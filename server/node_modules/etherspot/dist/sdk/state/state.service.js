"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StateService = void 0;
const class_transformer_1 = require("class-transformer");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const common_1 = require("../common");
const classes_1 = require("./classes");
class StateService extends common_1.Service {
    constructor(options = {}) {
        super();
        this.options = options;
        this.state$ = new rxjs_1.BehaviorSubject(null);
    }
    get state() {
        return this.state$.value;
    }
    get wallet$() {
        return this.services.walletService.wallet$;
    }
    get wallet() {
        return this.services.walletService.wallet;
    }
    get walletAddress$() {
        return this.services.walletService.walletAddress$;
    }
    get walletAddress() {
        return this.services.walletService.walletAddress;
    }
    get account$() {
        return this.services.accountService.account$;
    }
    get account() {
        return this.services.accountService.account;
    }
    get accountAddress$() {
        return this.services.accountService.accountAddress$;
    }
    get accountAddress() {
        return this.services.accountService.accountAddress;
    }
    get accountMember$() {
        return this.services.accountService.accountMember$;
    }
    get accountMember() {
        return this.services.accountService.accountMember;
    }
    get p2pPaymentDepositAddress$() {
        return this.services.p2pPaymentsService.p2pPaymentDepositAddress$;
    }
    get p2pPaymentDepositAddress() {
        return this.services.p2pPaymentsService.p2pPaymentDepositAddress;
    }
    get gatewayBatch$() {
        return this.services.gatewayService.gatewayBatch$;
    }
    get gatewayBatch() {
        return this.services.gatewayService.gatewayBatch;
    }
    get network() {
        return this.services.networkService.network;
    }
    get network$() {
        return this.services.networkService.network$;
    }
    restore(state) {
        const { accountService: { account$, accountMember$ }, p2pPaymentsService: { p2pPaymentDepositAddress$ }, } = this.services;
        if (state) {
            state = class_transformer_1.plainToClass(classes_1.State, state);
            const { account, accountMember, p2pPaymentDepositAddress } = state;
            account$.next(account);
            accountMember$.next(accountMember);
            p2pPaymentDepositAddress$.next(p2pPaymentDepositAddress);
        }
        return this;
    }
    dump() {
        return {
            account: this.account,
            accountMember: this.accountMember,
            p2pPaymentDepositAddress: this.p2pPaymentDepositAddress,
        };
    }
    onInit() {
        const { storage } = this.options || {};
        const { walletService: { wallet$, wallet }, accountService: { account$, accountMember$ }, p2pPaymentsService: { p2pPaymentDepositAddress$ }, gatewayService: { gatewayBatch$ }, networkService: { network$, network }, } = this.services;
        const callback = () => {
            this.addSubscriptions(rxjs_1.combineLatest([
                wallet$,
                account$,
                accountMember$,
                p2pPaymentDepositAddress$,
                gatewayBatch$,
                network$,
            ])
                .pipe(operators_1.map(([wallet, account, accountMember, p2pPaymentDepositAddress, gatewayBatch, network,]) => ({
                wallet,
                account,
                accountMember,
                p2pPaymentDepositAddress,
                gatewayBatch,
                network,
            })))
                .subscribe(this.state$), !storage
                ? null
                : this.state$
                    .pipe(operators_1.filter((state) => state &&
                    state.wallet &&
                    state.wallet.address &&
                    state.network &&
                    state.network.name &&
                    true), operators_1.tap((state) => {
                    const { wallet, network } = state, storageState = __rest(state, ["wallet", "network"]);
                    delete storageState.gatewayBatch;
                    this.error$.catch(() => storage.setState(wallet.address, network.name, storageState));
                }))
                    .subscribe());
        };
        if (storage) {
            this.error$.catch(async () => {
                const walletAddress = wallet && wallet.address ? wallet.address : null;
                const networkName = network && network.name ? network.name : null;
                if (walletAddress && networkName) {
                    const state = await storage.getState(walletAddress, networkName);
                    this.restore(state);
                }
            }, callback);
        }
        else {
            callback();
        }
    }
}
exports.StateService = StateService;
