"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GatewayService = void 0;
const core_1 = require("@apollo/client/core");
const ethers_1 = require("ethers");
const common_1 = require("../common");
const classes_1 = require("./classes");
const utils_1 = require("./utils");
class GatewayService extends common_1.Service {
    constructor() {
        super(...arguments);
        this.gatewayBatch$ = new common_1.UniqueSubject(null);
        this.estimationOptions = null;
    }
    get gatewayBatch() {
        return this.gatewayBatch$.value;
    }
    batchGatewayTransactionRequest(transactionRequest) {
        const { to, data } = transactionRequest;
        const gatewayBatch = Object.assign(Object.assign({ requests: [] }, (this.gatewayBatch || {})), { estimation: null });
        gatewayBatch.requests.push({
            to,
            data: ethers_1.utils.hexlify(data),
        });
        this.gatewayBatch$.next(gatewayBatch);
        return this.gatewayBatch;
    }
    clearGatewayBatch() {
        this.estimationOptions = null;
        this.gatewayBatch$.next(null);
    }
    async getGatewaySupportedToken(token) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int, $token: String!) {
          result: gatewaySupportedToken(chainId: $chainId, token: $token) {
            address
            exchangeRate
          }
        }
      `, {
            models: {
                result: classes_1.GatewaySupportedToken,
            },
            variables: {
                token,
            },
        });
        return result;
    }
    async getGatewaySupportedTokens() {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int) {
          result: gatewaySupportedTokens(chainId: $chainId) {
            items {
              address
              exchangeRate
            }
          }
        }
      `, {
            models: {
                result: classes_1.GatewaySupportedTokens,
            },
        });
        return result.items;
    }
    async getGatewaySubmittedBatch(hash) {
        const { apiService, contractService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int, $hash: String!) {
          result: gatewayBatch(chainId: $chainId, hash: $hash) {
            transaction {
              hash
              state
              sender
              gasPrice
              gasUsed
              totalCost
              createdAt
              updatedAt
            }
            logs {
              address
              data
              topics
            }
            hash
            state
            account
            nonce
            to
            data
            senderSignature
            estimatedGas
            estimatedGasPrice
            feeToken
            feeAmount
            feeData
            delayedUntil
            createdAt
            updatedAt
          }
        }
      `, {
            models: {
                result: classes_1.GatewaySubmittedBatch,
            },
            variables: {
                hash,
            },
        });
        if (result && result.logs) {
            result.events = contractService.processContractsLogs(result.logs);
        }
        return result;
    }
    async getGatewaySubmittedBatches(page = null) {
        const { accountService, apiService } = this.services;
        const account = accountService.accountAddress;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int, $account: String!, $page: Int) {
          result: gatewayBatches(chainId: $chainId, account: $account, page: $page) {
            items {
              transaction {
                hash
                state
                sender
                gasPrice
                gasUsed
                totalCost
                createdAt
                updatedAt
              }
              logs {
                address
                data
                topics
              }
              hash
              state
              account
              nonce
              to
              data
              senderSignature
              estimatedGas
              estimatedGasPrice
              feeToken
              feeAmount
              feeData
              createdAt
              updatedAt
            }
            currentPage
            nextPage
          }
        }
      `, {
            models: {
                result: classes_1.GatewaySubmittedBatches,
            },
            variables: {
                account,
                page: page || 1,
            },
        });
        return result;
    }
    async getGatewaySubmittedPendingBatches(page = null) {
        const { accountService, apiService } = this.services;
        const account = accountService.accountAddress;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int, $account: String!, $page: Int) {
          result: gatewayPendingBatches(chainId: $chainId, account: $account, page: $page) {
            items {
              transaction {
                hash
                state
                sender
                gasPrice
                gasUsed
                totalCost
                createdAt
                updatedAt
              }
              hash
              state
              account
              nonce
              to
              data
              senderSignature
              estimatedGas
              estimatedGasPrice
              feeToken
              feeAmount
              feeData
              createdAt
              updatedAt
            }
            currentPage
            nextPage
          }
        }
      `, {
            models: {
                result: classes_1.GatewaySubmittedBatches,
            },
            variables: {
                account,
                page: page || 1,
            },
        });
        return result;
    }
    async getGatewayTransaction(hash) {
        const { apiService, contractService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int, $hash: String!) {
          result: gatewayTransaction(chainId: $chainId, hash: $hash) {
            hash
            state
            sender
            gasPrice
            gasUsed
            totalCost
            createdAt
            updatedAt
            batches {
              logs {
                address
                data
                topics
              }
              hash
              state
              account
              nonce
              to
              data
              senderSignature
              estimatedGas
              estimatedGasPrice
              feeToken
              feeAmount
              feeData
              createdAt
              updatedAt
            }
          }
        }
      `, {
            models: {
                result: classes_1.GatewayTransaction,
            },
            variables: {
                hash,
            },
        });
        if (result && result.batches && Array.isArray(result.batches)) {
            result.batches = result.batches.map((batch) => {
                if (batch.logs) {
                    batch.events = contractService.processContractsLogs(batch.logs);
                }
                return batch;
            });
        }
        return result;
    }
    async getGatewayGasInfo() {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int) {
          result: gatewayGasInfo(chainId: $chainId) {
            standard
            fast
            instant
          }
        }
      `, {
            models: {
                result: classes_1.GatewayGasInfo,
            },
        });
        return result;
    }
    async estimateGatewayBatch(feeToken, statelessBatch) {
        if (!this.gatewayBatch && !statelessBatch) {
            throw new common_1.Exception('Can not estimate empty batch');
        }
        const { to, data } = this.extractToAndData(statelessBatch);
        const nonce = utils_1.uniqueNonce();
        const { accountService, apiService } = this.services;
        const account = accountService.accountAddress;
        const { estimation } = await apiService.mutate(core_1.gql `
        mutation(
          $chainId: Int
          $account: String!
          $nonce: Int!
          $to: [String!]!
          $data: [String!]!
          $feeToken: String
        ) {
          estimation: estimateGatewayBatch(
            chainId: $chainId
            account: $account
            nonce: $nonce
            to: $to
            data: $data
            feeToken: $feeToken
          ) {
            feeAmount
            feeTokenReceiver
            estimatedGas
            estimatedGasPrice
            signature
            createdAt
            expiredAt
          }
        }
      `, {
            models: {
                estimation: classes_1.GatewayEstimatedBatch,
            },
            variables: {
                account,
                nonce,
                to,
                data,
                feeToken,
            },
        });
        if (statelessBatch) {
            return Object.assign(Object.assign({}, statelessBatch), { estimation });
        }
        this.estimationOptions = {
            nonce,
            feeToken,
        };
        this.gatewayBatch$.next(Object.assign(Object.assign({}, this.gatewayBatch), { estimation }));
        return this.gatewayBatch;
    }
    async estimateGatewayKnownOp(op, feeToken = null) {
        const { accountService, apiService } = this.services;
        const account = accountService.accountAddress;
        const { result } = await apiService.mutate(core_1.gql `
        mutation($chainId: Int, $account: String!, $op: GatewayKnownOps!, $feeToken: String) {
          result: estimateGatewayKnownOp(chainId: $chainId, account: $account, op: $op, feeToken: $feeToken) {
            feeAmount
            estimatedGas
            estimatedGasPrice
          }
        }
      `, {
            models: {
                result: classes_1.GatewayEstimatedKnownOp,
            },
            variables: {
                account,
                op,
                feeToken,
            },
        });
        return result;
    }
    async submitGatewayBatch(statelessBatch) {
        if (!this.gatewayBatch && !statelessBatch) {
            throw new common_1.Exception('Can not submit empty batch');
        }
        const { estimation } = (statelessBatch === null || statelessBatch === void 0 ? void 0 : statelessBatch.estimation) ? statelessBatch : this.gatewayBatch;
        if (!estimation || estimation.expiredAt.getTime() < estimation.createdAt.getTime()) {
            throw new common_1.Exception('Can not submit not estimated batch');
        }
        const { to, data } = this.extractToAndData(statelessBatch);
        const { feeTokenReceiver, feeAmount, estimatedGas, estimatedGasPrice, expiredAt: estimationExpiredAt, signature: estimationSignature, } = estimation;
        const guarded = statelessBatch.guarded !== false;
        const { nonce, feeToken } = this.estimationOptions;
        const { accountService, walletService, apiService } = this.services;
        const { gatewayContract, personalAccountRegistryContract, erc20TokenContract, } = this.internalContracts;
        const account = accountService.accountAddress;
        let feeTransactionRequest;
        if (feeToken) {
            const { data } = erc20TokenContract.encodeTransfer(feeTokenReceiver, feeAmount);
            feeTransactionRequest = personalAccountRegistryContract.encodeExecuteAccountTransaction(account, feeToken, 0, data);
        }
        else {
            feeTransactionRequest = personalAccountRegistryContract.encodeRefundAccountCall(account, null, feeAmount);
        }
        const destinations = [...to, feeTransactionRequest.to];
        const datas = [...data, feeTransactionRequest.data];
        if (guarded) {
            const guardedTx = this.guardedTransactionRequest();
            if (guardedTx) {
                destinations.unshift(guardedTx.to);
                datas.unshift(guardedTx.data);
            }
        }
        const messageHash = gatewayContract.hashDelegatedBatch(account, nonce, destinations, datas);
        const senderSignature = await walletService.signMessage(messageHash);
        const { result } = await apiService.mutate(core_1.gql `
        mutation(
          $chainId: Int
          $account: String!
          $nonce: Int!
          $to: [String!]!
          $data: [String!]!
          $feeToken: String
          $feeAmount: BigNumber!
          $senderSignature: String!
          $estimatedGas: Int!
          $estimatedGasPrice: BigNumber!
          $estimationExpiredAt: DateTime!
          $estimationSignature: String!
          $guarded: Boolean,
        ) {
          result: submitGatewayBatch(
            chainId: $chainId
            account: $account
            nonce: $nonce
            to: $to
            data: $data
            feeToken: $feeToken
            feeAmount: $feeAmount
            senderSignature: $senderSignature
            estimatedGas: $estimatedGas
            estimatedGasPrice: $estimatedGasPrice
            estimationExpiredAt: $estimationExpiredAt
            estimationSignature: $estimationSignature
            guarded: $guarded
          ) {
            transaction {
              hash
              state
              sender
              gasPrice
              gasUsed
              totalCost
              createdAt
              updatedAt
            }
            hash
            state
            account
            nonce
            to
            data
            senderSignature
            estimatedGas
            estimatedGasPrice
            feeToken
            feeAmount
            feeData
            delayedUntil
            createdAt
            updatedAt
          }
        }
      `, {
            models: {
                result: classes_1.GatewaySubmittedBatch,
            },
            variables: {
                account,
                nonce,
                to,
                data,
                feeToken,
                feeAmount,
                senderSignature,
                estimatedGas,
                estimatedGasPrice,
                estimationExpiredAt,
                estimationSignature,
                guarded,
            },
        });
        if (!statelessBatch || (!statelessBatch.requests && !statelessBatch.estimation)) {
            this.clearGatewayBatch();
        }
        return result;
    }
    async cancelGatewayBatch(hash) {
        const { accountService, apiService } = this.services;
        const { accountAddress } = accountService;
        const { result } = await apiService.mutate(core_1.gql `
        mutation($chainId: Int, $account: String!, $hash: String!) {
          result: cancelGatewayBatch(chainId: $chainId, account: $account, hash: $hash) {
            hash
            state
            account
            nonce
            to
            data
            senderSignature
            estimatedGas
            estimatedGasPrice
            feeToken
            feeAmount
            feeData
            delayedUntil
            createdAt
            updatedAt
          }
        }
      `, {
            models: {
                result: classes_1.GatewaySubmittedBatch,
            },
            variables: {
                account: accountAddress,
                hash,
            },
        });
        return result;
    }
    async forceGatewayBatch(hash) {
        const { accountService, apiService } = this.services;
        const { accountAddress } = accountService;
        const { result } = await apiService.mutate(core_1.gql `
        mutation($chainId: Int, $account: String!, $hash: String!) {
          result: forceGatewayBatch(chainId: $chainId, account: $account, hash: $hash) {
            hash
            state
            account
            nonce
            to
            data
            senderSignature
            estimatedGas
            estimatedGasPrice
            feeToken
            feeAmount
            feeData
            delayedUntil
            createdAt
            updatedAt
          }
        }
      `, {
            models: {
                result: classes_1.GatewaySubmittedBatch,
            },
            variables: {
                account: accountAddress,
                hash,
            },
        });
        return result;
    }
    async encodeGatewayBatch(delegate) {
        if (!this.gatewayBatch) {
            throw new common_1.Exception('Can not encode empty batch');
        }
        let result;
        const { accountService, walletService } = this.services;
        const { gatewayContract } = this.internalContracts;
        const account = accountService.accountAddress;
        const { to, data } = this.extractToAndData();
        if (delegate) {
            const nonce = utils_1.uniqueNonce();
            const messageHash = gatewayContract.hashDelegatedBatch(account, nonce, to, data);
            const senderSignature = await walletService.signMessage(messageHash);
            result = gatewayContract.encodeDelegateBatch(account, nonce, to, data, senderSignature);
        }
        else {
            result = gatewayContract.encodeSendBatchFromAccount(account, to, data);
        }
        this.clearGatewayBatch();
        return result;
    }
    extractToAndData(statelessBatch) {
        return ((statelessBatch === null || statelessBatch === void 0 ? void 0 : statelessBatch.requests) ? statelessBatch : this.gatewayBatch).requests.reduce((result, { to, data }) => {
            result.to.push(to);
            result.data.push(data);
            return result;
        }, {
            to: [],
            data: [],
        });
    }
    guardedTransactionRequest() {
        const { gatewayContract, personalAccountRegistryContract, gatewayV2Contract, } = this.internalContracts;
        if (gatewayV2Contract.address &&
            gatewayV2Contract.address !== ethers_1.constants.AddressZero) {
            const guardedTxContent = personalAccountRegistryContract.encodeIsAccountDeployed(gatewayContract.address);
            return gatewayV2Contract.encodeSendBatchFromAccountGuarded(gatewayContract.address, [guardedTxContent.to], [guardedTxContent.data]);
        }
        return null;
    }
}
exports.GatewayService = GatewayService;
