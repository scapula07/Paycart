"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sdk = void 0;
const ethers_1 = require("ethers");
const contracts_1 = require("@etherspot/contracts");
const account_1 = require("./account");
const api_1 = require("./api");
const assets_1 = require("./assets");
const block_1 = require("./block");
const common_1 = require("./common");
const context_1 = require("./context");
const contract_1 = require("./contract");
const dto_1 = require("./dto");
const ens_1 = require("./ens");
const env_1 = require("./env");
const exchange_1 = require("./exchange");
const faucet_1 = require("./faucet");
const gateway_1 = require("./gateway");
const name_resolution_1 = require("./name-resolution");
const network_1 = require("./network");
const notification_1 = require("./notification");
const payments_1 = require("./payments");
const project_1 = require("./project");
const rates_1 = require("./rates");
const session_1 = require("./session");
const transactions_1 = require("./transactions");
const state_1 = require("./state");
const wallet_1 = require("./wallet");
class Sdk {
    constructor(walletProvider, optionsLike) {
        let options = {};
        if (!wallet_1.isWalletProvider(walletProvider)) {
            throw new common_1.Exception('Invalid wallet provider');
        }
        if (optionsLike) {
            switch (typeof optionsLike) {
                case 'string':
                    options = {
                        env: optionsLike,
                    };
                    break;
                case 'object':
                    options = optionsLike;
                    break;
            }
        }
        const env = env_1.Env.prepare(options.env);
        const { networkName, omitWalletProviderNetworkCheck, projectKey, projectMetadata, stateStorage, sessionStorage, } = options;
        const { apiOptions, networkOptions } = env;
        this.internalContracts = {
            ensControllerContract: new contract_1.ENSControllerContract(),
            ensReverseRegistrarContract: new contract_1.ENSReverseRegistrarContract(),
            erc20TokenContract: new contract_1.ERC20TokenContract(),
            gatewayContract: new contract_1.GatewayContract(),
            paymentRegistryContract: new contract_1.PaymentRegistryContract(),
            personalAccountRegistryContract: new contract_1.PersonalAccountRegistryContract(),
            gatewayV2Contract: new contract_1.GatewayV2Contract(),
        };
        this.services = {
            networkService: new network_1.NetworkService(networkOptions, networkName),
            walletService: new wallet_1.WalletService(walletProvider, {
                omitProviderNetworkCheck: omitWalletProviderNetworkCheck,
            }),
            sessionService: new session_1.SessionService({
                storage: sessionStorage,
            }),
            accountService: new account_1.AccountService(),
            apiService: new api_1.ApiService(apiOptions),
            assetsService: new assets_1.AssetsService(),
            blockService: new block_1.BlockService(),
            ensService: new ens_1.ENSService(),
            exchangeService: new exchange_1.ExchangeService(),
            faucetService: new faucet_1.FaucetService(),
            gatewayService: new gateway_1.GatewayService(),
            nameResolutionService: new name_resolution_1.NameResolutionService(),
            notificationService: new notification_1.NotificationService(),
            p2pPaymentsService: new payments_1.P2PPaymentService(),
            paymentHubService: new payments_1.PaymentHubService(),
            projectService: new project_1.ProjectService({
                key: projectKey,
                metadata: projectMetadata,
            }),
            transactionsService: new transactions_1.TransactionsService(),
            stateService: new state_1.StateService({
                storage: stateStorage,
            }),
            contractService: new contract_1.ContractService(),
            ratesService: new rates_1.RatesService(),
        };
        this.context = new context_1.Context(this.internalContracts, this.services);
    }
    get api() {
        return this.services.apiService;
    }
    get notifications$() {
        return this.services.notificationService.subscribeNotifications();
    }
    get state() {
        return this.services.stateService;
    }
    get state$() {
        return this.services.stateService.state$;
    }
    get error$() {
        return this.context.error$;
    }
    get supportedNetworks() {
        return this.services.networkService.supportedNetworks;
    }
    destroy() {
        this.context.destroy();
    }
    async signMessage(dto) {
        const { message } = await dto_1.validateDto(dto, dto_1.SignMessageDto);
        await this.require({
            network: false,
        });
        return this.services.walletService.signMessage(message);
    }
    async createSession(dto = {}) {
        const { ttl, fcmToken } = await dto_1.validateDto(dto, dto_1.CreateSessionDto);
        await this.require();
        return this.services.sessionService.createSession(ttl, fcmToken);
    }
    async getGatewaySupportedToken(dto) {
        const { token } = await dto_1.validateDto(dto, dto_1.GetGatewaySupportedTokenDto, {
            addressKeys: ['token'],
        });
        const { gatewayService } = this.services;
        return gatewayService.getGatewaySupportedToken(token);
    }
    async getGatewaySupportedTokens() {
        return this.services.gatewayService.getGatewaySupportedTokens();
    }
    async getGatewaySubmittedBatch(dto) {
        const { hash } = await dto_1.validateDto(dto, dto_1.GetGatewaySubmittedBatchDto);
        return this.services.gatewayService.getGatewaySubmittedBatch(hash);
    }
    async getGatewaySubmittedBatches(dto = {}) {
        const { page } = await dto_1.validateDto(dto, dto_1.PaginationDto);
        await this.require({
            session: true,
            contractAccount: true,
        });
        return this.services.gatewayService.getGatewaySubmittedBatches(page || 1);
    }
    async getGatewaySubmittedPendingBatches(dto = {}) {
        const { page } = await dto_1.validateDto(dto, dto_1.PaginationDto);
        await this.require({
            session: true,
            contractAccount: true,
        });
        return this.services.gatewayService.getGatewaySubmittedPendingBatches(page || 1);
    }
    async getGatewayTransaction(dto) {
        const { hash } = await dto_1.validateDto(dto, dto_1.GetGatewaySubmittedBatchDto);
        return this.services.gatewayService.getGatewayTransaction(hash);
    }
    async getGatewayGasInfo() {
        return this.services.gatewayService.getGatewayGasInfo();
    }
    async batchGatewayTransactionRequest(dto) {
        const { to, data } = await dto_1.validateDto(dto, dto_1.BatchGatewayTransactionRequestDto, {
            addressKeys: ['to'],
        });
        await this.require();
        const { gatewayService } = this.services;
        return gatewayService.batchGatewayTransactionRequest({
            to,
            data,
        });
    }
    async estimateGatewayKnownOp(dto) {
        const { op, feeToken } = await dto_1.validateDto(dto, dto_1.EstimateGatewayKnownOpDto, {
            addressKeys: ['feeToken'],
        });
        await this.require({
            session: true,
        });
        return this.services.gatewayService.estimateGatewayKnownOp(op, feeToken);
    }
    async estimateGatewayBatch(dto = {}) {
        const { feeToken } = await dto_1.validateDto(dto, dto_1.EstimateGatewayBatchDto, {
            addressKeys: ['feeToken'],
        });
        await this.require({
            session: true,
            contractAccount: true,
        });
        return this.services.gatewayService.estimateGatewayBatch(feeToken);
    }
    async estimateStatelessAccountTransactions(transactionsDto, estimationDto = {}) {
        const { gatewayService } = this.services;
        const gatewayBatch = {
            requests: [],
            estimation: null,
        };
        const { feeToken } = await dto_1.validateDto(estimationDto, dto_1.EstimateGatewayBatchDto, {
            addressKeys: ['feeToken'],
        });
        for (const transactionDto of transactionsDto) {
            const encodedAccountTransaction = await this.encodeExecuteAccountTransaction(transactionDto);
            const { to, data } = encodedAccountTransaction;
            gatewayBatch.requests.push({
                to,
                data: ethers_1.utils.hexlify(data),
            });
        }
        return gatewayService.estimateGatewayBatch(feeToken, gatewayBatch);
    }
    async submitGatewayBatch(dto = {}) {
        const { customProjectMetadata } = await dto_1.validateDto(dto, dto_1.CustomProjectMetadataDto);
        await this.require({
            session: true,
            contractAccount: true,
        });
        const { gatewayService, projectService } = this.services;
        return projectService.withCustomProjectMetadata(customProjectMetadata, () => gatewayService.submitGatewayBatch({
            requests: null,
            estimation: null,
            guarded: dto.guarded,
        }));
    }
    async cancelGatewayBatch(dto) {
        const { hash } = await dto_1.validateDto(dto, dto_1.CancelGatewayBatchDto);
        await this.require({
            session: true,
            contractAccount: true,
        });
        const { gatewayService } = this.services;
        return gatewayService.cancelGatewayBatch(hash);
    }
    async forceGatewayBatch(dto) {
        const { hash } = await dto_1.validateDto(dto, dto_1.CancelGatewayBatchDto);
        await this.require({
            session: true,
            contractAccount: true,
        });
        const { gatewayService } = this.services;
        return gatewayService.forceGatewayBatch(hash);
    }
    async encodeGatewayBatch(dto = {}) {
        const { delegate } = await dto_1.validateDto(dto, dto_1.EncodeGatewayBatchDto);
        await this.require();
        return this.services.gatewayService.encodeGatewayBatch(delegate);
    }
    clearGatewayBatch() {
        this.services.gatewayService.clearGatewayBatch();
    }
    async switchCurrentProject(dto = null) {
        let currentProject = null;
        if (dto) {
            currentProject = await dto_1.validateDto(dto, dto_1.SwitchCurrentProjectDto);
        }
        return this.services.projectService.switchCurrentProject(currentProject);
    }
    async callCurrentProject(dto = {}) {
        await this.require({
            session: true,
            currentProject: true,
        });
        const { payload, customProjectMetadata } = await dto_1.validateDto(dto, dto_1.CallCurrentProjectDto);
        const { projectService } = this.services;
        return projectService.withCustomProjectMetadata(customProjectMetadata, () => projectService.callCurrentProject(payload));
    }
    async getProject(dto) {
        const { key } = await dto_1.validateDto(dto, dto_1.GetProjectDto);
        return this.services.projectService.getProject(key);
    }
    async getProjects(dto) {
        await this.require({
            session: true,
        });
        const { page } = await dto_1.validateDto(dto, dto_1.PaginationDto);
        return this.services.projectService.getProjects(page || 1);
    }
    async updateProject(dto) {
        await this.require({
            session: true,
        });
        const { key, privateKey, endpoint } = await dto_1.validateDto(dto, dto_1.UpdateProjectDto);
        return this.services.projectService.updateProject(key, privateKey, endpoint);
    }
    async syncAccount() {
        await this.require({
            session: true,
        });
        return this.services.accountService.syncAccount();
    }
    async computeContractAccount(dto = {}) {
        const { sync } = await dto_1.validateDto(dto, dto_1.ComputeContractAccountDto);
        await this.require({
            session: sync,
        });
        const { accountService } = this.services;
        accountService.computeContractAccount();
        if (sync) {
            await accountService.syncAccount();
        }
        return accountService.account;
    }
    async computeContractAccountByAddress(dto) {
        const { address } = await dto_1.validateDto(dto, dto_1.ComputeContractAccountByAddressDto);
        const { personalAccountRegistryContract } = this.internalContracts;
        return personalAccountRegistryContract.computeAccountAddress(address);
    }
    async joinContractAccount(dto) {
        const { address, sync } = await dto_1.validateDto(dto, dto_1.JoinContractAccountDto, {
            addressKeys: ['address'],
        });
        await this.require({
            session: sync,
        });
        const { accountService } = this.services;
        accountService.joinContractAccount(address);
        if (sync) {
            await accountService.syncAccount();
        }
        return accountService.account;
    }
    async getConnectedAccounts(dto = {}) {
        const { page } = await dto_1.validateDto(dto, dto_1.PaginationDto);
        await this.require({
            session: true,
        });
        return this.services.accountService.getConnectedAccounts(page || 1);
    }
    async getAccount(dto = {}) {
        const { address } = await dto_1.validateDto(dto, dto_1.GetAccountDto, {
            addressKeys: ['address'],
        });
        await this.require({
            wallet: !address,
        });
        return this.services.accountService.getAccount(this.prepareAccountAddress(address));
    }
    async getAccountBalances(dto = {}) {
        const { account, tokens, chainId, provider } = await dto_1.validateDto(dto, dto_1.GetAccountBalancesDto, {
            addressKeys: ['account', 'tokens'],
        });
        await this.require({
            wallet: !account,
        });
        const ChainId = chainId ? chainId : this.services.networkService.chainId;
        return this.services.accountService.getAccountBalances(this.prepareAccountAddress(account), tokens, ChainId, provider);
    }
    async getAccountInvestments(dto = {}) {
        const { account, apps, chainId, provider } = await dto_1.validateDto(dto, dto_1.GetAccountInvestmentsDto, {
            addressKeys: ['account', 'apps'],
        });
        await this.require({
            wallet: !account,
            contractAccount: true,
        });
        return this.services.accountService.getAccountInvestments(this.prepareAccountAddress(account), chainId || this.services.networkService.chainId, apps, provider);
    }
    async getAccount24HourNetCurve(dto = {}) {
        const { account, chainIds } = await dto_1.validateDto(dto, dto_1.GetAccount24HourNetCurveDto, {
            addressKeys: ['account'],
        });
        await this.require({
            wallet: !account,
        });
        return this.services.accountService.getAccount24HourNetCurve(this.prepareAccountAddress(account), chainIds);
    }
    async getAccountTotalBalances(dto) {
        const { account, currency } = await dto_1.validateDto(dto, dto_1.GetAccountTotalBalancesDto, {
            addressKeys: ['account'],
        });
        await this.require({
            wallet: !account,
        });
        return this.services.accountService.getAccountTotalBalances(this.prepareAccountAddress(account), currency);
    }
    async getAccountMembers(dto = {}) {
        const { account, page } = await dto_1.validateDto(dto, dto_1.GetAccountMembersDto, {
            addressKeys: ['account'],
        });
        await this.require({
            wallet: !account,
        });
        return this.services.accountService.getAccountMembers(this.prepareAccountAddress(account), page || 1);
    }
    async getDelayTransactionOptions() {
        await this.require({
            session: true,
        });
        return this.services.accountService.getDelayTransactionOptions();
    }
    async getAccountSettings() {
        await this.require({
            contractAccount: true,
        });
        return this.services.accountService.getAccountSettings();
    }
    async updateAccountSettings(dto) {
        await this.require({
            contractAccount: true,
        });
        return this.services.accountService.updateAccountSettings(dto);
    }
    async isEligibleForAirdrop(dto) {
        return this.services.accountService.isEligibleForAirdrop(dto);
    }
    async encodeDeployAccount() {
        await this.require({
            contractAccount: true,
        });
        const { personalAccountRegistryContract } = this.internalContracts;
        const { accountService } = this.services;
        return personalAccountRegistryContract.encodeDeployAccount(accountService.accountAddress);
    }
    async encodeAddAccountOwner(dto) {
        const { owner } = await dto_1.validateDto(dto, dto_1.AddAccountOwnerDto, {
            addressKeys: ['owner'],
        });
        await this.require({
            contractAccount: true,
        });
        const { personalAccountRegistryContract } = this.internalContracts;
        const { accountService } = this.services;
        return personalAccountRegistryContract.encodeAddAccountOwner(accountService.accountAddress, owner);
    }
    async encodeRemoveAccountOwner(dto) {
        const { owner } = await dto_1.validateDto(dto, dto_1.RemoveAccountOwnerDto, {
            addressKeys: ['owner'],
        });
        await this.require({
            contractAccount: true,
        });
        const { personalAccountRegistryContract } = this.internalContracts;
        const { accountService } = this.services;
        return personalAccountRegistryContract.encodeRemoveAccountOwner(accountService.accountAddress, owner);
    }
    async encodeExecuteAccountTransaction(dto) {
        const { to, value, data } = await dto_1.validateDto(dto, dto_1.ExecuteAccountTransactionDto, {
            addressKeys: ['to'],
        });
        await this.require({
            contractAccount: true,
        });
        const { personalAccountRegistryContract } = this.internalContracts;
        const { accountService } = this.services;
        if (common_1.addressesEqual(accountService.accountAddress, to)) {
            throw new common_1.Exception('Destination address should not be the same as sender address');
        }
        return personalAccountRegistryContract.encodeExecuteAccountTransaction(accountService.accountAddress, to, value || 0, data || '0x');
    }
    async batchDeployAccount() {
        return this.batchGatewayTransactionRequest(await this.encodeDeployAccount());
    }
    async batchAddAccountOwner(dto) {
        return this.batchGatewayTransactionRequest(await this.encodeAddAccountOwner(dto));
    }
    async batchRemoveAccountOwner(dto) {
        return this.batchGatewayTransactionRequest(await this.encodeRemoveAccountOwner(dto));
    }
    async batchExecuteAccountTransaction(dto) {
        const transactionRequest = await this.encodeExecuteAccountTransaction(dto);
        return this.batchGatewayTransactionRequest(transactionRequest);
    }
    async reserveENSName(dto) {
        const { name } = await dto_1.validateDto(dto, dto_1.ReserveENSNameDto);
        await this.require({
            session: true,
        });
        return this.services.ensService.reserveENSNode(name);
    }
    async validateENSName(dto) {
        const { name } = await dto_1.validateDto(dto, dto_1.ReserveENSNameDto);
        await this.require({
            session: true,
        });
        return this.services.ensService.validateENSNode(name);
    }
    async getENSNode(dto = {}) {
        const { nameOrHashOrAddress } = await dto_1.validateDto(dto, dto_1.GetENSNodeDto);
        await this.require({
            wallet: !nameOrHashOrAddress,
        });
        const { ensService } = this.services;
        return ensService.getENSNode(this.prepareAccountAddress(nameOrHashOrAddress));
    }
    async getENSRootNode(dto) {
        const { name } = await dto_1.validateDto(dto, dto_1.GetENSRootNodeDto);
        await this.require({
            wallet: false,
        });
        const { ensService } = this.services;
        return ensService.getENSRootNode(name);
    }
    async getENSTopLevelDomains() {
        await this.require({
            wallet: false,
        });
        const { ensService } = this.services;
        return ensService.getENSTopLevelDomains();
    }
    async ensAddressesLookup(dto) {
        const { names } = await dto_1.validateDto(dto, dto_1.ENSAddressesLookupDto);
        await this.require({
            wallet: false,
        });
        const { ensService } = this.services;
        return ensService.ensAddressesLookup(names);
    }
    async ensNamesLookup(dto) {
        const { addresses } = await dto_1.validateDto(dto, dto_1.ENSNamesLookupDto);
        await this.require({
            wallet: false,
        });
        const { ensService } = this.services;
        return ensService.ensNamesLookup(addresses);
    }
    async encodeClaimENSNode(dto = {}) {
        const { nameOrHashOrAddress } = await dto_1.validateDto(dto, dto_1.ClaimENSNodeDto);
        await this.require({
            wallet: !nameOrHashOrAddress,
        });
        const ensNode = await this.getENSNode({
            nameOrHashOrAddress,
        });
        if (!ensNode || ensNode.state !== ens_1.ENSNodeStates.Reserved) {
            throw new common_1.Exception('Can not claim ens node');
        }
        const { name, guardianSignature } = ensNode;
        const parsedName = ens_1.parseENSName(name);
        const { ensControllerContract } = this.internalContracts;
        return ensControllerContract.encodeRegisterSubNode(parsedName.root.hash, parsedName.labelHash, guardianSignature);
    }
    async encodeSetENSRecordName(dto = {}) {
        let { name } = await dto_1.validateDto(dto, dto_1.SetENSRecordNameDto);
        await this.require();
        const { accountService } = this.services;
        const { accountAddress } = accountService;
        const ensNode = await this.getENSNode({
            nameOrHashOrAddress: accountAddress,
        });
        if (!ensNode) {
            throw new common_1.Exception('Can not set ens record name');
        }
        const { hash } = ensNode;
        if (!name) {
            ({ name } = ensNode);
        }
        const { ensControllerContract } = this.internalContracts;
        return ensControllerContract.encodeSetName(hash, name);
    }
    async encodeSetENSRecordText(dto) {
        const { key, value } = await dto_1.validateDto(dto, dto_1.SetENSRecordTextDto);
        await this.require();
        const { accountService } = this.services;
        const { accountAddress } = accountService;
        const ensNode = await this.getENSNode({
            nameOrHashOrAddress: accountAddress,
        });
        if (!ensNode) {
            throw new common_1.Exception('Can not set ens record text');
        }
        const { hash } = ensNode;
        const { ensControllerContract } = this.internalContracts;
        return ensControllerContract.encodeSetText(hash, key, value);
    }
    async encodeClaimENSReverseName() {
        await this.require();
        const { accountService, ensService } = this.services;
        const { accountAddress } = accountService;
        const ensNode = await this.getENSNode({
            nameOrHashOrAddress: accountAddress,
        });
        if (!ensNode) {
            throw new common_1.Exception('Can not claim ens reverse name');
        }
        const { name } = ensNode;
        const { ensReverseRegistrarContract } = this.internalContracts;
        const { data } = ensReverseRegistrarContract.encodeSetName(name);
        const to = await ensService.ensAddrReversOwner;
        const { personalAccountRegistryContract } = this.internalContracts;
        return personalAccountRegistryContract.encodeExecuteAccountTransaction(accountService.accountAddress, to, 0, data);
    }
    async batchClaimENSNode(dto = {}) {
        await this.require({
            contractAccount: true,
        });
        return this.batchGatewayTransactionRequest(await this.encodeClaimENSNode(dto));
    }
    async batchSetENSRecordName(dto = {}) {
        await this.require({
            contractAccount: true,
        });
        return this.batchGatewayTransactionRequest(await this.encodeSetENSRecordName(dto));
    }
    async batchSetENSRecordText(dto) {
        await this.require({
            contractAccount: true,
        });
        return this.batchGatewayTransactionRequest(await this.encodeSetENSRecordText(dto));
    }
    async batchClaimENSReverseName() {
        await this.require({
            contractAccount: true,
        });
        return this.batchGatewayTransactionRequest(await this.encodeClaimENSReverseName());
    }
    async getExchangeSupportedAssets(dto = {}) {
        const { page, limit, chainId } = await dto_1.validateDto(dto, dto_1.GetExchangeSupportedAssetsDto);
        await this.require({
            session: true,
        });
        const getChainId = chainId ? chainId : this.services.networkService.chainId;
        return this.services.exchangeService.getExchangeSupportedAssets(page, limit, getChainId);
    }
    async getExchangeOffers(dto) {
        const { fromTokenAddress, toTokenAddress, fromAmount, fromChainId, toAddress, fromAddress, showZeroUsd } = await dto_1.validateDto(dto, dto_1.GetExchangeOffersDto, {
            addressKeys: ['fromTokenAddress', 'toTokenAddress'],
        });
        await this.require({
            session: true,
            contractAccount: true,
        });
        let { chainId } = this.services.networkService;
        chainId = fromChainId ? fromChainId : chainId;
        return this.services.exchangeService.getExchangeOffers(fromTokenAddress, toTokenAddress, ethers_1.BigNumber.from(fromAmount), chainId, toAddress, fromAddress, showZeroUsd);
    }
    getCrossChainBridgeSupportedChains(dto) {
        return this.services.exchangeService.getCrossChainBridgeSupportedChains(dto);
    }
    getCrossChainBridgeTokenList(dto) {
        return this.services.exchangeService.getCrossChainBridgeTokenList(dto);
    }
    findCrossChainBridgeRoutes(dto) {
        return this.services.exchangeService.findCrossChainBridgeRoutes(dto);
    }
    buildCrossChainBridgeTransaction(dto) {
        return this.services.exchangeService.buildCrossChainBridgeTransaction(dto);
    }
    async getCrossChainQuotes(dto) {
        const { fromChainId, toChainId, fromTokenAddress, toTokenAddress, fromAmount, serviceProvider, lifiBridges, toAddress, fromAddress, showZeroUsd, } = await dto_1.validateDto(dto, dto_1.GetExchangeCrossChainQuoteDto, {
            addressKeys: ['fromTokenAddress', 'toTokenAddress'],
        });
        await this.require({
            session: true,
        });
        let { chainId } = this.services.networkService;
        chainId = fromChainId ? fromChainId : chainId;
        return this.services.exchangeService.getCrossChainQuotes(fromTokenAddress, toTokenAddress, chainId, toChainId, ethers_1.BigNumber.from(fromAmount), serviceProvider, lifiBridges, toAddress, fromAddress, showZeroUsd);
    }
    async getAdvanceRoutesLiFi(dto) {
        const { fromChainId, toChainId, fromTokenAddress, toTokenAddress, fromAmount, toAddress, allowSwitchChain, fromAddress, showZeroUsd, } = await dto_1.validateDto(dto, dto_1.GetAdvanceRoutesLiFiDto, {
            addressKeys: ['fromTokenAddress', 'toTokenAddress'],
        });
        let { chainId } = this.services.networkService;
        chainId = fromChainId ? fromChainId : chainId;
        const data = await this.services.exchangeService.getAdvanceRoutesLiFi(fromTokenAddress, toTokenAddress, chainId, toChainId, ethers_1.BigNumber.from(fromAmount), toAddress, allowSwitchChain, fromAddress, showZeroUsd);
        return data;
    }
    async getStepTransaction(dto) {
        return this.services.exchangeService.getStepTransaction(dto.route);
    }
    async getLiFiStatus(dto) {
        const { fromChainId, toChainId, txnHash, bridge } = dto;
        return this.services.exchangeService.getLiFiStatus(fromChainId, toChainId, txnHash, bridge);
    }
    async getP2PPaymentDeposits(dto = {}) {
        const { tokens } = await dto_1.validateDto(dto, dto_1.GetP2PPaymentDepositsDto, {
            addressKeys: ['tokens'],
        });
        await this.require({
            session: true,
        });
        const { accountService, p2pPaymentsService } = this.services;
        return p2pPaymentsService.syncP2PPaymentDeposits(accountService.accountAddress, tokens);
    }
    async getP2PPaymentChannel(dto) {
        const { hash } = await dto_1.validateDto(dto, dto_1.GetP2PPaymentChannelDto);
        await this.require({
            wallet: false,
        });
        const { p2pPaymentsService } = this.services;
        return p2pPaymentsService.getP2PPaymentChannel(hash);
    }
    async getP2PPaymentChannels(dto = {}) {
        const { senderOrRecipient, uncommittedOnly, page } = await dto_1.validateDto(dto, dto_1.GetP2PPaymentChannelsDto, {
            addressKeys: ['senderOrRecipient'],
        });
        await this.require({
            wallet: !senderOrRecipient,
        });
        const { p2pPaymentsService } = this.services;
        return p2pPaymentsService.getP2PPaymentChannels(this.prepareAccountAddress(senderOrRecipient), { uncommittedOnly }, page || 1);
    }
    async getP2PPaymentChannelsAdmin(dto = {}) {
        const validatedDto = await dto_1.validateDto(dto, dto_1.GetP2PPaymentChannelsAdminDto, {
            addressKeys: ['sender', 'recipient', 'token'],
        });
        await this.require({
            wallet: true,
            currentProject: true,
        });
        const { p2pPaymentsService } = this.services;
        return p2pPaymentsService.getP2PPaymentChannelsAdmin(validatedDto);
    }
    async increaseP2PPaymentChannelAmount(dto) {
        const { recipient, token, value } = await dto_1.validateDto(dto, dto_1.IncreaseP2PPaymentChannelAmountDto, {
            addressKeys: ['recipient', 'token'],
        });
        await this.require({
            session: true,
            currentProject: true,
        });
        const { accountService, p2pPaymentsService, projectService } = this.services;
        const now = new Date();
        const todayUTC = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));
        const saltDate = todayUTC.toISOString().slice(0, 10).replace(/-/g, '');
        return p2pPaymentsService.increaseP2PPaymentChannelAmount(recipient, token, ethers_1.BigNumber.from(value), `${accountService.accountAddress}${projectService.currentProject.key}${token}${saltDate}`);
    }
    async updateP2PPaymentChannel(dto) {
        const { recipient, token, totalAmount } = await dto_1.validateDto(dto, dto_1.UpdateP2PPaymentChannelDto, {
            addressKeys: ['recipient', 'token'],
        });
        await this.require({
            session: true,
        });
        const { p2pPaymentsService } = this.services;
        return p2pPaymentsService.updateP2PPaymentChannel(recipient, token, ethers_1.BigNumber.from(totalAmount));
    }
    async signP2PPaymentChannel(dto) {
        const { hash } = await dto_1.validateDto(dto, dto_1.SignP2PPaymentChannelDto);
        await this.require({
            session: true,
        });
        const { p2pPaymentsService } = this.services;
        return p2pPaymentsService.signP2PPaymentChannel(hash);
    }
    async encodeWithdrawP2PPaymentDeposit(dto) {
        const { token, amount } = await dto_1.validateDto(dto, dto_1.WithdrawP2PPaymentDepositDto, {
            addressKeys: ['token'],
        });
        await this.require({
            session: true,
        });
        const { p2pPaymentsService } = this.services;
        return p2pPaymentsService.buildP2PPaymentDepositWithdrawalTransactionRequest(await p2pPaymentsService.decreaseP2PPaymentDeposit(token, ethers_1.BigNumber.from(amount)));
    }
    async encodeP2PPaymentDepositWithdrawal(dto) {
        const { token } = await dto_1.validateDto(dto, dto_1.P2PPaymentDepositWithdrawalDto, {
            addressKeys: ['token'],
        });
        await this.require({
            session: true,
        });
        const { accountService, p2pPaymentsService } = this.services;
        const { accountAddress } = accountService;
        return p2pPaymentsService.buildP2PPaymentDepositWithdrawalTransactionRequest(await p2pPaymentsService.syncP2PPaymentDeposit(accountAddress, token));
    }
    async encodeCommitP2PPaymentChannel(dto) {
        const { hash, deposit } = await dto_1.validateDto(dto, dto_1.CommitP2PPaymentChannelDto);
        await this.require();
        const paymentChannel = await this.getP2PPaymentChannel({
            hash,
        });
        if (!paymentChannel) {
            throw new common_1.Exception('Payment channel not found');
        }
        const { sender, token, uid, totalAmount, latestPayment: { blockNumber, senderSignature, guardianSignature }, } = paymentChannel;
        const { paymentRegistryContract } = this.internalContracts;
        return deposit
            ? paymentRegistryContract.encodeCommitPaymentChannelAndDeposit(sender, token, uid, blockNumber, totalAmount, senderSignature, guardianSignature)
            : paymentRegistryContract.encodeCommitPaymentChannelAndWithdraw(sender, token, uid, blockNumber, totalAmount, senderSignature, guardianSignature);
    }
    async batchWithdrawP2PPaymentDeposit(dto) {
        await this.require({
            contractAccount: true,
        });
        return this.batchGatewayTransactionRequest(await this.encodeWithdrawP2PPaymentDeposit(dto));
    }
    async batchP2PPaymentDepositWithdrawal(dto) {
        await this.require({
            contractAccount: true,
        });
        return this.batchGatewayTransactionRequest(await this.encodeP2PPaymentDepositWithdrawal(dto));
    }
    async batchCommitP2PPaymentChannel(dto) {
        await this.require();
        return this.batchGatewayTransactionRequest(await this.encodeCommitP2PPaymentChannel(dto));
    }
    async getPaymentHub(dto) {
        const { hub, token } = await dto_1.validateDto(dto, dto_1.GetPaymentHubDto, {
            addressKeys: ['hub', 'token'],
        });
        await this.require({
            wallet: !hub,
        });
        const { paymentHubService } = this.services;
        return paymentHubService.getPaymentHub(this.prepareAccountAddress(hub), token);
    }
    async getPaymentHubs(dto = {}) {
        dto = await dto_1.validateDto(dto, dto_1.GetPaymentHubsDto, {
            addressKeys: ['hub', 'token'],
        });
        const { token, page } = dto;
        let { hub } = dto;
        await this.require({
            network: true,
            wallet: typeof hub === 'undefined',
        });
        if (typeof hub === 'undefined') {
            hub = this.prepareAccountAddress(hub);
        }
        const { paymentHubService } = this.services;
        return paymentHubService.getPaymentHubs(hub, token, page || 1);
    }
    async getPaymentHubBridge(dto = {}) {
        const { hub, token, acceptedNetworkName, acceptedToken } = await dto_1.validateDto(dto, dto_1.GetPaymentHubBridgeDto, {
            addressKeys: ['hub', 'token', 'acceptedToken'],
        });
        await this.require({
            wallet: !hub,
        });
        const { paymentHubService } = this.services;
        return paymentHubService.getPaymentHubBridge(this.prepareAccountAddress(hub), token, this.getNetworkChainId(acceptedNetworkName), acceptedToken);
    }
    async getPaymentHubBridges(dto) {
        const { hub, token, acceptedNetworkName, page } = await dto_1.validateDto(dto, dto_1.GetPaymentHubBridgesDto, {
            addressKeys: ['hub', 'token'],
        });
        await this.require({
            wallet: !hub,
        });
        let acceptedChainId;
        if (typeof acceptedNetworkName === 'undefined') {
            acceptedChainId = this.getNetworkChainId(acceptedNetworkName);
        }
        const { paymentHubService } = this.services;
        return paymentHubService.getPaymentHubBridges(this.prepareAccountAddress(hub), token, acceptedChainId, page || 1);
    }
    async getPaymentHubDeposit(dto) {
        const { hub, token, owner } = await dto_1.validateDto(dto, dto_1.GetPaymentHubDepositDto, {
            addressKeys: ['hub', 'token', 'owner'],
        });
        await this.require({
            wallet: !owner,
        });
        const { paymentHubService } = this.services;
        return paymentHubService.getPaymentHubDeposit(hub, token, this.prepareAccountAddress(owner));
    }
    async getPaymentHubDeposits(dto) {
        const { hub, tokens, owner, page } = await dto_1.validateDto(dto, dto_1.GetPaymentHubDepositsDto, {
            addressKeys: ['hub', 'tokens', 'owner'],
        });
        await this.require({
            wallet: !owner,
        });
        const { paymentHubService } = this.services;
        return paymentHubService.getPaymentHubDeposits(hub, tokens || [], this.prepareAccountAddress(owner), page || 1);
    }
    async getPaymentHubPayment(dto) {
        const { hash } = await dto_1.validateDto(dto, dto_1.GetPaymentHubPaymentDto);
        const { paymentHubService } = this.services;
        return paymentHubService.getPaymentHubPayment(hash);
    }
    async getPaymentHubPayments(dto) {
        const { hub, token, senderOrRecipient, page } = await dto_1.validateDto(dto, dto_1.GetPaymentHubPaymentsDto, {
            addressKeys: ['hub', 'token', 'senderOrRecipient'],
        });
        await this.require({
            session: true,
        });
        const { paymentHubService } = this.services;
        return paymentHubService.getPaymentHubPayments(hub, token, this.prepareAccountAddress(senderOrRecipient), page || 1);
    }
    async createPaymentHubPayment(dto) {
        const { hub, token, recipient, value } = await dto_1.validateDto(dto, dto_1.CreatePaymentHubPaymentDto, {
            addressKeys: ['hub', 'token', 'recipient'],
        });
        await this.require({
            session: true,
        });
        const { paymentHubService } = this.services;
        return paymentHubService.createPaymentHubPayment(hub, token, recipient, ethers_1.BigNumber.from(value));
    }
    async updatePaymentHub(dto = {}) {
        const { token, liquidity } = await dto_1.validateDto(dto, dto_1.UpdatePaymentHubDto, {
            addressKeys: ['token'],
        });
        await this.require({
            session: true,
        });
        const { paymentHubService } = this.services;
        return paymentHubService.updatePaymentHub(ethers_1.BigNumber.from(liquidity || 0), token);
    }
    async updatePaymentHubDeposit(dto) {
        const { hub, token, totalAmount } = await dto_1.validateDto(dto, dto_1.UpdatePaymentHubDepositDto, {
            addressKeys: ['hub', 'token'],
        });
        await this.require({
            session: true,
        });
        const { paymentHubService } = this.services;
        return paymentHubService.updatePaymentHubDeposit(hub, ethers_1.BigNumber.from(totalAmount || 0), token);
    }
    async transferPaymentHubDeposit(dto) {
        const { hub, token, value, targetNetworkName, targetHub, targetToken } = await dto_1.validateDto(dto, dto_1.TransferPaymentHubDepositDto, {
            addressKeys: ['hub', 'token', 'targetHub', 'targetToken'],
        });
        await this.require({
            session: true,
        });
        const { paymentHubService } = this.services;
        return paymentHubService.transferPaymentHubDeposit(hub, token, ethers_1.BigNumber.from(value), this.getNetworkChainId(targetNetworkName), targetHub, targetToken);
    }
    async activatePaymentHubBridge(dto) {
        const { token, acceptedNetworkName, acceptedToken } = await dto_1.validateDto(dto, dto_1.UpdatePaymentHubBridgeDto, {
            addressKeys: ['token', 'acceptedToken'],
        });
        await this.require({
            session: true,
        });
        const { paymentHubService } = this.services;
        return paymentHubService.activatePaymentHubBridge(token, this.getNetworkChainId(acceptedNetworkName), acceptedToken);
    }
    async deactivatePaymentHubBridge(dto) {
        const { token, acceptedNetworkName, acceptedToken } = await dto_1.validateDto(dto, dto_1.UpdatePaymentHubBridgeDto, {
            addressKeys: ['token', 'acceptedToken'],
        });
        await this.require({
            session: true,
        });
        const { paymentHubService } = this.services;
        return paymentHubService.deactivatePaymentHubBridge(token, this.getNetworkChainId(acceptedNetworkName), acceptedToken);
    }
    async getTokenLists() {
        await this.require({
            wallet: false,
        });
        return this.services.assetsService.getTokenLists();
    }
    async getTokenListTokens(dto = {}) {
        const { name } = await dto_1.validateDto(dto, dto_1.GetTokenListDto);
        await this.require({
            wallet: false,
        });
        return this.services.assetsService.getTokenListTokens(name);
    }
    async getNativeCurrencies() {
        return this.services.assetsService.getNativeCurrencies();
    }
    async getAccountTokenListTokens(dto = {}) {
        const { name } = await dto_1.validateDto(dto, dto_1.GetTokenListDto);
        await this.require({
            session: true,
        });
        return this.services.assetsService.getAccountTokenListTokens(name);
    }
    async isTokenOnTokenList(dto) {
        const { token, name } = await dto_1.validateDto(dto, dto_1.IsTokenOnTokenListDto, {
            addressKeys: ['token'],
        });
        await this.require({
            wallet: false,
        });
        return this.services.assetsService.isTokenOnTokenList(token, name);
    }
    async getTokenDetails(dto = {}) {
        const { tokenAddress, chainId, provider } = await dto_1.validateDto(dto, dto_1.GetTokenDetailsDto, {
            addressKeys: ['tokenAddress'],
        });
        await this.require({
            wallet: !tokenAddress,
        });
        return this.services.assetsService.getTokenDetails(this.prepareAccountAddress(tokenAddress), chainId || this.services.networkService.chainId, provider);
    }
    async getHistoricalTokenPrice(dto = {}) {
        const { tokenAddress, chainId, provider, timePeriod } = await dto_1.validateDto(dto, dto_1.GetHistoricalTokenPriceDto, {
            addressKeys: ['tokenAddress'],
        });
        await this.require({
            wallet: !tokenAddress,
        });
        return this.services.assetsService.getHistoricalTokenPrice(this.prepareAccountAddress(tokenAddress), chainId || this.services.networkService.chainId, provider, timePeriod);
    }
    async getPoolsActivity(dto = {}) {
        const { tokenAddress, chainId, provider, page, type } = await dto_1.validateDto(dto, dto_1.GetPoolsActivityDto, {
            addressKeys: ['tokenAddress'],
        });
        await this.require({
            wallet: !tokenAddress,
        });
        return this.services.assetsService.getPoolsActivity(this.prepareAccountAddress(tokenAddress), chainId || this.services.networkService.chainId, provider, page, type);
    }
    async getNumberOfTransactions(dto = {}) {
        const { tokenAddress, chainId, provider } = await dto_1.validateDto(dto, dto_1.GetTokenDetailsDto, {
            addressKeys: ['tokenAddress'],
        });
        await this.require({
            wallet: !tokenAddress,
        });
        return this.services.assetsService.getNumberOfTransactions(this.prepareAccountAddress(tokenAddress), chainId || this.services.networkService.chainId, provider);
    }
    async getTradingHistory(dto = {}) {
        const { tokenAddress, chainId, provider, page } = await dto_1.validateDto(dto, dto_1.GetPoolsActivityDto, {
            addressKeys: ['tokenAddress'],
        });
        await this.require({
            wallet: !tokenAddress,
        });
        return this.services.assetsService.getTradingHistory(this.prepareAccountAddress(tokenAddress), chainId || this.services.networkService.chainId, provider, page);
    }
    async getMarketDetails(dto = {}) {
        const { tokenAddress, chainId, provider } = await dto_1.validateDto(dto, dto_1.GetTokenDetailsDto, {
            addressKeys: ['tokenAddress'],
        });
        await this.require({
            wallet: !tokenAddress,
        });
        return this.services.assetsService.getMarketDetails(this.prepareAccountAddress(tokenAddress), chainId || this.services.networkService.chainId, provider);
    }
    async getTransaction(dto) {
        const { hash } = await dto_1.validateDto(dto, dto_1.GetTransactionDto);
        await this.require({
            wallet: false,
        });
        return this.services.transactionsService.getTransaction(hash);
    }
    async getTransactions(dto) {
        const { account } = await dto_1.validateDto(dto, dto_1.GetTransactionsDto, {
            addressKeys: ['account'],
        });
        await this.require({
            wallet: !account,
            contractAccount: true,
        });
        return this.services.transactionsService.getTransactions(this.prepareAccountAddress(account));
    }
    async getNftList(dto) {
        const { account } = await dto_1.validateDto(dto, dto_1.GetNftListDto, {
            addressKeys: ['account'],
        });
        await this.require({
            wallet: !account,
        });
        return this.services.transactionsService.getNftList(this.prepareAccountAddress(account));
    }
    async createStreamTransactionPayload(dto) {
        const { tokenAddress, receiver, amount, account, userData, skipBalanceCheck } = await dto_1.validateDto(dto, dto_1.CreateStreamTransactionPayloadDto, {
            addressKeys: ['tokenAddress', 'receiver', 'account'],
        });
        await this.require({
            session: true,
            wallet: !account,
            contractAccount: true,
        });
        return this.services.transactionsService.createStreamTransactionPayload(this.prepareAccountAddress(account), receiver, ethers_1.BigNumber.from(amount), tokenAddress, userData ? userData : '0x', skipBalanceCheck);
    }
    async deleteStreamTransactionPayload(dto) {
        const { tokenAddress, receiver, account, userData } = await dto_1.validateDto(dto, dto_1.DeleteStreamTransactionPayloadDto, {
            addressKeys: ['tokenAddress', 'receiver', 'account'],
        });
        await this.require({
            session: true,
            wallet: !account,
            contractAccount: true,
        });
        return this.services.transactionsService.deleteStreamTransactionPayload(this.prepareAccountAddress(account), receiver, tokenAddress, userData);
    }
    async modifyStreamTransactionPayload(dto) {
        const { tokenAddress, receiver, amount, account, userData } = await dto_1.validateDto(dto, dto_1.CreateStreamTransactionPayloadDto, {
            addressKeys: ['tokenAddress', 'receiver', 'account'],
        });
        await this.require({
            session: true,
            wallet: !account,
            contractAccount: true,
        });
        return this.services.transactionsService.modifyStreamTransactionPayload(this.prepareAccountAddress(account), receiver, ethers_1.BigNumber.from(amount), tokenAddress, userData);
    }
    async getStreamList(dto = {}) {
        const { account } = await dto_1.validateDto(dto, dto_1.GetStreamListDto, {
            addressKeys: ['account'],
        });
        await this.require({
            session: true,
            wallet: !account,
            contractAccount: true,
        });
        return this.services.transactionsService.getStreamList(this.prepareAccountAddress(account));
    }
    async createSuperERC20WrapperTransactionPayload(underlyingToken, underlyingDecimals, name, symbol) {
        return this.services.transactionsService.createSuperERC20WrapperTransactionPayload(underlyingToken, underlyingDecimals, name, symbol);
    }
    async findSuperERC20WrapperOnChain(underlyingToken, chainId, underlyingDecimals, name, symbol) {
        return this.services.transactionsService.findSuperERC20WrapperOnChain(underlyingToken, chainId, underlyingDecimals, name, symbol);
    }
    async registerERC20WrapperToken(wrapperAddress, chainId) {
        return this.services.transactionsService.registerERC20WrapperToken(wrapperAddress, chainId);
    }
    async getRegisteredERC20WrapperTokens() {
        return this.services.transactionsService.getRegisteredERC20WrapperTokens();
    }
    async topUpAccount() {
        await this.require();
        return this.services.faucetService.topUpAccount();
    }
    async topUpPaymentDepositAccount() {
        await this.require();
        return this.services.faucetService.topUpPaymentDepositAccount();
    }
    async topUp(value) {
        if (!this.services.accountService.isContractAccount())
            await this.computeContractAccount({
                sync: false,
            });
        const wallet = this.services.walletService.walletProvider;
        if (!wallet)
            throw new common_1.Exception('The provider is missing');
        const nonce = await wallet.getTransactionCount();
        const account = this.state.accountAddress;
        const response = await wallet.sendTransaction({
            to: account,
            value: ethers_1.utils.parseEther(value),
            nonce,
        });
        await response.wait();
    }
    async topUpP2P(value) {
        if (!this.services.accountService.isContractAccount())
            await this.computeContractAccount({
                sync: false,
            });
        const wallet = this.services.walletService.walletProvider;
        if (!wallet)
            throw new common_1.Exception('The provider is missing');
        const nonce = await wallet.getTransactionCount();
        const account = this.state.p2pPaymentDepositAddress;
        const response = await wallet.sendTransaction({
            to: account,
            value: ethers_1.utils.parseEther(value),
            nonce,
        });
        await response.wait();
    }
    async topUpToken(value, contractAddress) {
        if (!this.services.accountService.isContractAccount())
            await this.computeContractAccount({
                sync: false,
            });
        const account = this.state.accountAddress;
        await this.transferTokens(account, value, contractAddress);
    }
    async topUpTokenP2P(value, contractAddress) {
        if (!this.services.accountService.isContractAccount())
            await this.computeContractAccount({
                sync: false,
            });
        const account = this.state.p2pPaymentDepositAddress;
        await this.transferTokens(account, value, contractAddress);
    }
    async transferTokens(account, value, contractAddress) {
        const provider = this.services.walletService.walletProvider;
        const abi = contracts_1.getContractAbi(contracts_1.ContractNames.ERC20Token);
        if (!provider)
            throw new common_1.Exception(`The provider is missing`);
        const contract = new ethers_1.Contract(contractAddress, abi, provider);
        const tx = await contract.transfer(account, value);
        await tx.wait();
    }
    registerContract(name, abi, addresses = null) {
        return this.services.contractService.registerContract(name, abi, addresses);
    }
    async require(options = {}) {
        options = Object.assign({ network: true, wallet: true }, options);
        const { accountService, networkService, walletService, sessionService, projectService } = this.services;
        if (options.network && !networkService.chainId) {
            throw new common_1.Exception('Unknown network');
        }
        if (options.wallet && !walletService.walletAddress) {
            throw new common_1.Exception('Require wallet');
        }
        if (options.session) {
            await sessionService.verifySession();
        }
        if (options.contractAccount && (!accountService.account || accountService.account.type !== account_1.AccountTypes.Contract)) {
            throw new common_1.Exception('Require contract account');
        }
        if (options.currentProject) {
            if (!projectService.currentProject) {
                throw new common_1.Exception('Require project');
            }
            const isProjectValid = await projectService.isProjectValid();
            if (!isProjectValid) {
                throw new common_1.Exception('Invalid project key');
            }
        }
    }
    prepareAccountAddress(account = null) {
        const { accountService: { accountAddress }, } = this.services;
        return account || accountAddress;
    }
    getNetworkChainId(networkName = null) {
        let result;
        if (!networkName) {
            ({ chainId: result } = this.services.networkService);
        }
        else {
            const network = this.supportedNetworks.find(({ name }) => name === networkName);
            if (!network) {
                throw new common_1.Exception('Unsupported network');
            }
            ({ chainId: result } = network);
        }
        return result;
    }
    async fetchExchangeRates(dto) {
        const { tokens, chainId } = dto;
        let data;
        const promises = [];
        const batches = [...Array(Math.ceil(tokens.length / 50))].map(() => tokens.splice(0, 50));
        batches.forEach((batch) => {
            promises.push(this.services.ratesService.fetchExchangeRates(batch, chainId));
        });
        await Promise
            .allSettled(promises)
            .then((response) => response === null || response === void 0 ? void 0 : response.forEach((result) => {
            var _a;
            if ((result === null || result === void 0 ? void 0 : result.status) === 'fulfilled') {
                !data
                    ? (data = result.value ? result.value : {})
                    : (data.items = ((_a = result === null || result === void 0 ? void 0 : result.value) === null || _a === void 0 ? void 0 : _a.items) ? [...data.items, ...result.value.items] : [...data.items]);
            }
        }));
        if (data && data.items && data.items.length) {
            data.error = '';
            data.errored = false;
            data.items = [...new Map(data.items.map(item => [item['address'], item])).values()];
        }
        else {
            data.items = [];
        }
        return data;
    }
    async validateResolveName(options = {}) {
        options = Object.assign({}, options);
        const { networkService } = this.services;
        if (options.network && !networkService.chainId) {
            throw new common_1.Exception('Unknown network');
        }
        if (!options.name) {
            throw new common_1.Exception('Require name');
        }
    }
    async resolveName(dto = {
        name: '',
    }) {
        const { chainId, name } = await dto_1.validateDto(dto, dto_1.NameResolutionNodeDto);
        await this.validateResolveName({ network: chainId, name: name });
        const { nameResolutionService } = this.services;
        return nameResolutionService.resolveName(chainId, name);
    }
}
exports.Sdk = Sdk;
