"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionsService = void 0;
const core_1 = require("@apollo/client/core");
const common_1 = require("../common");
const classes_1 = require("./classes");
class TransactionsService extends common_1.Service {
    async getTransaction(hash) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int, $hash: String!) {
          result: transaction(chainId: $chainId, hash: $hash) {
            blockHash
            blockNumber
            from
            gasLimit
            gasPrice
            gasUsed
            hash
            input
            logs
            nonce
            status
            timestamp
            to
            transactionIndex
            value
            blockExplorerUrl
            mainTransactionDataFetched
            internalTransactionsFetched
          }
        }
      `, {
            variables: {
                hash,
            },
            models: {
                result: classes_1.Transaction,
            },
        });
        return result;
    }
    async getTransactions(account) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int, $account: String!) {
          result: transactions(chainId: $chainId, account: $account) {
            items {
              blockNumber
              timestamp
              from
              gasLimit
              gasPrice
              gasUsed
              hash
              logs
              status
              to
              value
              direction
              internalTransactions
              internalTransactionsFetched
              mainTransactionDataFetched
              batch
              asset {
                from
                to
                name
                symbol
                category
                type
                value
                decimal
                contract
              }
              blockExplorerUrl
            }
          }
        }
      `, {
            variables: {
                account,
            },
            models: {
                result: classes_1.Transactions,
            },
        });
        return result;
    }
    async getNftList(account) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int, $account: String!) {
          result: nftList(chainId: $chainId, account: $account) {
            items {
              contractName
              contractSymbol
              contractAddress
              tokenType
              nftVersion
              nftDescription
              balance
              items {
                tokenId
                name
                amount
                image
                ipfsGateway
              }
            }
          }
        }
      `, {
            variables: {
                account,
            },
            models: {
                result: classes_1.NftList,
            },
        });
        return result;
    }
    async createStreamTransactionPayload(account, receiver, amount, tokenAddress, userData, skipBalanceCheck) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query(
          $account: String!
          $receiver: String!
          $amount: BigNumber!
          $tokenAddress: String!
          $chainId: Int!
          $userData: String
          $skipBalanceCheck: Boolean
        ) {
          result: streamTransactionPayload(
            account: $account
            receiver: $receiver
            amount: $amount
            tokenAddress: $tokenAddress
            chainId: $chainId
            userData: $userData
            skipBalanceCheck: $skipBalanceCheck
          ) {
            data
            to
            error
          }
        }
      `, {
            variables: {
                account,
                receiver,
                amount,
                tokenAddress,
                userData,
                skipBalanceCheck,
            },
            models: {
                result: classes_1.StreamTransactionPayload,
            },
        });
        return result;
    }
    async modifyStreamTransactionPayload(account, receiver, amount, tokenAddress, userData, skipBalanceCheck) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query(
          $account: String!
          $receiver: String!
          $amount: BigNumber!
          $tokenAddress: String!
          $chainId: Int!
          $userData: String
          $skipBalanceCheck: Boolean
        ) {
          result: modifyTransactionPayload(
            account: $account
            receiver: $receiver
            amount: $amount
            tokenAddress: $tokenAddress
            chainId: $chainId
            userData: $userData
            skipBalanceCheck: $skipBalanceCheck
          ) {
            data
            to
            error
          }
        }
      `, {
            variables: {
                account,
                receiver,
                amount,
                tokenAddress,
                userData,
                skipBalanceCheck,
            },
            models: {
                result: classes_1.StreamTransactionPayload,
            },
        });
        return result;
    }
    async deleteStreamTransactionPayload(account, receiver, tokenAddress, userData) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($account: String!, $receiver: String!, $tokenAddress: String!, $chainId: Int!, $userData: String) {
          result: deleteTransactionPayload(
            account: $account
            receiver: $receiver
            tokenAddress: $tokenAddress
            chainId: $chainId
            userData: $userData
          ) {
            data
            to
            error
          }
        }
      `, {
            variables: {
                account,
                receiver,
                tokenAddress,
                userData,
            },
            models: {
                result: classes_1.StreamTransactionPayload,
            },
        });
        return result;
    }
    async getStreamList(account) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($account: String!, $chainId: Int!) {
          result: streamList(account: $account, chainId: $chainId) {
            items {
              id
              createdAtTimestamp
              createdAtBlockNumber
              updatedAtTimestamp
              updatedAtBlockNumber
              currentFlowRate
              streamedUntilUpdatedAt
              token {
                id
                createdAtTimestamp
                createdAtBlockNumber
                name
                symbol
                isListed
                underlyingAddress
              }
              sender
              receiver
              flowUpdatedEvents {
                id
                blockNumber
                timestamp
                transactionHash
                token
                sender
                receiver
                flowRate
                totalSenderFlowRate
                totalReceiverFlowRate
                userData
                oldFlowRate
                type
                totalAmountStreamedUntilTimestamp
              }
            }
            error
          }
        }
      `, {
            variables: {
                account,
            },
            models: {
                result: classes_1.StreamList,
            },
        });
        return result;
    }
    async createSuperERC20WrapperTransactionPayload(underlyingToken, underlyingDecimals, name, symbol) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int!, $underlyingToken: String!, $underlyingDecimals: Int, $name: String, $symbol: String) {
          result: createSuperERC20WrapperTransactionPayload(
            chainId: $chainId
            underlyingToken: $underlyingToken
            underlyingDecimals: $underlyingDecimals
            name: $name
            symbol: $symbol
          ) {
            error
            data
            to
          }
        }
      `, {
            variables: {
                chainId: this.services.networkService.chainId,
                underlyingToken,
                underlyingDecimals,
                name,
                symbol,
            },
            models: {
                result: classes_1.StreamTransactionPayload,
            },
        });
        return result;
    }
    async findSuperERC20WrapperOnChain(underlyingToken, chainId, underlyingDecimals, name, symbol) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int!, $underlyingToken: String!, $underlyingDecimals: Int, $name: String, $symbol: String) {
          result: findSuperERC20WrapperOnChain(
            chainId: $chainId
            underlyingToken: $underlyingToken
            underlyingDecimals: $underlyingDecimals
            name: $name
            symbol: $symbol
          )
        }
      `, {
            variables: {
                chainId: chainId || this.services.networkService.chainId,
                underlyingToken,
                underlyingDecimals,
                name,
                symbol,
            },
        });
        return result;
    }
    async registerERC20WrapperToken(wrapperAddress, chainId) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int!, $wrapperAddress: String!) {
          result: registerERC20WrapperToken(chainId: $chainId, wrapperAddress: $wrapperAddress) {
            id
            chainId
            contractName
            contractSymbol
            contractAddress
            tokenType
            nftVersion
            decimals
            underlyingToken
          }
        }
      `, {
            variables: {
                chainId: chainId || this.services.networkService.chainId,
                wrapperAddress,
            },
            models: {
                result: classes_1.KnownContract,
            },
        });
        return result;
    }
    async getRegisteredERC20WrapperTokens() {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query {
          result: getRegisteredERC20WrapperTokens {
            chains
            items {
              id
              chainId
              contractName
              contractSymbol
              contractAddress
              tokenType
              nftVersion
              decimals
              underlyingToken
            }
          }
        }
      `, {
            models: {
                result: classes_1.KnownContracts,
            },
        });
        return result;
    }
}
exports.TransactionsService = TransactionsService;
