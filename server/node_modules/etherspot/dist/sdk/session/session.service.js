"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionService = void 0;
const core_1 = require("@apollo/client/core");
const ethers_1 = require("ethers");
const operators_1 = require("rxjs/operators");
const common_1 = require("../common");
const classes_1 = require("./classes");
const utils_1 = require("./utils");
const session_storage_1 = require("./session.storage");
class SessionService extends common_1.Service {
    constructor(options = {}) {
        super();
        this.session = null;
        const { storage } = options;
        this.storage = storage ? storage : new session_storage_1.SessionStorage();
    }
    get headers() {
        return this.session
            ? {
                [common_1.HeaderNames.AuthToken]: this.session.token,
            }
            : {};
    }
    get sessionTtl() {
        return this.session ? this.session.ttl : undefined;
    }
    async verifySession() {
        await this.restoreSession();
        if (this.session && !this.session.verify()) {
            this.session = null;
        }
        if (!this.session) {
            await this.createSession();
        }
        else {
            await this.refreshSession();
        }
    }
    async refreshSession() {
        this.session.refresh();
        await this.storeSession();
    }
    async createSession(ttl, fcmToken) {
        const { apiService, walletService } = this.services;
        const { walletAddress } = walletService;
        let session;
        let error;
        let signerAddress;
        try {
            const { code } = await apiService.mutate(core_1.gql `
          mutation($chainId: Int, $account: String!) {
            code: createSessionCode(chainId: $chainId, account: $account)
          }
        `, {
                variables: {
                    account: walletAddress,
                },
            });
            const message = utils_1.createSessionMessage(code);
            const messageHash = ethers_1.utils.arrayify(ethers_1.utils.hashMessage(message));
            const signature = await walletService.signMessage(message);
            signerAddress = ethers_1.utils.recoverAddress(messageHash, signature);
            ({ session } = await apiService.mutate(core_1.gql `
          mutation(
            $chainId: Int
            $account: String!
            $code: String!
            $signature: String!
            $ttl: Int
            $fcmToken: String
          ) {
            session: createSession(
              chainId: $chainId
              account: $account
              code: $code
              signature: $signature
              ttl: $ttl
              fcmToken: $fcmToken
            ) {
              token
              ttl
              account {
                address
                type
                state
                store
                createdAt
                updatedAt
              }
            }
          }
        `, {
                variables: {
                    code,
                    signature,
                    ttl,
                    account: walletAddress,
                    fcmToken,
                },
                models: {
                    session: classes_1.Session,
                },
            }));
        }
        catch (err) {
            session = null;
            error = err;
        }
        if (session) {
            delete session.account;
            session.refresh();
            if (signerAddress !== walletAddress) {
                const { providerType } = walletService.wallet;
                walletService.wallet$.next({
                    address: signerAddress,
                    providerType,
                });
            }
        }
        if (error) {
            throw error;
        }
        this.session = session;
        await this.storeSession();
        return session;
    }
    onInit() {
        const { walletAddress$ } = this.services.walletService;
        this.addSubscriptions(walletAddress$
            .pipe(operators_1.switchMap(() => this.restoreSession()))
            .subscribe());
    }
    async storeSession() {
        const { walletService } = this.services;
        const { walletAddress } = walletService;
        await this.storage.setSession(walletAddress, this.session ? this.session.toStoredSession() : null);
    }
    async restoreSession() {
        let session = null;
        const { walletService } = this.services;
        const { walletAddress } = walletService;
        if (walletAddress) {
            const storedSession = await this.storage.getSession(walletAddress);
            session = storedSession ? classes_1.Session.fromStoredSession(storedSession) : null;
        }
        this.session = session;
    }
}
exports.SessionService = SessionService;
