"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExchangeService = void 0;
const core_1 = require("@apollo/client/core");
const common_1 = require("../common");
const classes_1 = require("./classes");
const assets_1 = require("../assets");
class ExchangeService extends common_1.Service {
    async getExchangeSupportedAssets(page = null, limit = null, ChainId) {
        const { apiService, accountService } = this.services;
        const account = accountService.accountAddress;
        const { result } = await apiService.query(core_1.gql `
        query($ChainId: Int, $account: String!, $page: Int, $limit: Int) {
          result: exchangeSupportedAssets(chainId: $ChainId, account: $account, page: $page, limit: $limit) {
            items {
              address
              name
              symbol
              decimals
              logoURI
            }
            currentPage
            nextPage
          }
        }
      `, {
            variables: {
                account,
                ChainId,
                page: page || 1,
                limit: limit || 100,
            },
            models: {
                result: assets_1.PaginatedTokens,
            },
        });
        return result;
    }
    async getCrossChainQuotes(fromTokenAddress, toTokenAddress, fromChainId, toChainId, fromAmount, serviceProvider, lifiBridges, toAddress, fromAddress, showZeroUsd) {
        const { apiService, accountService } = this.services;
        const account = accountService.accountAddress;
        const { result } = await apiService.query(core_1.gql `
        query(
          $account: String!
          $fromTokenAddress: String!
          $toTokenAddress: String!
          $fromAmount: BigNumber!
          $fromChainId: Int
          $toChainId: Int
          $serviceProvider: CrossChainServiceProvider
          $lifiBridges: [LiFiBridge!]
          $toAddress: String
          $fromAddress: String
          $showZeroUsd: Boolean
        ) {
          result: getCrossChainQuotes(
            account: $account
            fromTokenAddress: $fromTokenAddress
            toTokenAddress: $toTokenAddress
            fromAmount: $fromAmount
            fromChainId: $fromChainId
            toChainId: $toChainId
            serviceProvider: $serviceProvider
            lifiBridges: $lifiBridges
            toAddress: $toAddress
            fromAddress: $fromAddress
            showZeroUsd: $showZeroUsd
          ) {
            items {
              provider
              approvalData {
                approvalAddress
                amount
              }
              transaction {
                data
                to
                value
                from
                chainId
              }
              estimate {
                approvalAddress
                fromAmount
                toAmount
                gasCosts {
                  limit
                  amountUSD
                  token {
                    address
                    symbol
                    decimals
                    logoURI
                    chainId
                    name
                  }
                }
                data {
                  fromToken {
                    address
                    symbol
                    decimals
                    logoURI
                    chainId
                    name
                  }
                  toToken {
                    address
                    symbol
                    decimals
                    logoURI
                    chainId
                    name
                  }
                  toTokenAmount
                  estimatedGas
                }
              }
              LiFiBridgeUsed
            }
          }
        }
      `, {
            variables: {
                account,
                fromTokenAddress,
                toTokenAddress,
                fromChainId,
                toChainId,
                fromAmount,
                serviceProvider,
                lifiBridges,
                toAddress,
                fromAddress,
                showZeroUsd,
            },
            models: {
                result: classes_1.BridgingQuotes,
            },
        });
        return result ? result : null;
    }
    async getAdvanceRoutesLiFi(fromTokenAddress, toTokenAddress, fromChainId, toChainId, fromAmount, toAddress, allowSwitchChain, fromAddress, showZeroUsd) {
        const { apiService, accountService } = this.services;
        const account = accountService.accountAddress;
        let data = null;
        const { result } = await apiService.query(core_1.gql `
        query(
          $account: String!
          $fromTokenAddress: String!
          $toTokenAddress: String!
          $fromAmount: BigNumber!
          $fromChainId: Int
          $toChainId: Int
          $toAddress: String
          $allowSwitchChain: Boolean
          $fromAddress: String
          $showZeroUsd: Boolean
        ) {
          result: getAdvanceRoutesLiFi(
            account: $account
            fromTokenAddress: $fromTokenAddress
            toTokenAddress: $toTokenAddress
            fromAmount: $fromAmount
            fromChainId: $fromChainId
            toChainId: $toChainId
            toAddress: $toAddress
            allowSwitchChain: $allowSwitchChain
            fromAddress: $fromAddress
            showZeroUsd: $showZeroUsd
          ) {
            data
          }
        }
      `, {
            variables: {
                account,
                fromTokenAddress,
                toTokenAddress,
                fromChainId,
                toChainId,
                fromAmount,
                toAddress,
                allowSwitchChain,
                fromAddress,
                showZeroUsd,
            },
        });
        try {
            data = JSON.parse(result['data']);
        }
        catch (err) {
            console.log(err);
        }
        return data;
    }
    async getStepTransaction(selectedRoute) {
        const { apiService, accountService } = this.services;
        const account = accountService.accountAddress;
        let transactions = [];
        try {
            const route = JSON.stringify(selectedRoute);
            const { result } = await apiService.query(core_1.gql `
        query(
          $route: String!
          $account: String!
        ) {
          result: getStepTransactions(
            route: $route
            account: $account
          ) {
              to
              gasLimit
              gasPrice
              data
              value
              chainId
              type
          }
        }`, {
                variables: {
                    route,
                    account,
                },
            });
            transactions = result;
        }
        catch (err) {
            console.log(err);
        }
        return {
            items: transactions
        };
    }
    async getLiFiStatus(fromChainId, toChainId, txnHash, bridge) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query(
          $fromChainId: Int!
          $toChainId: Int!
          $txnHash: String!
          $bridge: String
        ) {
          result: getLiFiStatus(
            fromChainId: $fromChainId
            toChainId: $toChainId
            txnHash: $txnHash
            bridge: $bridge
          ) {
            status
            bridgeExplorerLink
            subStatus
            subStatusMsg
            sendingTxnHash
            receivingTxnHash
          }
        }`, {
            variables: {
                fromChainId,
                toChainId,
                txnHash,
                bridge
            },
        });
        return result;
    }
    async getExchangeOffers(fromTokenAddress, toTokenAddress, fromAmount, fromChainId, toAddress, fromAddress, showZeroUsd) {
        const { apiService, accountService } = this.services;
        const account = accountService.accountAddress;
        if (!toAddress)
            toAddress = accountService.accountAddress;
        const { result } = await apiService.query(core_1.gql `
        query(
          $fromChainId: Int!
          $account: String!
          $fromTokenAddress: String!
          $toTokenAddress: String!
          $fromAmount: BigNumber!
          $toAddress: String
          $fromAddress: String
          $showZeroUsd: Boolean
        ) {
          result: exchangeOffers(
            chainId: $fromChainId
            account: $account
            fromTokenAddress: $fromTokenAddress
            toTokenAddress: $toTokenAddress
            fromAmount: $fromAmount
            toAddress: $toAddress
            fromAddress: $fromAddress
            showZeroUsd: $showZeroUsd
          ) {
            items {
              provider
              receiveAmount
              exchangeRate
              transactions {
                to
                data
                value
              }
            }
          }
        }
      `, {
            variables: {
                fromChainId,
                account,
                fromTokenAddress,
                toTokenAddress,
                fromAmount,
                toAddress,
                fromAddress,
                showZeroUsd,
            },
            models: {
                result: classes_1.ExchangeOffers,
            },
        });
        return result ? result.items : null;
    }
    async getCrossChainBridgeSupportedChains(dto) {
        const { apiService } = this.services;
        const serviceProvider = dto === null || dto === void 0 ? void 0 : dto.serviceProvider;
        const { result } = await apiService.query(core_1.gql `
        query($serviceProvider: CrossChainServiceProvider) {
          result: crossChainBridgeSupportedChains(
            serviceProvider: $serviceProvider
          ) {
            items {
              chainId
              name
              isL1
              sendingEnabled
              icon
              receivingEnabled
              currency {
                address
                icon
                name
                symbol
                decimals
                minNativeCurrencyForGas
              }
              rpcs
              explorers
            }
          }
        }
      `, {
            variables: {
                serviceProvider,
            },
            models: {
                result: classes_1.CrossChainBridgeSupportedChains,
            },
        });
        return result ? result.items : null;
    }
    async getCrossChainBridgeTokenList(dto) {
        const { apiService } = this.services;
        const { direction, fromChainId, toChainId, disableSwapping, serviceProvider } = dto;
        const { result } = await apiService.query(core_1.gql `
        query(
          $direction: SocketTokenDirection!,
          $fromChainId: Int!,
          $toChainId: Int!,
          $disableSwapping: Boolean,
          $serviceProvider: CrossChainServiceProvider
        ) {
          result: crossChainBridgeTokenList(
            direction: $direction
            fromChainId: $fromChainId
            toChainId: $toChainId
            disableSwapping: $disableSwapping,
            serviceProvider: $serviceProvider
          ) {
            items {
              name
              address
              chainId
              decimals
              symbol
              icon
            }
          }
        }
      `, {
            variables: {
                direction,
                fromChainId,
                toChainId,
                disableSwapping,
                serviceProvider,
            },
            models: {
                result: classes_1.CrossChainBridgeTokenList,
            },
        });
        return result ? result.items : null;
    }
    async findCrossChainBridgeRoutes(dto) {
        const { apiService } = this.services;
        const { fromTokenAddress, fromChainId, toTokenAddress, toChainId, fromAmount, userAddress, disableSwapping } = dto;
        const { result } = await apiService.query(core_1.gql `
        query(
          $fromTokenAddress: String!
          $fromChainId: Int!
          $toTokenAddress: String!
          $toChainId: Int!
          $fromAmount: String!
          $userAddress: String!
          $disableSwapping: Boolean
        ) {
          result: findCrossChainBridgeRoutes(
            fromTokenAddress: $fromTokenAddress
            fromChainId: $fromChainId
            toTokenAddress: $toTokenAddress
            toChainId: $toChainId
            fromAmount: $fromAmount
            userAddress: $userAddress
            disableSwapping: $disableSwapping
          ) {
            items {
              chainGasBalances
              fromAmount
              routeId
              sender
              serviceTime
              toAmount
              totalGasFeesInUsd
              totalUserTx
              usedBridgeNames
              userTxs {
                approvalData {
                  allowanceTarget
                  approvalTokenAddress
                  minimumApprovalAmount
                  owner
                }
                chainId
                gasFees {
                  asset {
                    address
                    chainId
                    decimals
                    icon
                    name
                    symbol
                  }
                  feesInUsd
                  gasLimit
                }
                routePath
                sender
                serviceTime
                stepCount
                steps {
                  chainId
                  fromChainId
                  fromAmount
                  fromAsset {
                    address
                    chainAgnosticId
                    chainId
                    createdAt
                    decimals
                    icon
                    id
                    isEnabled
                    name
                    rank
                    symbol
                    updatedAt
                  }
                  gasFees {
                    asset {
                      address
                      chainId
                      decimals
                      icon
                      name
                      symbol
                    }
                    feesInUsd
                    gasLimit
                  }
                  protocol {
                    displayName
                    icon
                    name
                  }
                  toAmount
                  toAsset {
                    address
                    chainAgnosticId
                    chainId
                    createdAt
                    decimals
                    icon
                    id
                    isEnabled
                    name
                    rank
                    symbol
                    updatedAt
                  }
                  toChainId
                  type
                }
                toAmount
                toAsset {
                  address
                  chainAgnosticId
                  chainId
                  createdAt
                  decimals
                  icon
                  id
                  isEnabled
                  name
                  rank
                  symbol
                  updatedAt
                }
                txType
                userTxIndex
                userTxType
              }
            }
          }
        }
      `, {
            variables: {
                fromTokenAddress,
                fromChainId,
                toTokenAddress,
                toChainId,
                fromAmount,
                userAddress,
                disableSwapping,
            },
            models: {
                result: classes_1.CrossChainBridgeRoutes,
            },
        });
        return result ? result.items : null;
    }
    async buildCrossChainBridgeTransaction(dto) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($payload: CrossChainBridgeRouteBuildTransactionRouteArgs!) {
          result: callCrossChainBridgeTransaction(payload: $payload) {
            userTxType
            txType
            txData
            txTarget
            chainId
            value
            approvalData {
              minimumApprovalAmount
              approvalTokenAddress
              allowanceTarget
              owner
            }
          }
        }
      `, {
            models: {
                result: classes_1.CrossChainBridgeBuildTXResponse,
            },
            variables: {
                payload: { payload: dto },
            },
        });
        return result;
    }
    async getExchangeRoutersAddress(dto) {
        const { apiService } = this.services;
        const { chainId } = dto;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: number) {
          result: getExchangeRoutersAddress(chainId: $chainId)
        }
      `, {
            variables: {
                chainId,
            },
        });
        return result;
    }
    async getCrossChainBridgeTransaction(payload) {
        const { apiService } = this.services;
        const { result } = await apiService.mutate(core_1.gql `
        mutation($chainId: Int, $sender: String!, $payload: JSONObject) {
          result: getCrossChainBridgeTransaction(payload: $payload) {
            data
          }
        }
      `, {
            variables: {
                payload,
            },
        });
        return result.data;
    }
}
exports.ExchangeService = ExchangeService;
