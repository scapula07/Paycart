"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalContract = void 0;
const contracts_1 = require("@etherspot/contracts");
const ethers_1 = require("ethers");
const common_1 = require("../../common");
const contract_1 = require("../contract");
class InternalContract extends contract_1.Contract {
    constructor(name) {
        super(name, contracts_1.getContractAbi(name));
    }
    get address() {
        return this.services.networkService.getInternalContractAddress(this.name);
    }
    hashMessagePayload(structName, structFields, message) {
        const { chainId } = this.context.services.networkService;
        const prefix = `${structName}(${structFields.map(({ type, name }) => `${type} ${name}`).join(',')})`;
        const types = [
            'uint256',
            'address',
            'bytes32',
            ...structFields.map(({ type }) => type),
        ];
        const values = [
            chainId,
            this.address,
            ethers_1.utils.id(prefix),
            ...structFields.map(({ name, type }) => {
                let result;
                switch (type) {
                    case 'address':
                        result = common_1.prepareAddress(message[name], true);
                        break;
                    case 'uint256':
                        result = ethers_1.BigNumber.from(message[name] || 0).toHexString();
                        break;
                    case 'address[]':
                        result = message[name].map((address) => common_1.prepareAddress(address, true));
                        break;
                    default:
                        result = message[name];
                }
                return result;
            }),
        ];
        return Buffer.from(ethers_1.utils.arrayify(ethers_1.utils.solidityKeccak256(types, values)));
    }
    computeCreate2Address(contractName, salt, ...args) {
        let result = null;
        if (this.address) {
            let byteCode = contracts_1.getContractByteCode(contractName);
            for (const arg of args) {
                byteCode = common_1.concatHex(byteCode, ethers_1.utils.hexZeroPad(arg, 32));
            }
            result = ethers_1.utils.getCreate2Address(this.address, salt, ethers_1.utils.solidityKeccak256(['bytes'], [byteCode]));
        }
        return result;
    }
}
exports.InternalContract = InternalContract;
