"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Contract = void 0;
const ethers_1 = require("ethers");
const common_1 = require("../common");
const utils_1 = require("./utils");
class Contract extends common_1.Service {
    constructor(name, abi) {
        super();
        this.name = name;
        this.interface = new ethers_1.utils.Interface(abi);
        const { fragments } = this.interface;
        const methodsMap = fragments.reduce((result, fragment) => {
            const { name, type } = fragment;
            if (type === 'function') {
                if (!result[name]) {
                    result[name] = [fragment];
                }
                else {
                    result[name].push(fragment);
                }
            }
            return result;
        }, {});
        const methods = Object.values(methodsMap);
        for (const fragments of methods) {
            this.defineFunctions(fragments);
        }
    }
    parseLog(log) {
        let result;
        try {
            const { name: event, args } = this.interface.parseLog(log);
            result = {
                contract: this.name,
                event,
                args,
            };
        }
        catch (err) {
            result = null;
        }
        return result;
    }
    defineFunctions(fragments) {
        const { name, constant } = fragments[0];
        const methodPrefix = constant ? 'call' : 'encode';
        const methodPostfix = `${name[0].toUpperCase()}${name.slice(1)}`;
        for (const fragment of fragments) {
            const { inputs, outputs } = fragment;
            let method = `${methodPrefix}${methodPostfix}`;
            if (fragments.length !== 1) {
                method = `${method}(${inputs.map(({ type }) => type).join(',')})`;
            }
            if (!this[method]) {
                Object.defineProperty(this, method, {
                    value: (...args) => {
                        const to = this.address;
                        const data = this.interface.encodeFunctionData(name, args.map((arg, index) => utils_1.prepareInputArg(inputs[index].type, arg)));
                        let result;
                        if (constant) {
                            const { contractService } = this.services;
                            result = contractService.callContract(to, data).then((data) => {
                                const decoded = this.interface.decodeFunctionResult(fragment, data);
                                return outputs.length === 1 ? decoded[0] : decoded;
                            });
                        }
                        else {
                            result = {
                                to,
                                data,
                            };
                        }
                        return result;
                    },
                    writable: false,
                });
            }
        }
    }
}
exports.Contract = Contract;
