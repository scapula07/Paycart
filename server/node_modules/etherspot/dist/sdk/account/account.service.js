"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountService = void 0;
const core_1 = require("@apollo/client/core");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const common_1 = require("../common");
const classes_1 = require("./classes");
const constants_1 = require("./constants");
class AccountService extends common_1.Service {
    constructor() {
        super();
        this.account$ = new common_1.SynchronizedSubject();
        this.accountMember$ = new common_1.SynchronizedSubject();
        this.accountAddress$ = this.account$.observeKey('address');
    }
    get account() {
        return this.account$.value;
    }
    get accountAddress() {
        return this.account ? this.account.address : null;
    }
    get accountMember() {
        return this.accountMember$.value;
    }
    get headers() {
        return this.accountAddress
            ? {
                [common_1.HeaderNames.AnalyticsToken]: common_1.keccak256(this.accountAddress),
            }
            : {};
    }
    computeContractAccount() {
        const { walletService } = this.services;
        const { personalAccountRegistryContract } = this.internalContracts;
        const address = personalAccountRegistryContract.computeAccountAddress(walletService.walletAddress);
        if (address) {
            this.account$.next(classes_1.Account.fromPlain({
                address,
                type: constants_1.AccountTypes.Contract,
                synchronizedAt: null,
            }));
            this.accountMember$.next(classes_1.AccountMember.fromPlain({
                state: constants_1.AccountMemberStates.Added,
                type: constants_1.AccountMemberTypes.Owner,
                synchronizedAt: null,
            }));
        }
    }
    joinContractAccount(address) {
        this.account$.next(classes_1.Account.fromPlain({
            address,
            type: constants_1.AccountTypes.Contract,
            synchronizedAt: null,
        }));
    }
    async syncAccount() {
        const { apiService } = this.services;
        switch (this.account.type) {
            case constants_1.AccountTypes.Key: {
                const { account } = await apiService.mutate(core_1.gql `
            mutation($chainId: Int) {
              account: syncAccount(chainId: $chainId) {
                address
                type
                state
                store
                createdAt
                updatedAt
              }
            }
          `, {
                    models: {
                        account: classes_1.Account,
                    },
                });
                this.account$.next(account);
                break;
            }
            case constants_1.AccountTypes.Contract: {
                const _a = (await apiService.mutate(core_1.gql `
            mutation($chainId: Int, $account: String!) {
              accountMember: syncAccountMember(chainId: $chainId, account: $account) {
                account {
                  address
                  type
                  state
                  store
                  createdAt
                  updatedAt
                }
                type
                state
                store
                createdAt
                updatedAt
              }
            }
          `, {
                    variables: {
                        account: this.accountAddress,
                    },
                    models: {
                        accountMember: classes_1.AccountMember,
                    },
                })).accountMember, { account } = _a, accountMember = __rest(_a, ["account"]);
                this.account$.next(account);
                this.accountMember$.next(accountMember);
                break;
            }
        }
        return this.account;
    }
    async getConnectedAccounts(page) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int, $page: Int) {
          result: accounts(chainId: $chainId, page: $page) {
            items {
              address
              type
              state
              store
              createdAt
              updatedAt
            }
            currentPage
            nextPage
          }
        }
      `, {
            variables: {
                page: page || 1,
            },
            models: {
                result: classes_1.Accounts,
            },
        });
        return result;
    }
    async getAccount(account) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int, $account: String!) {
          result: account(chainId: $chainId, account: $account) {
            ensNode {
              hash
              name
              label
              address
              state
              zone
              createdAt
              updatedAt
            }
            address
            type
            state
            store
            createdAt
            updatedAt
          }
        }
      `, {
            variables: {
                account,
            },
            models: {
                result: classes_1.Account,
            },
        });
        return result;
    }
    async getAccountBalances(account, tokens, ChainId, provider) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($ChainId: Int!, $account: String!, $tokens: [String!], $provider: String) {
          result: accountBalances(chainId: $ChainId, account: $account, tokens: $tokens, provider: $provider) {
            items {
              token
              balance
              superBalance
            }
          }
        }
      `, {
            variables: {
                account,
                ChainId,
                tokens,
                provider
            },
            models: {
                result: classes_1.AccountBalances,
            },
        });
        return result;
    }
    async getAccountInvestments(account, ChainId, apps, provider) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($ChainId: Int!, $account: String!, $apps: [String!], $provider: String) {
          result: accountInvestments(chainId: $ChainId, account: $account, apps: $apps, provider: $provider) {
            items {
              name
              network
              position
              balance
              logoURI
              positionsInfo {
                balance
                tokens
                price
                metaType
                name
                logoURI
              }
            }
          }
        }
      `, {
            variables: {
                account,
                ChainId,
                apps,
                provider
            },
            models: {
                result: classes_1.AccountInvestments,
            },
        });
        return result;
    }
    async getAccount24HourNetCurve(account, chainIds) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainIds: [Int!], $account: String!) {
          result: netCurveBalances(chainIds: $chainIds, account: $account) {
            items {
              usdValue
              timestamp
            }
          }
        }
      `, {
            variables: {
                account,
                chainIds,
            },
            models: {
                result: classes_1.NetCurveBalances,
            },
        });
        return result;
    }
    async getAccountDashboard(account, currency, days) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int, $account: String!, $currency: String!, $days: Float) {
          result: accountDashboard(chainId: $chainId, account: $account, currency: $currency, days: $days) {
            history {
              balance
              timestamp
            }
            wallet {
              balance
              netChange
            }
          }
        }
      `, {
            variables: {
                account,
                currency,
                days,
            },
            models: {
                result: classes_1.AccountDashboard,
            },
        });
        return result;
    }
    async getAccountTotalBalances(account, currency) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($account: String!, $currency: Currencies!) {
          result: accountTotalBalances(account: $account, currency: $currency) {
            totalBalances {
              chainId
              category
              totalBalance
              balances {
                address
                tokenAddress
                serviceTitle
                protocol
                iconUrl
                key
                title
                value
                share
              }
            }
          }
        }
      `, {
            variables: {
                account,
                currency,
            },
            models: {
                result: classes_1.AccountTotalBalances,
            },
        });
        return result;
    }
    async getAccountMembers(account, page) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int, $account: String!, $page: Int) {
          result: accountMembers(chainId: $chainId, account: $account, page: $page) {
            items {
              member {
                address
                type
                state
                store
                createdAt
                updatedAt
              }
              type
              state
              store
              createdAt
              updatedAt
            }
            currentPage
            nextPage
          }
        }
      `, {
            variables: {
                account,
                page: page || 1,
            },
            models: {
                result: classes_1.AccountMembers,
            },
        });
        return result;
    }
    async getAccountSettings() {
        const { apiService, accountService } = this.services;
        const { accountAddress } = accountService;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int, $account: String!) {
          result: accountSettings(chainId: $chainId, account: $account) {
            fcmToken
            delayTransactions
          }
        }
      `, {
            models: {
                result: classes_1.AccountSettings,
            },
            variables: {
                account: accountAddress,
            },
        });
        return result;
    }
    async getDelayTransactionOptions() {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query {
          result: delayTransactionOptions
        }
      `);
        return result;
    }
    async updateAccountSettings(dto) {
        const { apiService, accountService } = this.services;
        const { accountAddress } = accountService;
        const { result } = await apiService.mutate(core_1.gql `
        mutation($chainId: Int, $account: String!, $fcmToken: String, $delayTransactions: Int) {
          result: updateAccountSettings(
            chainId: $chainId
            account: $account
            fcmToken: $fcmToken
            delayTransactions: $delayTransactions
          ) {
            fcmToken
            delayTransactions
          }
        }
      `, {
            models: {
                result: classes_1.AccountSettings,
            },
            variables: {
                account: accountAddress,
                fcmToken: dto.fcmToken,
                delayTransactions: dto.delayTransactions,
            },
        });
        return result;
    }
    async isEligibleForAirdrop(dto) {
        const { apiService } = this.services;
        const { address } = dto;
        const { result } = await apiService.query(core_1.gql `
        query($address: String!) {
          result: isEligibleForAirdrop(address: $address)
        }
      `, {
            variables: {
                address,
            },
        });
        return result;
    }
    isContractAccount() {
        return this.account.type === constants_1.AccountTypes.Contract;
    }
    onInit() {
        const { walletService, networkService } = this.services;
        this.addSubscriptions(rxjs_1.combineLatest([
            walletService.walletAddress$,
            networkService.chainId$,
        ])
            .pipe(operators_1.map(([address, chainId]) => !address || !chainId
            ? null
            : classes_1.Account.fromPlain({
                address,
                type: constants_1.AccountTypes.Key,
                synchronizedAt: null,
            })))
            .subscribe(this.account$), this.accountAddress$.pipe(operators_1.map(() => null)).subscribe(this.accountMember$));
    }
}
exports.AccountService = AccountService;
