"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletService = void 0;
const operators_1 = require("rxjs/operators");
const common_1 = require("../common");
const providers_1 = require("./providers");
class WalletService extends common_1.Service {
    constructor(providerLike, options) {
        super();
        this.providerLike = providerLike;
        this.options = options;
        this.wallet$ = new common_1.ObjectSubject();
        this.walletAddress$ = this.wallet$.observeKey('address');
    }
    get wallet() {
        return this.wallet$.value;
    }
    get etherWallet() {
        return this.wallet$.value;
    }
    get walletAddress() {
        return this.wallet ? this.wallet.address : null;
    }
    get walletProvider() {
        return this.provider ? this.provider : null;
    }
    async signMessage(message) {
        return this.provider ? this.provider.signMessage(message) : null;
    }
    switchWalletProvider(providerLike) {
        var _a;
        let provider = null;
        if (providerLike) {
            switch (typeof providerLike) {
                case 'object': {
                    const { privateKey } = providerLike;
                    const walletLike = providerLike;
                    const isNotJsonRpcProvider = ((_a = walletLike.provider) === null || _a === void 0 ? void 0 : _a.constructor.name) !== 'JsonRpcProvider';
                    if (privateKey && isNotJsonRpcProvider) {
                        provider = new providers_1.KeyWalletProvider(privateKey);
                    }
                    else {
                        provider = providerLike;
                    }
                    break;
                }
                case 'string':
                    provider = new providers_1.KeyWalletProvider(providerLike);
                    break;
            }
        }
        if (!provider) {
            this.wallet$.next(null);
            this.removeSubscriptions();
        }
        else {
            const { type: providerType } = provider;
            const { networkService } = this.services;
            const subscriptions = [];
            const { address, address$, networkName$ } = provider;
            if (typeof address$ !== 'undefined') {
                subscriptions.push(address$
                    .pipe(operators_1.map((address) => ({
                    address,
                    providerType,
                })))
                    .subscribe((wallet) => this.wallet$.next(wallet)));
            }
            else if (typeof address !== 'undefined') {
                this.wallet$.next({
                    address,
                    providerType,
                });
            }
            else {
                throw new Error('Invalid wallet address');
            }
            if (typeof networkName$ !== 'undefined') {
                const { omitProviderNetworkCheck } = this.options;
                if (omitProviderNetworkCheck) {
                    networkService.useDefaultNetwork();
                }
                else {
                    subscriptions.push(networkName$
                        .pipe(operators_1.tap((networkName) => {
                        networkService.switchNetwork(networkName);
                    }))
                        .subscribe());
                }
            }
            else {
                networkService.useDefaultNetwork();
            }
            this.replaceSubscriptions(...subscriptions);
        }
        this.provider = provider;
    }
    onInit() {
        if (this.providerLike) {
            this.switchWalletProvider(this.providerLike);
            this.providerLike = null;
        }
    }
}
exports.WalletService = WalletService;
