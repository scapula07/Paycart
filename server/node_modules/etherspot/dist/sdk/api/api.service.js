"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiService = void 0;
const core_1 = require("@apollo/client/core");
const context_1 = require("@apollo/client/link/context");
const ws_1 = require("@apollo/client/link/ws");
const utilities_1 = require("@apollo/client/utilities");
const apollo_cache_policies_1 = require("@nerdwallet/apollo-cache-policies");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const ethers_1 = require("ethers");
const common_1 = require("../common");
const constants_1 = require("./constants");
const exceptions_1 = require("./exceptions");
const utils_1 = require("./utils");
class ApiService extends common_1.Service {
    constructor(options) {
        super();
        this.cache = new apollo_cache_policies_1.InvalidationPolicyCache({
            resultCaching: true,
            addTypename: false,
            invalidationPolicies: {
                types: constants_1.сacheSettings,
            },
        });
        this.options = Object.assign({ port: null, useSsl: false }, options);
    }
    async query(query, options) {
        options = Object.assign({ variables: {}, fetchPolicy: 'no-cache' }, options);
        const { omitChainIdVariable, variables, fetchPolicy, models, } = options;
        return this.wrapCall(() => this.apolloClient.query({
            query,
            fetchPolicy,
            variables: this.prepareApiVariables(variables, omitChainIdVariable),
        }), models);
    }
    async mutate(mutation, options) {
        options = Object.assign({ variables: {} }, options);
        const { omitChainIdVariable, variables, models, } = options;
        return this.wrapCall(() => this.apolloClient.mutate({
            mutation,
            variables: this.prepareApiVariables(variables, omitChainIdVariable),
        }), models);
    }
    subscribe(query, options) {
        const { omitChainIdVariable, variables, models, } = options;
        return this.apolloClient
            .subscribe({
            query,
            variables: this.prepareApiVariables(variables, omitChainIdVariable),
        })
            .map(({ data }) => utils_1.mapApiResult(data, models));
    }
    onInit() {
        const httpLink = new core_1.HttpLink({
            fetch: cross_fetch_1.default,
            uri: utils_1.buildApiUri(this.options, 'http'),
        });
        const wsLink = new ws_1.WebSocketLink({
            webSocketImpl: WebSocket,
            uri: utils_1.buildApiUri(this.options, 'ws', 'graphql'),
            options: {
                reconnect: true,
                lazy: true,
            },
        });
        const authLink = context_1.setContext(async () => {
            const { accountService, sessionService, projectService, } = this.services;
            return {
                headers: Object.assign(Object.assign(Object.assign({}, accountService.headers), sessionService.headers), projectService.headers),
            };
        });
        const link = core_1.split(({ query }) => {
            const definition = utilities_1.getMainDefinition(query);
            return definition.kind === 'OperationDefinition' && definition.operation === 'subscription';
        }, wsLink, authLink.concat(httpLink));
        this.apolloClient = new core_1.ApolloClient({
            link,
            cache: this.cache,
        });
    }
    async wrapCall(call, models) {
        const wrapped = async () => {
            let result;
            try {
                this.cache.expire();
                const { data } = await call();
                result = utils_1.mapApiResult(data, models);
            }
            catch (err) {
                utils_1.catchApiError(err);
            }
            return result;
        };
        let result;
        try {
            result = await wrapped();
        }
        catch (err) {
            if (err instanceof exceptions_1.HttpException &&
                (err.code === exceptions_1.HttpExceptionCodes.Forbidden || err.code === exceptions_1.HttpExceptionCodes.Unauthorized)) {
                const { sessionService } = this.services;
                const { sessionTtl } = sessionService;
                await sessionService.createSession(sessionTtl);
                result = await wrapped();
            }
            else {
                throw err;
            }
        }
        return result;
    }
    prepareApiVariables(variables, omitChainIdVariable) {
        const result = {};
        const keys = Object.keys(variables || {});
        for (const key of keys) {
            let value;
            if (common_1.isBigNumber(variables[key])) {
                value = ethers_1.BigNumber.from(variables[key]).toHexString();
            }
            else if (variables[key] instanceof Date) {
                value = variables[key].getTime();
            }
            else {
                value = variables[key];
            }
            result[key] = value;
        }
        if (!omitChainIdVariable) {
            const { chainId } = this.services.networkService;
            result.chainId = chainId;
        }
        return result;
    }
}
exports.ApiService = ApiService;
