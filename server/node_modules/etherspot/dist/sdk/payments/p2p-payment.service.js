"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.P2PPaymentService = void 0;
const core_1 = require("@apollo/client/core");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const common_1 = require("../common");
const classes_1 = require("./classes");
const utils_1 = require("./utils");
class P2PPaymentService extends common_1.Service {
    constructor() {
        super(...arguments);
        this.p2pPaymentDepositAddress$ = new common_1.UniqueSubject();
    }
    get p2pPaymentDepositAddress() {
        return this.p2pPaymentDepositAddress$.value;
    }
    async syncP2PPaymentDeposit(owner, token) {
        let result = null;
        token = common_1.prepareAddress(token);
        const deposits = await this.syncP2PPaymentDeposits(owner, token ? [token] : []);
        if (deposits && deposits.items) {
            result = deposits.items.find((deposit) => deposit.token === token);
        }
        return result || null;
    }
    async syncP2PPaymentDeposits(owner, tokens) {
        const { apiService } = this.services;
        const { result } = await apiService.mutate(core_1.gql `
        mutation($chainId: Int, $owner: String!, $tokens: [String!]) {
          result: syncP2PPaymentDeposits(chainId: $chainId, owner: $owner, tokens: $tokens) {
            items {
              latestWithdrawal {
                createdAt
                guardianSignature
                state
                totalAmount
                updatedAt
                value
              }
              address
              availableAmount
              createdAt
              exitState
              lockedAmount
              owner
              pendingAmount
              token
              totalAmount
              updatedAt
              withdrawAmount
            }
          }
        }
      `, {
            models: {
                result: classes_1.P2PPaymentDeposits,
            },
            variables: {
                owner,
                tokens,
            },
        });
        return result;
    }
    async getP2PPaymentChannel(hash) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int, $hash: String!) {
          result: p2pPaymentChannel(chainId: $chainId, hash: $hash) {
            committedAmount
            createdAt
            hash
            recipient
            sender
            state
            token
            totalAmount
            uid
            updatedAt
            endangered
            latestPayment {
              blockNumber
              guardianSignature
              senderSignature
              state
              totalAmount
              updatedAt
              value
            }
          }
        }
      `, {
            models: {
                result: classes_1.P2PPaymentChannel,
            },
            variables: {
                hash,
            },
        });
        return result;
    }
    async getP2PPaymentChannels(senderOrRecipient, filters, page = null) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int, $senderOrRecipient: String!, $page: Int, $uncommittedOnly: Boolean) {
          result: p2pPaymentChannels(
            chainId: $chainId
            senderOrRecipient: $senderOrRecipient
            page: $page
            uncommittedOnly: $uncommittedOnly
          ) {
            items {
              committedAmount
              createdAt
              hash
              recipient
              sender
              state
              token
              totalAmount
              uid
              updatedAt
              endangered
              latestPayment {
                blockNumber
                guardianSignature
                senderSignature
                state
                totalAmount
                updatedAt
                value
              }
            }
            nextPage
            currentPage
          }
        }
      `, {
            models: {
                result: classes_1.P2PPaymentChannels,
            },
            variables: Object.assign({ senderOrRecipient, page: page || 1 }, filters),
        });
        return result;
    }
    async getP2PPaymentChannelsAdmin(dto) {
        const { sender, recipient, token, uncommittedOnly, page } = dto;
        const { apiService, projectService, walletService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query(
          $chainId: Int
          $adminAddress: String!
          $projectKey: String!
          $sender: String
          $recipient: String
          $token: String
          $uncommittedOnly: Boolean
          $limit: Int
          $page: Int
        ) {
          result: p2pPaymentChannelsAdmin(
            chainId: $chainId
            adminAddress: $adminAddress
            projectKey: $projectKey
            sender: $sender
            recipient: $recipient
            token: $token
            uncommittedOnly: $uncommittedOnly
            limit: $limit
            page: $page
          ) {
            items {
              hash
              latestPayment {
                blockNumber
                guardianSignature
                senderSignature
                state
                totalAmount
                updatedAt
                value
              }
              sender
              recipient
              token
              uid
              state
              endangered
              totalAmount
              committedAmount
              projectKey
              createdAt
              updatedAt
            }
            nextPage
            currentPage
          }
        }
      `, {
            models: {
                result: classes_1.P2PPaymentChannels,
            },
            variables: {
                adminAddress: walletService.walletAddress,
                projectKey: projectService.currentProject.key,
                sender,
                recipient,
                token,
                uncommittedOnly,
                limit: 100,
                page: page || 1,
            },
        });
        return result;
    }
    async getP2PPaymentChannelPayments(channel, page = null) {
        const { apiService } = this.services;
        const { result } = await apiService.query(core_1.gql `
        query($chainId: Int, $channel: String!, $page: Int) {
          result: p2pPaymentChannelPayments(chainId: $chainId, channel: $channel, page: $page) {
            items {
              blockNumber
              createdAt
              guardianSignature
              senderSignature
              state
              totalAmount
              updatedAt
              value
            }
            currentPage
            nextPage
          }
        }
      `, {
            models: {
                result: classes_1.P2PPaymentChannelPayments,
            },
            variables: {
                channel,
                page: page || 1,
            },
        });
        return result;
    }
    async decreaseP2PPaymentDeposit(token, amount) {
        const { accountService } = this.services;
        const owner = accountService.accountAddress;
        const deposit = await this.syncP2PPaymentDeposit(owner, token);
        if (!deposit || deposit.availableAmount.lt(amount)) {
            common_1.ValidationException.throw('amount', {
                tooHigh: 'Not enough funds',
            });
        }
        return this.updateP2PPaymentDeposit(token, deposit.withdrawAmount.add(amount));
    }
    async updateP2PPaymentDeposit(token, totalAmount) {
        const { apiService, accountService } = this.services;
        const owner = accountService.accountAddress;
        const { result } = await apiService.mutate(core_1.gql `
        mutation($chainId: Int, $owner: String!, $token: String, $totalAmount: BigNumber!) {
          result: updateP2PPaymentDeposit(chainId: $chainId, owner: $owner, token: $token, totalAmount: $totalAmount) {
            latestWithdrawal {
              createdAt
              guardianSignature
              state
              totalAmount
              updatedAt
              value
            }
            address
            availableAmount
            createdAt
            exitState
            lockedAmount
            owner
            pendingAmount
            token
            totalAmount
            updatedAt
            withdrawAmount
          }
        }
      `, {
            models: {
                result: classes_1.P2PPaymentDeposit,
            },
            variables: {
                owner,
                token,
                totalAmount,
            },
        });
        return result;
    }
    async increaseP2PPaymentChannelAmount(recipient, token, value, uidSalt = null) {
        const { accountService } = this.services;
        const hash = utils_1.computePaymentChannelHash(accountService.accountAddress, recipient, token, utils_1.createPaymentChannelUid(uidSalt));
        const paymentChannel = await this.getP2PPaymentChannel(hash);
        return this.updateP2PPaymentChannel(recipient, token, paymentChannel ? paymentChannel.totalAmount.add(value) : value, uidSalt);
    }
    async updateP2PPaymentChannel(recipient, token, totalAmount, uidSalt = null) {
        const { paymentRegistryContract } = this.internalContracts;
        const { apiService, accountService, blockService, projectService, walletService } = this.services;
        const uid = utils_1.createPaymentChannelUid(uidSalt);
        const sender = accountService.accountAddress;
        const projectKey = projectService.currentProject.key;
        const blockNumber = await blockService.getCurrentBlockNumber();
        const messageHash = paymentRegistryContract.hashPaymentChannelCommit(sender, recipient, token, uid, blockNumber, totalAmount);
        const senderSignature = await walletService.signMessage(messageHash);
        const { result } = await apiService.mutate(core_1.gql `
        mutation(
          $chainId: Int
          $blockNumber: Int!
          $recipient: String!
          $sender: String!
          $senderSignature: String!
          $token: String
          $totalAmount: BigNumber!
          $uid: String!
          $projectKey: String!
        ) {
          result: updateP2PPaymentChannel(
            chainId: $chainId
            blockNumber: $blockNumber
            recipient: $recipient
            sender: $sender
            senderSignature: $senderSignature
            token: $token
            totalAmount: $totalAmount
            uid: $uid
            projectKey: $projectKey
          ) {
            hash
            sender
            recipient
            token
            uid
            state
            totalAmount
            committedAmount
            createdAt
            updatedAt
            latestPayment {
              blockNumber
              guardianSignature
              senderSignature
              state
              totalAmount
              updatedAt
              value
            }
            projectKey
          }
        }
      `, {
            models: {
                result: classes_1.P2PPaymentChannel,
            },
            variables: {
                blockNumber,
                recipient,
                sender,
                senderSignature,
                token,
                totalAmount,
                uid,
                projectKey,
            },
        });
        return result;
    }
    async signP2PPaymentChannel(hash) {
        const { apiService, accountService, walletService } = this.services;
        const paymentChannel = await this.getP2PPaymentChannel(hash);
        if (!paymentChannel ||
            !paymentChannel.latestPayment ||
            paymentChannel.sender !== accountService.accountAddress ||
            paymentChannel.latestPayment.senderSignature) {
            throw new Error('Can not sign payment channel');
        }
        const { sender, recipient, token, totalAmount, uid, latestPayment: { blockNumber }, } = paymentChannel;
        const { paymentRegistryContract } = this.internalContracts;
        const messageHash = paymentRegistryContract.hashPaymentChannelCommit(sender, recipient, token, uid, blockNumber, totalAmount);
        const senderSignature = await walletService.signMessage(messageHash);
        const { result } = await apiService.mutate(core_1.gql `
        mutation($chainId: Int, $hash: String!, $senderSignature: String!) {
          result: signP2PPaymentChannel(chainId: $chainId, hash: $hash, senderSignature: $senderSignature) {
            committedAmount
            createdAt
            hash
            recipient
            sender
            state
            token
            totalAmount
            uid
            updatedAt
            latestPayment {
              blockNumber
              guardianSignature
              senderSignature
              state
              totalAmount
              updatedAt
              value
            }
          }
        }
      `, {
            models: {
                result: classes_1.P2PPaymentChannel,
            },
            variables: {
                hash,
                senderSignature,
            },
        });
        return result;
    }
    buildP2PPaymentDepositWithdrawalTransactionRequest(deposit) {
        if (!deposit || !deposit.latestWithdrawal) {
            throw new common_1.Exception('Payment deposit withdrawal not found');
        }
        const { paymentRegistryContract } = this.internalContracts;
        const { token, latestWithdrawal: { totalAmount, guardianSignature }, } = deposit;
        return paymentRegistryContract.encodeWithdrawDeposit(token, totalAmount, guardianSignature);
    }
    onInit() {
        const { paymentRegistryContract } = this.internalContracts;
        const { accountService, networkService } = this.services;
        this.addSubscriptions(rxjs_1.combineLatest([
            accountService.accountAddress$,
            networkService.chainId$,
        ])
            .pipe(operators_1.map(([address]) => {
            let result = null;
            if (address) {
                result = paymentRegistryContract.computePaymentDepositAccountAddress(address);
            }
            return result;
        }))
            .subscribe(this.p2pPaymentDepositAddress$));
    }
}
exports.P2PPaymentService = P2PPaymentService;
