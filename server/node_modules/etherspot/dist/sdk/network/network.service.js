"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkService = void 0;
const contracts_1 = require("@etherspot/contracts");
const common_1 = require("../common");
const constants_1 = require("./constants");
class NetworkService extends common_1.Service {
    constructor(options, defaultNetworkName) {
        super();
        this.options = options;
        this.network$ = new common_1.ObjectSubject(null);
        this.externalContractAddresses = new Map();
        const { supportedNetworkNames } = options;
        this.supportedNetworks = supportedNetworkNames
            .map((name) => {
            const chainId = constants_1.NETWORK_NAME_TO_CHAIN_ID[name];
            return !chainId
                ? null
                : {
                    chainId,
                    name,
                };
        })
            .filter((value) => !!value);
        if (!this.supportedNetworks.length) {
            throw new common_1.Exception('Invalid network config');
        }
        this.defaultNetwork = defaultNetworkName
            ? this.supportedNetworks.find(({ name }) => name === defaultNetworkName)
            : this.supportedNetworks[0];
        if (!this.defaultNetwork) {
            throw new common_1.Exception('Unsupported network');
        }
        this.chainId$ = this.network$.observeKey('chainId');
    }
    get network() {
        return this.network$.value;
    }
    get chainId() {
        return this.network ? this.network.chainId : null;
    }
    useDefaultNetwork() {
        this.network$.next(this.defaultNetwork);
    }
    switchNetwork(networkName) {
        this.network$.next(this.supportedNetworks.find(({ name }) => name === networkName) || null);
    }
    isNetworkNameSupported(networkName) {
        return !!this.supportedNetworks.find(({ name }) => name === networkName);
    }
    setExternalContractAddresses(contractName, addresses) {
        const chainAddresses = this.externalContractAddresses.get(contractName) || {};
        switch (typeof addresses) {
            case 'object': {
                const entries = Object.entries(addresses);
                for (const [networkName, address] of entries) {
                    const network = this.supportedNetworks.find(({ name }) => name === networkName);
                    if (network) {
                        chainAddresses[network.chainId] = common_1.prepareAddress(address);
                    }
                    else {
                        throw new common_1.Exception('Unsupported network');
                    }
                }
                break;
            }
            case 'string':
                if (!this.network) {
                    throw new common_1.Exception('Unsupported network');
                }
                chainAddresses[this.chainId] = addresses;
                break;
        }
        this.externalContractAddresses.set(contractName, chainAddresses);
    }
    getExternalContractAddress(contractName) {
        let result = null;
        if (this.network && this.externalContractAddresses.has(contractName)) {
            const { chainId } = this.network;
            result = this.externalContractAddresses.get(contractName)[chainId] || null;
        }
        return result;
    }
    getInternalContractAddress(contractName) {
        let result = null;
        if (this.network) {
            const { chainId, name } = this.network;
            const { internalContracts } = this.options;
            if (internalContracts && internalContracts[name] && internalContracts[name][contractName]) {
                result = internalContracts[name][contractName];
            }
            else {
                result = contracts_1.getContractAddress(contractName, chainId);
            }
        }
        return result;
    }
}
exports.NetworkService = NetworkService;
