import { ethers } from "ethers";
import Operation from "./Operation";
import { IBaseSuperTokenParams, ITransferFromParams } from "./interfaces";
export default class Token {
    readonly address: string;
    constructor(address: string);
    private get tokenContract();
    /**
     * @dev Returns the allowance the `owner` has granted the `spender`.
     * @param owner the owner who has allotted the allowance
     * @param spender the spender who has received the allowance
     * @param providerOrSigner a provider or signer for executing a web3 call
     * @returns {Promise<string>} the allowance amount
     */
    allowance: ({ owner, spender, providerOrSigner, }: {
        owner: string;
        spender: string;
        providerOrSigner: ethers.providers.Provider | ethers.Signer;
    }) => Promise<string>;
    /**
     * @dev Returns the ERC20 balanceOf the `account`, this can't be negative and will just display 0.
     * @param account the account you would like to query
     * @param providerOrSigner a provider or signer for executing a web3 call
     * @returns {Promise<string>} the token balance of `account`
     */
    balanceOf: ({ account, providerOrSigner, }: {
        account: string;
        providerOrSigner: ethers.providers.Provider | ethers.Signer;
    }) => Promise<string>;
    /**
     * @dev Returns the token name
     * @param providerOrSigner a provider or signer for executing a web3 call
     * @returns {string} the token name
     */
    name: ({ providerOrSigner, }: {
        providerOrSigner: ethers.providers.Provider | ethers.Signer;
    }) => Promise<string>;
    /**
     * @dev Returns the token symbol
     * @param providerOrSigner a provider or signer for executing a web3 call
     * @returns {string} the token symbol
     */
    symbol: ({ providerOrSigner, }: {
        providerOrSigner: ethers.providers.Provider | ethers.Signer;
    }) => Promise<string>;
    /**
     * @dev Returns the total supply of the token.
     * @param providerOrSigner a provider or signer for executing a web3 call
     * @returns {Promise<string>} the total supply of the token
     */
    totalSupply: ({ providerOrSigner, }: {
        providerOrSigner: ethers.providers.Provider | ethers.Signer;
    }) => Promise<string>;
    /**
     * @dev Approve `receiver` to spend `amount` tokens.
     * @param receiver The receiver approved.
     * @param amount The amount approved.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    approve: ({ receiver, amount, overrides, }: IBaseSuperTokenParams) => Operation;
    /**
     * @dev Transfer `receiver` `amount` tokens.
     * @param receiver The receiver of the transfer.
     * @param amount The amount to be transferred.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    transfer: ({ receiver, amount, overrides, }: IBaseSuperTokenParams) => Operation;
    /**
     * @dev Transfer from `sender` to `receiver` `amount` tokens.
     * @param sender The sender of the transfer.
     * @param receiver The receiver of the transfer.
     * @param amount The amount to be transferred.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    transferFrom: ({ sender, receiver, amount, overrides, }: ITransferFromParams) => Operation;
}
//# sourceMappingURL=Token.d.ts.map