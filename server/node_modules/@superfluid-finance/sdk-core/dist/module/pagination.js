/**
 * Factory function to create a {@link PagedResult}.
 * @param dataPlusOne Subgraph queries are executed with one extra result to get which is over the {@link Paging} `take` amount.
 * @param paging
 */
export const createPagedResult = (dataPlusOne, paging) => {
    var _a;
    const hasNextPage = dataPlusOne.length > paging.take;
    const data = dataPlusOne.slice(0, paging.take);
    const lastId = (_a = data.slice(-1)[0]) === null || _a === void 0 ? void 0 : _a.id;
    return {
        paging: { skip: paging.skip, take: paging.take },
        nextPaging: hasNextPage
            ? isSkipPaging(paging)
                ? nextSkipPaging(paging)
                : nextLastIdPaging(paging, lastId)
            : undefined,
        data: data,
    };
};
function isSkipPaging(paging) {
    return paging.skip !== undefined;
}
export const createSkipPaging = ({ skip = 0, take = 100, } = {}) => ({
    skip: skip,
    take: take,
});
export const createLastIdPaging = ({ lastId = "", take = 100, } = {}) => ({
    take: take,
    lastId: lastId,
});
/**
 * @dev Gets the next page given the skip/take used to initialize the `PagedResult` interface.
 * @returns the `Paging` class with the next page
 */
export const nextSkipPaging = (paging) => ({
    skip: paging.skip + paging.take,
    take: paging.take,
});
export const nextLastIdPaging = (paging, nextLastId) => ({
    take: paging.take,
    lastId: nextLastId,
});
/**
 * @dev Used to determine whether there is another page for pagination.
 * @returns the user's specified `take` plus one
 */
export const takePlusOne = (paging) => {
    return paging.take + 1;
};
//# sourceMappingURL=pagination.js.map