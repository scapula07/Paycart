"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const Operation_1 = __importDefault(require("./Operation"));
const SFError_1 = require("./SFError");
const ERC20WithTokenInfo_json_1 = __importDefault(require("./abi/ERC20WithTokenInfo.json"));
const utils_1 = require("./utils");
class Token {
    constructor(address) {
        // ERC20 Token Contract Read Functions
        /**
         * @dev Returns the allowance the `owner` has granted the `spender`.
         * @param owner the owner who has allotted the allowance
         * @param spender the spender who has received the allowance
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @returns {Promise<string>} the allowance amount
         */
        this.allowance = async ({ owner, spender, providerOrSigner, }) => {
            const normalizedOwner = (0, utils_1.normalizeAddress)(owner);
            const normalizedSpender = (0, utils_1.normalizeAddress)(spender);
            try {
                const allowance = await this.tokenContract
                    .connect(providerOrSigner)
                    .allowance(normalizedOwner, normalizedSpender);
                return allowance.toString();
            }
            catch (err) {
                throw new SFError_1.SFError({
                    type: "SUPERTOKEN_READ",
                    customMessage: "There was an error getting allowance",
                    errorObject: err,
                });
            }
        };
        /**
         * @dev Returns the ERC20 balanceOf the `account`, this can't be negative and will just display 0.
         * @param account the account you would like to query
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @returns {Promise<string>} the token balance of `account`
         */
        this.balanceOf = async ({ account, providerOrSigner, }) => {
            try {
                const normalizedAccount = (0, utils_1.normalizeAddress)(account);
                const balanceOf = await this.tokenContract
                    .connect(providerOrSigner)
                    .balanceOf(normalizedAccount);
                return balanceOf.toString();
            }
            catch (err) {
                throw new SFError_1.SFError({
                    type: "SUPERTOKEN_READ",
                    customMessage: "There was an error getting balanceOf",
                    errorObject: err,
                });
            }
        };
        /**
         * @dev Returns the token name
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @returns {string} the token name
         */
        this.name = async ({ providerOrSigner, }) => {
            try {
                const name = await this.tokenContract
                    .connect(providerOrSigner)
                    .name();
                return name;
            }
            catch (err) {
                throw new SFError_1.SFError({
                    type: "SUPERTOKEN_READ",
                    customMessage: "There was an error getting name",
                    errorObject: err,
                });
            }
        };
        /**
         * @dev Returns the token symbol
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @returns {string} the token symbol
         */
        this.symbol = async ({ providerOrSigner, }) => {
            try {
                const symbol = await this.tokenContract
                    .connect(providerOrSigner)
                    .symbol();
                return symbol;
            }
            catch (err) {
                throw new SFError_1.SFError({
                    type: "SUPERTOKEN_READ",
                    customMessage: "There was an error getting symbol",
                    errorObject: err,
                });
            }
        };
        /**
         * @dev Returns the total supply of the token.
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @returns {Promise<string>} the total supply of the token
         */
        this.totalSupply = async ({ providerOrSigner, }) => {
            try {
                const totalSupply = await this.tokenContract
                    .connect(providerOrSigner)
                    .totalSupply();
                return totalSupply.toString();
            }
            catch (err) {
                throw new SFError_1.SFError({
                    type: "SUPERTOKEN_READ",
                    customMessage: "There was an error getting totalSupply",
                    errorObject: err,
                });
            }
        };
        // ERC20 Token Contract Write Functions
        /**
         * @dev Approve `receiver` to spend `amount` tokens.
         * @param receiver The receiver approved.
         * @param amount The amount approved.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.approve = ({ receiver, amount, overrides, }) => {
            const normalizedReceiver = (0, utils_1.normalizeAddress)(receiver);
            const txn = this.tokenContract.populateTransaction.approve(normalizedReceiver, amount, overrides || {});
            return new Operation_1.default(txn, "ERC20_APPROVE");
        };
        /**
         * @dev Transfer `receiver` `amount` tokens.
         * @param receiver The receiver of the transfer.
         * @param amount The amount to be transferred.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.transfer = ({ receiver, amount, overrides, }) => {
            const normalizedReceiver = (0, utils_1.normalizeAddress)(receiver);
            const txn = this.tokenContract.populateTransaction.transfer(normalizedReceiver, amount, overrides || {});
            return new Operation_1.default(txn, "UNSUPPORTED");
        };
        /**
         * @dev Transfer from `sender` to `receiver` `amount` tokens.
         * @param sender The sender of the transfer.
         * @param receiver The receiver of the transfer.
         * @param amount The amount to be transferred.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.transferFrom = ({ sender, receiver, amount, overrides, }) => {
            const normalizedSender = (0, utils_1.normalizeAddress)(sender);
            const normalizedReceiver = (0, utils_1.normalizeAddress)(receiver);
            const txn = this.tokenContract.populateTransaction.transferFrom(normalizedSender, normalizedReceiver, amount, overrides || {});
            return new Operation_1.default(txn, "ERC20_TRANSFER_FROM");
        };
        this.address = address;
    }
    get tokenContract() {
        return new ethers_1.ethers.Contract(this.address, ERC20WithTokenInfo_json_1.default.abi);
    }
}
exports.default = Token;
//# sourceMappingURL=Token.js.map