"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const BatchCall_1 = __importDefault(require("./BatchCall"));
const ConstantFlowAgreementV1_1 = __importDefault(require("./ConstantFlowAgreementV1"));
const Host_1 = __importDefault(require("./Host"));
const InstantDistributionAgreementV1_1 = __importDefault(require("./InstantDistributionAgreementV1"));
const Query_1 = __importDefault(require("./Query"));
const SFError_1 = require("./SFError");
const SuperToken_1 = __importDefault(require("./SuperToken"));
const IResolver_json_1 = __importDefault(require("./abi/IResolver.json"));
const SuperfluidLoader_json_1 = __importDefault(require("./abi/SuperfluidLoader.json"));
const constants_1 = require("./constants");
const frameworkHelpers_1 = require("./frameworkHelpers");
const utils_1 = require("./utils");
/**
 * @dev Superfluid Framework Class
 * @description The entrypoint for the SDK-core, `create` an instance of this for full functionality.
 */
class Framework {
    constructor(options, settings) {
        /**
         * @dev Create a signer which can be used to sign transactions.
         * @param options.web3Provider a Web3Provider object (e.g. client side - metamask, web3modal)
         * @param options.provider an ethers Provider object (e.g. via Hardhat ethers)
         * @param options.privateKey a test account private key
         * @param options.signer a signer object (e.g. ethers.Wallet instance)
         * @returns `ethers.Signer` object
         */
        this.createSigner = (options) => {
            if (!options.privateKey &&
                !options.provider &&
                !options.signer &&
                !options.web3Provider) {
                throw new SFError_1.SFError({
                    type: "CREATE_SIGNER",
                    customMessage: "You must pass in a private key, provider or signer.",
                });
            }
            /* istanbul ignore else  */
            if (options.privateKey) {
                if (!options.provider) {
                    throw new SFError_1.SFError({
                        type: "CREATE_SIGNER",
                        customMessage: "You must pass in a provider with your private key.",
                    });
                }
                return new ethers_1.ethers.Wallet(options.privateKey, options.provider);
            }
            else if (options.signer) {
                return options.signer;
            }
            // NOTE: tested by sdk-redux already
            else if (options.web3Provider) {
                return options.web3Provider.getSigner();
            }
            /* istanbul ignore next */
            throw new SFError_1.SFError({
                type: "CREATE_SIGNER",
                customMessage: "Something went wrong, this should never occur.",
            });
        };
        /**
         * @dev Create a `BatchCall` class from the `Framework`.
         * @param operations the list of operations to execute
         * @returns `BatchCall` class
         */
        this.batchCall = (operations) => {
            return new BatchCall_1.default({
                operations,
                hostAddress: this.settings.config.hostAddress,
            });
        };
        /**
         * @dev Load a `SuperToken` class from the `Framework`.
         * @param tokenAddressOrSymbol the `SuperToken` address or symbol (if symbol, it must be on the resolver)
         * @returns `SuperToken` class
         */
        this.loadSuperToken = async (tokenAddressOrSymbol) => {
            let address;
            const isValidAddress = ethers_1.ethers.utils.isAddress(tokenAddressOrSymbol);
            if (isValidAddress) {
                address = tokenAddressOrSymbol;
            }
            else {
                try {
                    const superTokenKey = "supertokens." +
                        this.settings.protocolReleaseVersion +
                        "." +
                        tokenAddressOrSymbol;
                    const resolver = new ethers_1.ethers.Contract(this.settings.config.resolverAddress, IResolver_json_1.default.abi, this.settings.provider);
                    const tokenAddress = await resolver.get(superTokenKey);
                    address = tokenAddress;
                }
                catch (err) {
                    throw new SFError_1.SFError({
                        type: "SUPERTOKEN_INITIALIZATION",
                        customMessage: "There was an error with loading the SuperToken with symbol: " +
                            tokenAddressOrSymbol +
                            " with the resolver.",
                        errorObject: err,
                    });
                }
            }
            return await SuperToken_1.default.create({
                ...this.settings,
                address,
            });
        };
        this.userInputOptions = options;
        this.settings = settings;
        this.cfaV1 = new ConstantFlowAgreementV1_1.default({
            config: this.settings.config,
        });
        this.host = new Host_1.default(this.settings.config.hostAddress);
        this.idaV1 = new InstantDistributionAgreementV1_1.default({
            config: this.settings.config,
        });
        this.query = new Query_1.default(this.settings);
    }
}
exports.default = Framework;
_a = Framework;
/**
 * @dev Creates the Framework object based on user provided `options`.
 * @param options.chainId the chainId of your desired network (e.g. 137 = matic)
 * @param options.customSubgraphQueriesEndpoint your custom subgraph endpoint
 * @param options.dataMode the data mode you'd like the framework to use (SUBGRAPH_ONLY, SUBGRAPH_WEB3, WEB3_ONLY)
 * @param options.networkName the desired network (e.g. "matic", "rinkeby", etc.)
 * @param options.resolverAddress a custom resolver address (advanced use for testing)
 * @param options.protocolReleaseVersion a custom release version (advanced use for testing)
 * @param options.provider a provider object (injected web3, injected ethers, ethers provider) necessary for initializing the framework
 * @returns `Framework` class
 */
Framework.create = async (options) => {
    (0, frameworkHelpers_1.validateFrameworkConstructorOptions)({
        ...options,
        dataMode: options.dataMode || "SUBGRAPH_ONLY",
        protocolReleaseVersion: options.protocolReleaseVersion || "v1",
    });
    const networkName = (0, frameworkHelpers_1.getNetworkName)(options);
    const chainId = options.chainId || constants_1.networkNameToChainIdMap.get(networkName);
    const releaseVersion = options.protocolReleaseVersion || "v1";
    // NOTE: endpoint can be empty in WEB3_ONLY mode
    const customSubgraphQueriesEndpoint = options.dataMode === "WEB3_ONLY"
        ? ""
        : options.customSubgraphQueriesEndpoint ||
            (0, frameworkHelpers_1.getSubgraphQueriesEndpoint)(options);
    const provider = (0, utils_1.isEthersProvider)(options.provider)
        ? options.provider
        : (0, utils_1.isInjectedWeb3)(options.provider)
            ? // must explicitly cast web3 provider type because
                // ethers.providers.Web3Provider doesn't like
                // the type passed.
                new ethers_1.ethers.providers.Web3Provider(options.provider.currentProvider)
            : options.provider.provider;
    const network = await provider.getNetwork();
    if (network.chainId !== chainId && chainId != null) {
        throw new SFError_1.SFError({
            type: "NETWORK_MISMATCH",
            customMessage: "Your provider network chainId is: " +
                network.chainId +
                " whereas your desired chainId is: " +
                chainId,
        });
    }
    try {
        const resolverData = constants_1.chainIdToResolverDataMap.get(chainId) || {
            subgraphAPIEndpoint: "",
            resolverAddress: "",
            networkName: "",
        };
        const resolverAddress = options.resolverAddress
            ? options.resolverAddress
            : resolverData.resolverAddress;
        const resolver = new ethers_1.ethers.Contract(resolverAddress, IResolver_json_1.default.abi, provider);
        const superfluidLoaderAddress = await resolver.get("SuperfluidLoader-v1");
        const superfluidLoader = new ethers_1.ethers.Contract(superfluidLoaderAddress, SuperfluidLoader_json_1.default.abi, provider);
        const framework = await superfluidLoader.loadFramework(releaseVersion);
        const settings = {
            chainId,
            customSubgraphQueriesEndpoint,
            dataMode: options.dataMode || "SUBGRAPH_ONLY",
            protocolReleaseVersion: options.protocolReleaseVersion || "v1",
            provider,
            networkName,
            config: {
                resolverAddress,
                hostAddress: framework.superfluid,
                cfaV1Address: framework.agreementCFAv1,
                idaV1Address: framework.agreementIDAv1,
            },
        };
        return new Framework(options, settings);
    }
    catch (err) {
        throw new SFError_1.SFError({
            type: "FRAMEWORK_INITIALIZATION",
            customMessage: "There was an error initializing the framework",
            errorObject: err,
        });
    }
};
//# sourceMappingURL=Framework.js.map