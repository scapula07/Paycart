"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNetworkName = exports.getSubgraphQueriesEndpoint = exports.validateFrameworkConstructorOptions = void 0;
const SFError_1 = require("./SFError");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const validateFrameworkConstructorOptions = (options) => {
    if (!options.chainId && !options.networkName) {
        throw new SFError_1.SFError({
            type: "FRAMEWORK_INITIALIZATION",
            customMessage: "You must input chainId or networkName.",
        });
    }
    // if the user inputs a custom network (local, they have to specify this)
    if (options.networkName &&
        constants_1.networkNames.includes(options.networkName) &&
        options.chainId &&
        constants_1.chainIds.includes(options.chainId) &&
        constants_1.networkNameToChainIdMap.get(options.networkName) !== options.chainId) {
        throw new SFError_1.SFError({
            type: "FRAMEWORK_INITIALIZATION",
            customMessage: "The network name and chainId you have selected don't match.",
        });
    }
    if (!options.provider) {
        throw new SFError_1.SFError({
            type: "FRAMEWORK_INITIALIZATION",
            customMessage: "You must pass in a provider, an injected web3.js or ethers.js instance when initializing the framework.",
        });
    }
    // if the user inputs a networkName or chainId that isn't part of the resolver
    // that is, an unsupported network/chain
    if ((options.networkName != null &&
        !constants_1.networkNames.includes(options.networkName)) ||
        (options.chainId != null && !constants_1.chainIds.includes(options.chainId))) {
        if (options.dataMode !== "WEB3_ONLY" &&
            (0, utils_1.isNullOrEmpty)(options.customSubgraphQueriesEndpoint)) {
            throw new SFError_1.SFError({
                type: "FRAMEWORK_INITIALIZATION",
                customMessage: "You must input your own custom subgraph query endpoint if you use an unsupported network with dataMode set to SUBGRAPH_ONLY or SUBGRAPH_WEB3.",
            });
        }
        if ((0, utils_1.isNullOrEmpty)(options.resolverAddress)) {
            throw new SFError_1.SFError({
                type: "FRAMEWORK_INITIALIZATION",
                customMessage: "You must input your own resolver address if you use an unsupported network.",
            });
        }
    }
};
exports.validateFrameworkConstructorOptions = validateFrameworkConstructorOptions;
/**
 * @dev options.networkName is casted as not null as we check to ensure chainId or networkName is not null.
 * @param options
 * @returns SubgraphQueriesEndpoint which is a custom endpoint or based on selected network
 */
const getSubgraphQueriesEndpoint = (options) => {
    const chainId = options.networkName
        ? constants_1.networkNameToChainIdMap.get(options.networkName)
        : options.chainId;
    const resolverData = chainId ? constants_1.chainIdToResolverDataMap.get(chainId) : null;
    if (resolverData) {
        return resolverData.subgraphAPIEndpoint;
    }
    /* istanbul ignore next */
    throw new SFError_1.SFError({
        type: "FRAMEWORK_INITIALIZATION",
        customMessage: "Something went wrong, this should never occur.",
    });
};
exports.getSubgraphQueriesEndpoint = getSubgraphQueriesEndpoint;
/**
 * @dev We check that the user has input a networkName or chainId and that they are both supported.
 * @param options.chainId the chainId of the desired network
 * @param options.networkName the name of the desired network
 * @returns the network name
 */
const getNetworkName = (options) => {
    var _a;
    return (options.networkName ||
        (options.chainId
            ? (_a = constants_1.chainIdToResolverDataMap.get(options.chainId)) === null || _a === void 0 ? void 0 : _a.networkName
            : undefined) ||
        "custom");
};
exports.getNetworkName = getNetworkName;
//# sourceMappingURL=frameworkHelpers.js.map