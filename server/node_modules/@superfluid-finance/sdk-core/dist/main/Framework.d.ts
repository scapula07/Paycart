import { Signer } from "@ethersproject/abstract-signer";
import { HardhatEthersHelpers } from "@nomiclabs/hardhat-ethers/types";
import { ethers } from "ethers";
import Web3 from "web3";
import BatchCall from "./BatchCall";
import ConstantFlowAgreementV1 from "./ConstantFlowAgreementV1";
import Host from "./Host";
import InstantDistributionAgreementV1 from "./InstantDistributionAgreementV1";
import Operation from "./Operation";
import Query from "./Query";
import SuperToken from "./SuperToken";
import { IConfig, ISignerConstructorOptions } from "./interfaces";
import { DataMode } from "./types";
declare type SupportedProvider = ethers.providers.Provider | (typeof ethers & HardhatEthersHelpers) | Web3;
export interface IFrameworkOptions {
    chainId?: number;
    customSubgraphQueriesEndpoint?: string;
    dataMode?: DataMode;
    networkName?: string;
    resolverAddress?: string;
    protocolReleaseVersion?: string;
    provider: SupportedProvider;
}
export interface IFrameworkSettings {
    chainId: number;
    customSubgraphQueriesEndpoint: string;
    dataMode: DataMode;
    networkName: string;
    protocolReleaseVersion: string;
    provider: ethers.providers.Provider;
    config: IConfig;
}
/**
 * @dev Superfluid Framework Class
 * @description The entrypoint for the SDK-core, `create` an instance of this for full functionality.
 */
export default class Framework {
    readonly userInputOptions: IFrameworkOptions;
    settings: IFrameworkSettings;
    cfaV1: ConstantFlowAgreementV1;
    host: Host;
    idaV1: InstantDistributionAgreementV1;
    query: Query;
    private constructor();
    /**
     * @dev Creates the Framework object based on user provided `options`.
     * @param options.chainId the chainId of your desired network (e.g. 137 = matic)
     * @param options.customSubgraphQueriesEndpoint your custom subgraph endpoint
     * @param options.dataMode the data mode you'd like the framework to use (SUBGRAPH_ONLY, SUBGRAPH_WEB3, WEB3_ONLY)
     * @param options.networkName the desired network (e.g. "matic", "rinkeby", etc.)
     * @param options.resolverAddress a custom resolver address (advanced use for testing)
     * @param options.protocolReleaseVersion a custom release version (advanced use for testing)
     * @param options.provider a provider object (injected web3, injected ethers, ethers provider) necessary for initializing the framework
     * @returns `Framework` class
     */
    static create: (options: IFrameworkOptions) => Promise<Framework>;
    /**
     * @dev Create a signer which can be used to sign transactions.
     * @param options.web3Provider a Web3Provider object (e.g. client side - metamask, web3modal)
     * @param options.provider an ethers Provider object (e.g. via Hardhat ethers)
     * @param options.privateKey a test account private key
     * @param options.signer a signer object (e.g. ethers.Wallet instance)
     * @returns `ethers.Signer` object
     */
    createSigner: (options: ISignerConstructorOptions) => Signer;
    /**
     * @dev Create a `BatchCall` class from the `Framework`.
     * @param operations the list of operations to execute
     * @returns `BatchCall` class
     */
    batchCall: (operations: Operation[]) => BatchCall;
    /**
     * @dev Load a `SuperToken` class from the `Framework`.
     * @param tokenAddressOrSymbol the `SuperToken` address or symbol (if symbol, it must be on the resolver)
     * @returns `SuperToken` class
     */
    loadSuperToken: (tokenAddressOrSymbol: string) => Promise<SuperToken>;
}
export {};
//# sourceMappingURL=Framework.d.ts.map