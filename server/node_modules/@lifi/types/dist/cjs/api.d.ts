import { TransactionRequest } from '@ethersproject/providers';
import { BridgeDefinition, Chain, ChainId, ExchangeDefinition, Step, Token } from '.';
import { ToolError } from './apiErrors';
export declare const Orders: readonly ["RECOMMENDED", "FASTEST", "CHEAPEST", "SAFEST"];
export type Order = typeof Orders[number];
export interface RoutesRequest {
    fromChainId: number;
    fromAmount: string;
    fromTokenAddress: string;
    fromAddress?: string;
    toChainId: number;
    toTokenAddress: string;
    toAddress?: string;
    options?: RouteOptions;
}
export interface RouteOptions {
    order?: Order;
    slippage?: number;
    infiniteApproval?: boolean;
    allowSwitchChain?: boolean;
    integrator?: string;
    allowDestinationCall?: boolean;
    referrer?: string;
    bridges?: AllowDenyPrefer;
    exchanges?: AllowDenyPrefer;
    fee?: number;
    insurance?: boolean;
}
export type ToolsResponse = {
    exchanges: {
        key: string;
        name: string;
        logoURI: string;
        supportedChains: ChainId[];
    }[];
    bridges: {
        key: string;
        name: string;
        logoURI: string;
        supportedChains: {
            fromChainId: ChainId;
            toChainId: ChainId;
        }[];
    }[];
};
export interface AllowDenyPrefer {
    allow?: string[];
    deny?: string[];
    prefer?: string[];
}
export interface Route {
    id: string;
    fromChainId: number;
    fromAmountUSD: string;
    fromAmount: string;
    fromToken: Token;
    fromAddress?: string;
    toChainId: number;
    toAmountUSD: string;
    toAmount: string;
    toAmountMin: string;
    toToken: Token;
    toAddress?: string;
    gasCostUSD?: string;
    containsSwitchChain?: boolean;
    infiniteApproval?: boolean;
    steps: Step[];
    tags?: Order[];
}
export interface RoutesResponse {
    routes: Route[];
    errors: ToolError[];
}
export type PossibilityTopic = 'chains' | 'tokens' | 'bridges' | 'exchanges';
export interface PossibilitiesRequest {
    chains?: number[];
    bridges?: AllowDenyPrefer;
    exchanges?: AllowDenyPrefer;
    include?: PossibilityTopic[];
}
export interface PossibilitiesResponse {
    chains?: Chain[];
    tokens?: Token[];
    bridges?: BridgeDefinition[];
    exchanges?: ExchangeDefinition[];
}
export interface GetTokenRequest {
    chain: number | string;
    token: string;
}
export interface ToolConfiguration {
    allowBridges?: string[];
    denyBridges?: string[];
    preferBridges?: string[];
    allowExchanges?: string[];
    denyExchanges?: string[];
    preferExchanges?: string[];
}
export interface QuoteRequest extends ToolConfiguration {
    fromChain: number | string;
    fromToken: string;
    fromAddress: string;
    fromAmount: string;
    toChain: number | string;
    toToken: string;
    toAddress?: string;
    order?: Order;
    slippage?: number | string;
    integrator?: string;
    referrer?: string;
    fee?: number | string;
    insurance?: boolean;
    allowDestinationCall?: boolean;
}
export interface ContractCallQuoteRequest extends ToolConfiguration {
    fromChain: number | string;
    fromToken: string;
    fromAddress: string;
    toChain: number | string;
    toToken: string;
    toAmount: string;
    toContractAddress: string;
    toContractCallData: string;
    toContractGasLimit: string;
    toApprovalAddress?: string;
    toFallbackAddress?: string;
    contractOutputsToken?: string;
    slippage?: number | string;
    integrator?: string;
    referrer?: string;
    fee?: number | string;
    allowDestinationCall?: boolean;
}
export interface ContractCallQuotesRequest extends ToolConfiguration {
    fromChain: number | string;
    fromToken: string;
    fromAddress: string;
    toChain: number | string;
    toFallbackAddress?: string;
    toContractCalls: {
        sendingAmount: string;
        sendingToken: string;
        receivingToken: string;
        contractAddress: string;
        approvalAddress?: string;
        callData: string;
        gasLimit: string;
    }[];
    order?: Order;
    slippage?: number | string;
    integrator?: string;
    referrer?: string;
}
export interface ConnectionsRequest extends ToolConfiguration {
    fromChain?: number | string;
    fromToken?: string;
    toChain?: number | string;
    toToken?: string;
}
export interface Connection {
    fromChainId: number;
    toChainId: number;
    fromTokens: Token[];
    toTokens: Token[];
}
export interface ConnectionsResponse {
    connections: Connection[];
}
export interface GetStatusRequest {
    txHash: string;
    bridge?: string;
    fromChain: number | string;
    toChain: number | string;
}
export interface TransactionInfo {
    txHash: string;
    txLink?: string;
    amount?: string;
    token?: Token;
    chainId?: ChainId;
    gasPrice?: string;
    gasUsed?: string;
    gasToken?: Token;
    gasAmount?: string;
    gasAmountUSD?: string;
}
declare const _StatusMessage: readonly ["NOT_FOUND", "INVALID", "PENDING", "DONE", "FAILED"];
export type StatusMessage = typeof _StatusMessage[number];
declare const _SubstatusPending: readonly ["WAIT_SOURCE_CONFIRMATIONS", "WAIT_DESTINATION_TRANSACTION", "BRIDGE_NOT_AVAILABLE", "CHAIN_NOT_AVAILABLE", "NOT_PROCESSABLE_REFUND_NEEDED", "REFUND_IN_PROGRESS", "UNKNOWN_ERROR"];
export type SubstatusPending = typeof _SubstatusPending[number];
declare const _SubstatusDone: readonly ["COMPLETED", "PARTIAL", "REFUNDED"];
export type SubstatusDone = typeof _SubstatusDone[number];
export type Substatus = SubstatusPending | SubstatusDone;
export declare const isSubstatusPending: (substatus: Substatus) => substatus is "WAIT_SOURCE_CONFIRMATIONS" | "WAIT_DESTINATION_TRANSACTION" | "BRIDGE_NOT_AVAILABLE" | "CHAIN_NOT_AVAILABLE" | "NOT_PROCESSABLE_REFUND_NEEDED" | "REFUND_IN_PROGRESS" | "UNKNOWN_ERROR";
export declare const isSubstatusDone: (substatus: Substatus) => substatus is "COMPLETED" | "PARTIAL" | "REFUNDED";
export interface StatusInformation {
    status: StatusMessage;
    substatus?: Substatus;
    substatusMessage?: string;
}
export interface StatusResponse extends StatusInformation {
    sending: TransactionInfo;
    receiving?: TransactionInfo;
    tool?: string;
    bridgeExplorerLink?: string;
}
export interface ExtendedChain extends Chain {
    nativeToken: Token;
}
export interface ChainsResponse {
    chains: ExtendedChain[];
}
export interface ToolsRequest {
    chains?: ChainId[];
}
export type TokensRequest = {
    chains?: ChainId[];
};
export type TokensResponse = {
    tokens: {
        [chainId: number]: Token[];
    };
};
export type RequestOptions = {
    signal?: AbortSignal;
};
export interface Integrator {
    integratorId: string;
    feeBalances: FeeBalance[];
}
export type FeeBalance = {
    chainId: ChainId;
    tokenBalances: TokenBalance[];
};
export type TokenBalance = {
    token: Token;
    amount: string;
    amountUsd: string;
};
export interface IntegratorWithdrawalRequest {
    integratorId: string;
    chainId: ChainId;
    tokens?: string[];
}
export interface IntegratorWithdrawalTransactionResponse {
    transactionRequest: TransactionRequest;
}
export {};
