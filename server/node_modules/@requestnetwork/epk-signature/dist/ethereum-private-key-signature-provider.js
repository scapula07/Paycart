"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const utils_1 = require("@requestnetwork/utils");
/**
 * Implementation of the signature provider from private key
 * Allows to sign() with "Ethereum_address" identities thanks to their private key given in constructor() or addSignatureParameters()
 */
class EthereumPrivateKeySignatureProvider {
    constructor(signatureParameter) {
        /** list of supported signing method */
        this.supportedMethods = [types_1.SignatureTypes.METHOD.ECDSA];
        /** list of supported identity types */
        this.supportedIdentityTypes = [types_1.IdentityTypes.TYPE.ETHEREUM_ADDRESS];
        // using Map allow to easily remove dynamically entries
        this.signatureParametersDictionary = new Map();
        if (signatureParameter) {
            this.addSignatureParameters(signatureParameter);
        }
    }
    /**
     * Signs data
     *
     * @param string data the data to sign
     * @returns IIdentity the identity to sign with if not given, the default signer will be used
     *
     * @returns string the signature
     */
    sign(data, signer) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const actualSigner = signer;
            if (!this.supportedIdentityTypes.includes(actualSigner.type)) {
                throw Error(`Identity type not supported ${actualSigner.type}`);
            }
            // toLowerCase to avoid mismatch because of case
            const signatureParameter = this.signatureParametersDictionary.get(actualSigner.value.toLowerCase());
            if (!signatureParameter) {
                throw Error(`private key unknown for the address ${actualSigner.value}`);
            }
            // the hash format in request start by 01 but the ec-utils need a hash starting by 0x
            const hashData = (0, utils_1.normalizeKeccak256Hash)(data).value;
            const signatureValue = (0, utils_1.ecSign)(signatureParameter.privateKey, hashData);
            return {
                data,
                signature: {
                    method: types_1.SignatureTypes.METHOD.ECDSA,
                    value: signatureValue,
                },
            };
        });
    }
    /**
     * Function to add a new private key in the provider
     *
     * @param ISignatureParameters signatureParams signature parameters to add
     *
     * @returns IIdentity identity from the signature parameter added
     */
    addSignatureParameters(signatureParams) {
        if (!this.supportedMethods.includes(signatureParams.method)) {
            throw Error(`Signing method not supported ${signatureParams.method}`);
        }
        // compute the address from private key
        // toLowerCase to avoid mismatch because of case
        const address = (0, utils_1.getAddressFromPrivateKey)(signatureParams.privateKey).toLowerCase();
        this.signatureParametersDictionary.set(address, signatureParams);
        return {
            type: types_1.IdentityTypes.TYPE.ETHEREUM_ADDRESS,
            value: address,
        };
    }
    /**
     * Function to remove a private key from the provider
     *
     * @param IIdentity identity identity to remove the private key
     *
     * @returns void
     */
    removeRegisteredIdentity(identity) {
        // Check the type of the identity to be sure that the value used to delete will be the right type
        if (!this.supportedIdentityTypes.includes(identity.type)) {
            throw Error(`Identity type not supported ${identity.type}`);
        }
        this.signatureParametersDictionary.delete(identity.value);
    }
    /**
     * Function to remove a private key from the provider
     *
     * @param IIdentity identity identity to remove the private key
     *
     * @returns void
     */
    clearAllRegisteredIdentities() {
        this.signatureParametersDictionary.clear();
    }
    /**
     * Function to get all the identities available to sign with
     *
     * @returns IIdentity all the identities registered
     */
    getAllRegisteredIdentities() {
        return Array.from(this.signatureParametersDictionary.keys(), (address) => ({
            type: types_1.IdentityTypes.TYPE.ETHEREUM_ADDRESS,
            value: address,
        }));
    }
}
exports.default = EthereumPrivateKeySignatureProvider;
//# sourceMappingURL=ethereum-private-key-signature-provider.js.map