"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@requestnetwork/types");
const Semver = require("semver");
const action_1 = require("../action");
const version_1 = require("../version");
const utils_1 = require("@requestnetwork/utils");
/**
 * Implementation of the request logic specification
 */
exports.default = {
    createRequest,
    format,
};
/**
 * Function to format  action to create a Request
 *
 * If requestParameters.timestamp not given, "Date.now() / 1000" will be used as default
 *
 * @param requestParameters ICreateParameters parameters to create a request
 * @param IIdentity signerIdentity Identity of the signer
 * @param ISignatureProvider signatureProvider Signature provider in charge of the signature
 *
 * @returns IAction  the action with the signature
 */
function format(requestParameters, signerIdentity, signatureProvider) {
    if (!requestParameters.payee && !requestParameters.payer) {
        throw new Error('payee or PayerId must be given');
    }
    if (!(0, utils_1.isValidAmount)(requestParameters.expectedAmount)) {
        throw new Error('expectedAmount must be a positive integer');
    }
    if (requestParameters.payee && (0, utils_1.identityHasError)(requestParameters.payee)) {
        throw new Error(`payee: ${(0, utils_1.identityHasError)(requestParameters.payee)}̀`);
    }
    if (requestParameters.payer && (0, utils_1.identityHasError)(requestParameters.payer)) {
        throw new Error(`payer: ${(0, utils_1.identityHasError)(requestParameters.payer)}̀`);
    }
    if (!requestParameters.timestamp) {
        requestParameters.timestamp = (0, utils_1.getCurrentTimestampInSecond)();
    }
    // convert expectedAmount to string to have a consistent numbering
    requestParameters.expectedAmount = requestParameters.expectedAmount.toString();
    const version = version_1.default.currentVersion;
    const unsignedAction = {
        name: types_1.RequestLogicTypes.ACTION_NAME.CREATE,
        parameters: requestParameters,
        version,
    };
    const signerRole = action_1.default.getRoleInUnsignedAction(signerIdentity, unsignedAction);
    if (signerRole !== types_1.RequestLogicTypes.ROLE.PAYEE && signerRole !== types_1.RequestLogicTypes.ROLE.PAYER) {
        throw new Error('Signer must be the payee or the payer');
    }
    return action_1.default.createAction(unsignedAction, signerIdentity, signatureProvider);
}
/**
 * Function to create a request (create a request)
 *
 * @param Types.IAction action the action to evaluate
 *
 * @returns Types.IRequest the new request
 */
function createRequest(action, timestamp) {
    if (!action.data.parameters.payee && !action.data.parameters.payer) {
        throw new Error('action.parameters.payee or action.parameters.payer must be given');
    }
    if (action.data.parameters.payee && (0, utils_1.identityHasError)(action.data.parameters.payee)) {
        throw new Error(`payee: ${(0, utils_1.identityHasError)(action.data.parameters.payee)}̀`);
    }
    if (action.data.parameters.payer && (0, utils_1.identityHasError)(action.data.parameters.payer)) {
        throw new Error(`payer: ${(0, utils_1.identityHasError)(action.data.parameters.payer)}̀`);
    }
    if (!(0, utils_1.isString)(action.data.parameters.expectedAmount) ||
        !(0, utils_1.isValidAmount)(action.data.parameters.expectedAmount)) {
        throw new Error('action.parameters.expectedAmount must be a string representing a positive integer');
    }
    const signer = action_1.default.getSignerIdentityFromAction(action);
    // Copy to not modify the action itself
    const request = (0, utils_1.deepCopy)(action.data.parameters);
    request.extensions = {};
    request.requestId = action_1.default.getRequestId(action);
    request.version = action_1.default.getVersionFromAction(action);
    request.events = [generateEvent(action, timestamp, signer)];
    // If we're creating an older version of a request, we convert the string currency type to the new ICurrency one
    if (Semver.lt(action.data.version, '2.0.2')) {
        request.currency = legacyEnumToICurrencyConvert(action.data.parameters.currency);
    }
    const signerRole = action_1.default.getRoleInAction(signer, action);
    if (signerRole === types_1.RequestLogicTypes.ROLE.PAYEE) {
        request.state = types_1.RequestLogicTypes.STATE.CREATED;
        request.creator = action.data.parameters.payee;
        return request;
    }
    if (signerRole === types_1.RequestLogicTypes.ROLE.PAYER) {
        request.state = types_1.RequestLogicTypes.STATE.ACCEPTED;
        request.creator = action.data.parameters.payer;
        return request;
    }
    throw new Error('Signer must be the payee or the payer');
}
/**
 * Private function to generate the event 'Create' from an action
 *
 * @param Types.IAction action the action data that create the event
 * @param IdentityTypes.IIdentity actionSigner the signer of the action
 *
 * @returns Types.IEvent the event generated
 */
function generateEvent(action, timestamp, actionSigner) {
    const params = action.data.parameters;
    const event = {
        actionSigner,
        name: types_1.RequestLogicTypes.ACTION_NAME.CREATE,
        parameters: {
            expectedAmount: params.expectedAmount,
            extensionsDataLength: params.extensionsData ? params.extensionsData.length : 0,
            isSignedRequest: false,
        },
        timestamp,
    };
    return event;
}
/**
 * Converts legacy enum CURRENCY format to ICurrency object
 *
 * @param currency The old currency string format
 * @returns The ICurrency object
 */
function legacyEnumToICurrencyConvert(currency) {
    switch (currency) {
        case 'BTC':
            return {
                network: 'mainnet',
                type: types_1.RequestLogicTypes.CURRENCY.BTC,
                value: 'BTC',
            };
        case 'ETH':
            return {
                network: 'mainnet',
                type: types_1.RequestLogicTypes.CURRENCY.ETH,
                value: 'ETH',
            };
        case 'EUR':
            return {
                type: types_1.RequestLogicTypes.CURRENCY.ISO4217,
                value: 'EUR',
            };
        case 'USD':
            return {
                type: types_1.RequestLogicTypes.CURRENCY.ISO4217,
                value: 'USD',
            };
        case 'DAI': // DON'T RENAME: DAI was the name used by the legacy requests for SAI
            return {
                type: types_1.RequestLogicTypes.CURRENCY.ERC20,
                value: '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359', // SAI
            };
        default:
            throw new Error('Unsupported currency when getting request from transactions.');
    }
}
//# sourceMappingURL=create.js.map