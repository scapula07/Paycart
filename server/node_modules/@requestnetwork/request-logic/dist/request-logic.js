"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const events_1 = require("events");
const multi_format_1 = require("@requestnetwork/multi-format");
const types_1 = require("@requestnetwork/types");
const requestLogicCore_1 = require("./requestLogicCore");
const utils_1 = require("@requestnetwork/utils");
/**
 * Implementation of Request Logic
 */
class RequestLogic {
    constructor(transactionManager, signatureProvider, advancedLogic) {
        this.transactionManager = transactionManager;
        this.signatureProvider = signatureProvider;
        this.advancedLogic = advancedLogic;
    }
    /**
     * Creates a request and persists it on the transaction manager layer
     *
     * @param ICreateParameters parameters to create a request
     * @param signerIdentity Identity of the signer
     * @param topics list of string to topic the request
     *
     * @returns the request id and the meta data
     */
    createRequest(requestParameters, signerIdentity, topics = []) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { action, requestId, hashedTopics } = yield this.createCreationActionRequestIdAndTopics(requestParameters, signerIdentity, topics);
            // Validate the action, the apply will throw in case of error
            requestLogicCore_1.default.applyActionToRequest(null, action, Date.now(), this.advancedLogic);
            const resultPersistTx = yield this.transactionManager.persistTransaction(JSON.stringify(action), requestId, hashedTopics);
            const result = Object.assign(new events_1.EventEmitter(), {
                meta: { transactionManagerMeta: resultPersistTx.meta },
                result: { requestId },
            });
            // When receive the confirmation from transaction manager propagate it
            resultPersistTx
                .on('confirmed', (resultPersistTxConfirmed) => {
                result.emit('confirmed', {
                    meta: { transactionManagerMeta: resultPersistTxConfirmed.meta },
                    result: { requestId },
                });
            })
                .on('error', (error) => {
                result.emit('error', error);
            });
            return result;
        });
    }
    /**
     * Creates an encrypted request and persists it on the transaction manager layer
     *
     * @param requestParameters parameters to create a request
     * @param signerIdentity Identity of the signer
     * @param encryptionParams list of encryption parameters to encrypt the channel key with
     * @param topics list of string to topic the request
     *
     * @returns the request id and the meta data
     */
    createEncryptedRequest(requestParameters, signerIdentity, encryptionParams, topics = []) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (encryptionParams.length === 0) {
                throw new Error('You must give at least one encryption parameter to create an encrypted request');
            }
            const { action, requestId, hashedTopics } = yield this.createCreationActionRequestIdAndTopics(requestParameters, signerIdentity, topics);
            // Validate the action, the apply will throw in case of error
            requestLogicCore_1.default.applyActionToRequest(null, action, Date.now(), this.advancedLogic);
            const resultPersistTx = yield this.transactionManager.persistTransaction(JSON.stringify(action), requestId, hashedTopics, encryptionParams);
            const result = Object.assign(new events_1.EventEmitter(), {
                meta: { transactionManagerMeta: resultPersistTx.meta },
                result: { requestId },
            });
            // When receive the confirmation from transaction manager propagate it
            resultPersistTx
                .on('confirmed', (resultPersistTxConfirmed) => {
                result.emit('confirmed', {
                    meta: { transactionManagerMeta: resultPersistTxConfirmed.meta },
                    result: { requestId },
                });
            })
                .on('error', (error) => {
                result.emit('error', error);
            });
            return result;
        });
    }
    /**
     * Function to compute the id of a request without creating it
     *
     * @param requestParameters ICreateParameters parameters to create a request
     * @param IIdentity signerIdentity Identity of the signer
     *
     * @returns Promise<RequestLogicTypes.RequestId> the request id
     */
    computeRequestId(requestParameters, signerIdentity) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.signatureProvider) {
                throw new Error('You must give a signature provider to create actions');
            }
            const action = yield requestLogicCore_1.default.formatCreate(requestParameters, signerIdentity, this.signatureProvider);
            // Validate the action, the apply will throw in case of error
            requestLogicCore_1.default.applyActionToRequest(null, action, Date.now(), this.advancedLogic);
            return requestLogicCore_1.default.getRequestIdFromAction(action);
        });
    }
    /**
     * Function to accept a request   it on through the transaction manager layer
     *
     * @param IAcceptParameters acceptParameters parameters to accept a request
     * @param IIdentity signerIdentity Identity of the signer
     * @param boolean validate specifies if a validation should be done before persisting the transaction. Requires a full load of the Request.
     *
     * @returns Promise<IRequestLogicReturn> the meta data
     */
    acceptRequest(requestParameters, signerIdentity, validate = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.signatureProvider) {
                throw new Error('You must give a signature provider to create actions');
            }
            const action = yield requestLogicCore_1.default.formatAccept(requestParameters, signerIdentity, this.signatureProvider);
            const requestId = requestLogicCore_1.default.getRequestIdFromAction(action);
            if (validate) {
                yield this.validateAction(requestId, action);
            }
            const resultPersistTx = yield this.transactionManager.persistTransaction(JSON.stringify(action), requestId);
            const result = Object.assign(new events_1.EventEmitter(), {
                meta: { transactionManagerMeta: resultPersistTx.meta },
            });
            // When receive the confirmation from transaction manager propagate it
            resultPersistTx
                .on('confirmed', (resultPersistTxConfirmed) => {
                result.emit('confirmed', {
                    meta: { transactionManagerMeta: resultPersistTxConfirmed.meta },
                });
            })
                .on('error', (error) => {
                result.emit('error', error);
            });
            return result;
        });
    }
    /**
     * Function to cancel a request and persist it on through the transaction manager layer
     *
     * @param ICancelParameters cancelParameters parameters to cancel a request
     * @param IIdentity signerIdentity Identity of the signer
     * @param boolean validate specifies if a validation should be done before persisting the transaction. Requires a full load of the Request.
     *
     * @returns Promise<IRequestLogicReturn> the meta data
     */
    cancelRequest(requestParameters, signerIdentity, validate = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.signatureProvider) {
                throw new Error('You must give a signature provider to create actions');
            }
            const action = yield requestLogicCore_1.default.formatCancel(requestParameters, signerIdentity, this.signatureProvider);
            const requestId = requestLogicCore_1.default.getRequestIdFromAction(action);
            if (validate) {
                yield this.validateAction(requestId, action);
            }
            const resultPersistTx = yield this.transactionManager.persistTransaction(JSON.stringify(action), requestId);
            const result = Object.assign(new events_1.EventEmitter(), {
                meta: { transactionManagerMeta: resultPersistTx.meta },
            });
            // When receive the confirmation from transaction manager propagate it
            resultPersistTx
                .on('confirmed', (resultPersistTxConfirmed) => {
                result.emit('confirmed', {
                    meta: { transactionManagerMeta: resultPersistTxConfirmed.meta },
                });
            })
                .on('error', (error) => {
                result.emit('error', error);
            });
            return result;
        });
    }
    /**
     * Function to increase expected amount of a request and persist it on through the transaction manager layer
     *
     * @param IIncreaseExpectedAmountParameters increaseAmountParameters parameters to increase expected amount of a request
     * @param IIdentity signerIdentity Identity of the signer
     * @param boolean validate specifies if a validation should be done before persisting the transaction. Requires a full load of the Request.
     *
     * @returns Promise<IRequestLogicReturn> the meta data
     */
    increaseExpectedAmountRequest(requestParameters, signerIdentity, validate = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.signatureProvider) {
                throw new Error('You must give a signature provider to create actions');
            }
            const action = yield requestLogicCore_1.default.formatIncreaseExpectedAmount(requestParameters, signerIdentity, this.signatureProvider);
            const requestId = requestLogicCore_1.default.getRequestIdFromAction(action);
            if (validate) {
                yield this.validateAction(requestId, action);
            }
            const resultPersistTx = yield this.transactionManager.persistTransaction(JSON.stringify(action), requestId);
            const result = Object.assign(new events_1.EventEmitter(), {
                meta: { transactionManagerMeta: resultPersistTx.meta },
            });
            // When receive the confirmation from transaction manager propagate it
            resultPersistTx
                .on('confirmed', (resultPersistTxConfirmed) => {
                result.emit('confirmed', {
                    meta: { transactionManagerMeta: resultPersistTxConfirmed.meta },
                });
            })
                .on('error', (error) => {
                result.emit('error', error);
            });
            return result;
        });
    }
    /**
     * Function to reduce expected amount of a request and persist it on through the transaction manager layer
     *
     * @param IReduceExpectedAmountParameters reduceAmountParameters parameters to reduce expected amount of a request
     * @param IIdentity signerIdentity Identity of the signer
     * @param boolean validate specifies if a validation should be done before persisting the transaction. Requires a full load of the Request.
     *
     * @returns Promise<IRequestLogicReturn> the meta data
     */
    reduceExpectedAmountRequest(requestParameters, signerIdentity, validate = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.signatureProvider) {
                throw new Error('You must give a signature provider to create actions');
            }
            const action = yield requestLogicCore_1.default.formatReduceExpectedAmount(requestParameters, signerIdentity, this.signatureProvider);
            const requestId = requestLogicCore_1.default.getRequestIdFromAction(action);
            if (validate) {
                yield this.validateAction(requestId, action);
            }
            const resultPersistTx = yield this.transactionManager.persistTransaction(JSON.stringify(action), requestId);
            const result = Object.assign(new events_1.EventEmitter(), {
                meta: { transactionManagerMeta: resultPersistTx.meta },
            });
            // When receive the confirmation from transaction manager propagate it
            resultPersistTx
                .on('confirmed', (resultPersistTxConfirmed) => {
                result.emit('confirmed', {
                    meta: { transactionManagerMeta: resultPersistTxConfirmed.meta },
                });
            })
                .on('error', (error) => {
                result.emit('error', error);
            });
            return result;
        });
    }
    /**
     * Function to add stakeholders to a request and persist it on through the transaction manager layer
     *
     * @param IAddStakeholdersParameters requestParameters parameters to add stakeholders to a request
     * @param IIdentity signerIdentity Identity of the signer
     * @param IEncryptionParameters encryptionParams list of addtional encryption parameters to encrypt the channel key with
     * @param boolean validate specifies if a validation should be done before persisting the transaction. Requires a full load of the Request.
     *
     * @returns Promise<IRequestLogicReturn> the meta data
     */
    addStakeholders(requestParameters, signerIdentity, encryptionParams, validate = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.signatureProvider) {
                throw new Error('You must give a signature provider to create actions');
            }
            const action = yield requestLogicCore_1.default.formatAddStakeholders(requestParameters, signerIdentity, this.signatureProvider);
            const requestId = requestLogicCore_1.default.getRequestIdFromAction(action);
            if (validate) {
                yield this.validateAction(requestId, action);
            }
            const resultPersistTx = yield this.transactionManager.persistTransaction(JSON.stringify(action), requestId, undefined, encryptionParams);
            const result = Object.assign(new events_1.EventEmitter(), {
                meta: { transactionManagerMeta: resultPersistTx.meta },
            });
            // When receive the confirmation from transaction manager propagate it
            resultPersistTx
                .on('confirmed', (resultPersistTxConfirmed) => {
                result.emit('confirmed', {
                    meta: { transactionManagerMeta: resultPersistTxConfirmed.meta },
                });
            })
                .on('error', (error) => {
                result.emit('error', error);
            });
            return result;
        });
    }
    /**
     * Function to add extensions data to a request and persist it through the transaction manager layer
     *
     * @param IAddExtensionsDataParameters requestParameters parameters to add extensions Data to a request
     * @param IIdentity signerIdentity Identity of the signer
     * @param boolean validate specifies if a validation should be done before persisting the transaction. Requires a full load of the Request.
     *
     * @returns Promise<IRequestLogicReturn> the meta data
     */
    addExtensionsDataRequest(requestParameters, signerIdentity, validate = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.signatureProvider) {
                throw new Error('You must give a signature provider to create actions');
            }
            const action = yield requestLogicCore_1.default.formatAddExtensionsData(requestParameters, signerIdentity, this.signatureProvider);
            const requestId = requestLogicCore_1.default.getRequestIdFromAction(action);
            if (validate) {
                yield this.validateAction(requestId, action);
            }
            const resultPersistTx = yield this.transactionManager.persistTransaction(JSON.stringify(action), requestId);
            const result = Object.assign(new events_1.EventEmitter(), {
                meta: { transactionManagerMeta: resultPersistTx.meta },
            });
            // When receive the confirmation from transaction manager propagate it
            resultPersistTx
                .on('confirmed', (resultPersistTxConfirmed) => {
                result.emit('confirmed', {
                    meta: { transactionManagerMeta: resultPersistTxConfirmed.meta },
                });
            })
                .on('error', (error) => {
                result.emit('error', error);
            });
            return result;
        });
    }
    /**
     * Function to get a request from the request id from the actions in the data-access layer
     *
     * @param requestId the requestId of the request to retrieve
     *
     * @returns the request constructed from the actions
     */
    getRequestFromId(requestId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { ignoredTransactions, confirmedRequestState, pendingRequestState, transactionManagerMeta, } = yield this.computeRequestFromRequestId(requestId);
            const pending = this.computeDiffBetweenPendingAndConfirmedRequestState(confirmedRequestState, pendingRequestState);
            return {
                meta: {
                    ignoredTransactions,
                    transactionManagerMeta,
                },
                result: { request: confirmedRequestState, pending },
            };
        });
    }
    /**
     * Gets the requests indexed by a topic from the transactions of transaction-manager layer
     *
     * @returns all the requests indexed by topic
     */
    getRequestsByTopic(topic, updatedBetween) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // hash all the topics
            const hashedTopic = multi_format_1.default.serialize((0, utils_1.normalizeKeccak256Hash)(topic));
            const getChannelsResult = yield this.transactionManager.getChannelsByTopic(hashedTopic, updatedBetween);
            return this.computeMultipleRequestFromChannels(getChannelsResult);
        });
    }
    /**
     * Gets the requests indexed by multiple topics from the transactions of transaction-manager layer
     *
     * @returns all the requests indexed by topics
     */
    getRequestsByMultipleTopics(topics, updatedBetween) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // hash all the topics
            const hashedTopics = topics.map((topic) => multi_format_1.default.serialize((0, utils_1.normalizeKeccak256Hash)(topic)));
            const getChannelsResult = yield this.transactionManager.getChannelsByMultipleTopics(hashedTopics, updatedBetween);
            return this.computeMultipleRequestFromChannels(getChannelsResult);
        });
    }
    /**
     * Creates the creation action and the requestId of a request
     *
     * @param requestParameters parameters to create a request
     * @param signerIdentity Identity of the signer
     *
     * @returns the request id, the action and the hashed topics
     */
    createCreationActionRequestIdAndTopics(requestParameters, signerIdentity, topics) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.signatureProvider) {
                throw new Error('You must give a signature provider to create actions');
            }
            const action = yield requestLogicCore_1.default.formatCreate(requestParameters, signerIdentity, this.signatureProvider);
            const requestId = requestLogicCore_1.default.getRequestIdFromAction(action);
            // hash all the topics
            const hashedTopics = topics.map((topic) => multi_format_1.default.serialize((0, utils_1.normalizeKeccak256Hash)(topic)));
            return {
                action,
                hashedTopics,
                requestId,
            };
        });
    }
    /**
     * Interprets a request from requestId
     *
     * @param requestId the requestId of the request to compute
     * @returns the request, the pending state of the request and the ignored transactions
     */
    computeRequestFromRequestId(requestId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const resultGetTx = yield this.transactionManager.getTransactionsByChannelId(requestId);
            const actions = resultGetTx.result.transactions
                // filter the actions ignored by the previous layers
                .filter(utils_1.notNull)
                .sort((a, b) => a.timestamp - b.timestamp);
            // eslint-disable-next-line prefer-const
            let { ignoredTransactions, keptTransactions } = this.removeOldPendingTransactions(actions);
            // array of transaction without duplicates to avoid replay attack
            const timestampedActionsWithoutDuplicates = (0, utils_1.uniqueByProperty)(keptTransactions
                .filter(utils_1.notNull)
                .map((t) => {
                try {
                    return {
                        action: JSON.parse(t.transaction.data || ''),
                        state: t.state,
                        timestamp: t.timestamp,
                    };
                }
                catch (e) {
                    // We ignore the transaction.data that cannot be parsed
                    ignoredTransactions.push({
                        reason: 'JSON parsing error',
                        transaction: t,
                    });
                    return;
                }
            })
                .filter(utils_1.notNull), 'action');
            // Keeps the transaction ignored
            ignoredTransactions = ignoredTransactions.concat(timestampedActionsWithoutDuplicates.duplicates.map((tx) => {
                return {
                    reason: 'Duplicated transaction',
                    transaction: tx,
                };
            }));
            const { confirmedRequestState, pendingRequestState, ignoredTransactionsByApplication } = yield this.computeRequestFromTransactions(timestampedActionsWithoutDuplicates.uniqueItems);
            ignoredTransactions = ignoredTransactions.concat(ignoredTransactionsByApplication);
            return {
                confirmedRequestState,
                ignoredTransactions,
                pendingRequestState,
                transactionManagerMeta: resultGetTx.meta,
            };
        });
    }
    /**
     * Interprets a request from transactions
     *
     * @param transactions transactions to compute the request from
     * @returns the request and the ignoredTransactions
     */
    computeRequestFromTransactions(transactions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const ignoredTransactionsByApplication = [];
            // second parameter is null, because the first action must be a creation (no state expected)
            const confirmedRequestState = transactions
                .filter((action) => action.state === types_1.TransactionTypes.TransactionState.CONFIRMED)
                .reduce((requestState, actionConfirmed) => {
                try {
                    return requestLogicCore_1.default.applyActionToRequest(requestState, actionConfirmed.action, actionConfirmed.timestamp, this.advancedLogic);
                }
                catch (e) {
                    // if an error occurs while applying we ignore the action
                    ignoredTransactionsByApplication.push({
                        reason: e.message,
                        transaction: actionConfirmed,
                    });
                    return requestState;
                }
            }, null);
            const pendingRequestState = transactions
                .filter((action) => action.state === types_1.TransactionTypes.TransactionState.PENDING)
                .reduce((requestState, actionConfirmed) => {
                try {
                    return requestLogicCore_1.default.applyActionToRequest(requestState, actionConfirmed.action, actionConfirmed.timestamp, this.advancedLogic);
                }
                catch (e) {
                    // if an error occurs while applying we ignore the action
                    ignoredTransactionsByApplication.push({
                        reason: e.message,
                        transaction: actionConfirmed,
                    });
                    return requestState;
                }
            }, confirmedRequestState);
            return {
                confirmedRequestState,
                ignoredTransactionsByApplication,
                pendingRequestState,
            };
        });
    }
    /**
     * Interprets multiple requests from channels
     *
     * @param channelsRawData returned value by getChannels function
     * @returns the requests and meta data
     */
    computeMultipleRequestFromChannels(channelsRawData) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const transactionsByChannel = channelsRawData.result.transactions;
            const transactionManagerMeta = channelsRawData.meta.dataAccessMeta;
            // Gets all the requests from the transactions
            const allRequestAndMetaPromises = Object.keys(channelsRawData.result.transactions).map(
            // Parses and removes corrupted or duplicated transactions
            (channelId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                // eslint-disable-next-line prefer-const
                let { ignoredTransactions, keptTransactions } = this.removeOldPendingTransactions(transactionsByChannel[channelId]);
                const timestampedActionsWithoutDuplicates = (0, utils_1.uniqueByProperty)(keptTransactions
                    // filter the actions ignored by the previous layers
                    .filter(utils_1.notNull)
                    .map((t) => {
                    try {
                        return {
                            action: JSON.parse(t.transaction.data || ''),
                            state: t.state,
                            timestamp: t.timestamp,
                        };
                    }
                    catch (e) {
                        // We ignore the transaction.data that cannot be parsed
                        ignoredTransactions.push({
                            reason: 'JSON parsing error',
                            transaction: t,
                        });
                        return;
                    }
                })
                    .filter(utils_1.notNull), 'action');
                // Keeps the ignored transactions
                ignoredTransactions = ignoredTransactions.concat(timestampedActionsWithoutDuplicates.duplicates.map((tx) => ({
                    reason: 'Duplicated transaction',
                    transaction: tx,
                })));
                // Computes the request from the transactions
                const { confirmedRequestState, pendingRequestState, ignoredTransactionsByApplication } = yield this.computeRequestFromTransactions(timestampedActionsWithoutDuplicates.uniqueItems);
                ignoredTransactions = ignoredTransactions.concat(ignoredTransactionsByApplication);
                const pending = this.computeDiffBetweenPendingAndConfirmedRequestState(confirmedRequestState, pendingRequestState);
                return {
                    ignoredTransactions,
                    pending,
                    request: confirmedRequestState,
                    transactionManagerMeta: transactionManagerMeta[channelId],
                };
            }));
            const allRequestAndMeta = yield Promise.all(allRequestAndMetaPromises);
            // Merge all the requests and meta in one object
            return allRequestAndMeta.reduce((finalResult, requestAndMeta) => {
                if (requestAndMeta.request || requestAndMeta.pending) {
                    finalResult.result.requests.push({
                        pending: requestAndMeta.pending,
                        request: requestAndMeta.request,
                    });
                    // workaround to quiet the error "finalResult.meta.ignoredTransactions can be undefined" (but defined in the initialization value of the accumulator)
                    (finalResult.meta.ignoredTransactions || []).push(requestAndMeta.ignoredTransactions);
                    // add the transactionManagerMeta
                    (finalResult.meta.transactionManagerMeta || []).push(requestAndMeta.transactionManagerMeta);
                }
                return finalResult;
            }, {
                meta: {
                    ignoredTransactions: [],
                    transactionManagerMeta: [],
                },
                result: { requests: [] },
            });
        });
    }
    /**
     * Validates an action, throws if the action is invalid
     *
     * @param requestId the requestId of the request to retrieve
     * @param action the action to validate
     *
     * @returns void, throws if the action is invalid
     */
    validateAction(requestId, action) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { confirmedRequestState, pendingRequestState } = yield this.computeRequestFromRequestId(requestId);
            try {
                // Check if the action doesn't fail with the request state
                requestLogicCore_1.default.applyActionToRequest(confirmedRequestState, action, Date.now(), this.advancedLogic);
            }
            catch (error) {
                // Check if the action works with the pending state
                if (pendingRequestState) {
                    requestLogicCore_1.default.applyActionToRequest(pendingRequestState, action, Date.now(), this.advancedLogic);
                }
            }
        });
    }
    /**
     * Computes the diff between the confirmed and pending request
     *
     * @param confirmedRequestState the confirmed request state
     * @param pendingRequestState the pending request state
     * @returns an object with the pending state attributes that are different from the confirmed one
     */
    computeDiffBetweenPendingAndConfirmedRequestState(confirmedRequestState, pendingRequestState) {
        // Compute the diff between the confirmed and pending request
        let pending = null;
        if (!confirmedRequestState) {
            pending = pendingRequestState;
        }
        else if (pendingRequestState) {
            for (const key in pendingRequestState) {
                if (key in pendingRequestState) {
                    // TODO: Should find a better way to do that
                    if ((0, utils_1.normalizeKeccak256Hash)(pendingRequestState[key]).value !==
                        (0, utils_1.normalizeKeccak256Hash)(confirmedRequestState[key]).value) {
                        if (!pending) {
                            pending = {};
                        }
                        // eslint-disable-next-line
                        if (key === 'events') {
                            // keep only the new events in pending
                            pending[key] = pendingRequestState[key].slice(confirmedRequestState[key].length);
                        }
                        else {
                            pending[key] = pendingRequestState[key];
                        }
                    }
                }
            }
        }
        return pending;
    }
    /**
     * Sorts out the transactions pending older than confirmed ones
     *
     * @param actions list of the actions
     * @returns an object with the ignoredTransactions and the kept actions
     */
    removeOldPendingTransactions(transactions) {
        const ignoredTransactions = [];
        // ignored the transactions pending older than confirmed ones
        let confirmedFound = false;
        const keptTransactions = transactions
            .reverse()
            .filter((action) => {
            if (!action) {
                return false;
            }
            // Have we already found confirmed transactions
            confirmedFound =
                confirmedFound || action.state === types_1.TransactionTypes.TransactionState.CONFIRMED;
            // keep the transaction if confirmed or pending but no confirmed found before
            if (action.state === types_1.TransactionTypes.TransactionState.CONFIRMED ||
                (action.state === types_1.TransactionTypes.TransactionState.PENDING && !confirmedFound)) {
                return true;
            }
            else {
                // Keeps the ignored transactions
                ignoredTransactions.push({
                    reason: 'Confirmed transaction newer than this pending transaction',
                    transaction: action,
                });
                return false;
            }
        })
            .reverse();
        return { ignoredTransactions, keptTransactions };
    }
}
exports.default = RequestLogic;
//# sourceMappingURL=request-logic.js.map