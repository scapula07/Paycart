"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const multi_format_1 = require("@requestnetwork/multi-format");
const types_1 = require("@requestnetwork/types");
const utils_1 = require("@requestnetwork/utils");
const events_1 = require("events");
const channel_parser_1 = require("./channel-parser");
const transactions_factory_1 = require("./transactions-factory");
/**
 * Implementation of TransactionManager layer without encryption
 */
class TransactionManager {
    constructor(dataAccess, decryptionProvider) {
        this.dataAccess = dataAccess;
        this.channelParser = new channel_parser_1.default(decryptionProvider);
    }
    /**
     * Persists a transaction and topics in storage. If encryptionParams is given, the transaction will be encrypted
     *
     * @param transactionData transaction to persist
     * @param channelId string to identify a group of transactions
     * @param topics list of string to topic the transaction
     * @param encryptionParams list of encryption parameters to encrypt the channel key with
     *
     * @returns object containing the meta-data of the persist
     */
    persistTransaction(transactionData, channelId, topics = [], encryptionParams = []) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let transaction = {};
            let channelEncryptionMethod;
            // compute hash to add it to the topics
            const hash = multi_format_1.default.serialize((0, utils_1.normalizeKeccak256Hash)(JSON.parse(transactionData)));
            // Need to create a new channel (only the first transaction can have the hash equals to the channel id)
            if (channelId === hash) {
                if (encryptionParams.length === 0) {
                    // create a clear channel
                    transaction = yield transactions_factory_1.default.createClearTransaction(transactionData);
                }
                else {
                    // create an encrypted channel
                    transaction = yield transactions_factory_1.default.createEncryptedTransactionInNewChannel(transactionData, encryptionParams);
                    channelEncryptionMethod = transaction.encryptionMethod;
                }
                // Add the transaction to an existing channel
            }
            else {
                const resultGetTx = yield this.dataAccess.getTransactionsByChannelId(channelId);
                const { channelKey, channelType, encryptionMethod } = yield this.channelParser.getChannelTypeAndChannelKey(channelId, resultGetTx.result.transactions);
                if (channelType === types_1.TransactionTypes.ChannelType.UNKNOWN) {
                    throw new Error(`Impossible to retrieve the channel: ${channelId}`);
                }
                if (channelType === types_1.TransactionTypes.ChannelType.CLEAR) {
                    // add the transaction to a clear channel
                    transaction = yield transactions_factory_1.default.createClearTransaction(transactionData);
                }
                if (channelType === types_1.TransactionTypes.ChannelType.ENCRYPTED) {
                    if (!channelKey) {
                        throw new Error(`Impossible to decrypt the channel key of: ${channelId}`);
                    }
                    transaction = yield transactions_factory_1.default.createEncryptedTransaction(transactionData, channelKey, encryptionParams);
                    channelEncryptionMethod = encryptionMethod;
                }
            }
            const persistResult = yield this.dataAccess.persistTransaction(transaction, channelId, 
            // add the hash to the topics
            topics.concat([hash]));
            // Create the return result with EventEmitter
            const result = Object.assign(new events_1.EventEmitter(), {
                meta: {
                    dataAccessMeta: persistResult.meta,
                    encryptionMethod: channelEncryptionMethod,
                },
                result: {},
            });
            // When receive the confirmation from data-access propagate to the higher layer
            persistResult
                .on('confirmed', (resultPersistTransaction) => {
                const resultAfterConfirmation = {
                    meta: {
                        dataAccessMeta: resultPersistTransaction.meta,
                        encryptionMethod: channelEncryptionMethod,
                    },
                    result: {},
                };
                // propagate the confirmation
                result.emit('confirmed', resultAfterConfirmation);
            })
                .on('error', (error) => {
                result.emit('error', error);
            });
            return result;
        });
    }
    /**
     * Gets a list of transactions from a channel
     *
     * later it will handle decryption
     *
     * @param channelId channel id to retrieve the transactions from
     * @param timestampBoundaries timestamp boundaries of the transactions search
     * @returns list of transactions of the channel
     */
    getTransactionsByChannelId(channelId, timestampBoundaries) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const resultGetTx = yield this.dataAccess.getTransactionsByChannelId(channelId, timestampBoundaries);
            // Decrypts and cleans the channel from the data-access layers
            const { transactions, ignoredTransactions, encryptionMethod } = yield this.channelParser.decryptAndCleanChannel(channelId, resultGetTx.result.transactions);
            const meta = {
                dataAccessMeta: resultGetTx.meta,
                encryptionMethod,
                ignoredTransactions,
            };
            // Remove encryptionMethod from meta if it's undefined
            // to make it clearer the channel is not encrypted.
            if (!encryptionMethod) {
                delete meta.encryptionMethod;
            }
            return {
                meta,
                result: { transactions },
            };
        });
    }
    /**
     * Gets a list of channels indexed by topic
     *
     * @param topic topic to retrieve the channels from
     * @param updatedBetween filter the channel whose received new data in the boundaries
     * @returns list of channels indexed by topic
     */
    getChannelsByTopic(topic, updatedBetween) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const resultGetTx = yield this.dataAccess.getChannelsByTopic(topic, updatedBetween);
            return this.parseMultipleChannels(resultGetTx);
        });
    }
    /**
     * Gets a list of channels indexed by topics
     *
     * @param topics topics to retrieve the channels from
     * @param updatedBetween filter the channel whose hasn't received new data in the boundaries
     * @returns list of channels indexed by topics
     */
    getChannelsByMultipleTopics(topics, updatedBetween) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const resultGetTx = yield this.dataAccess.getChannelsByMultipleTopics(topics, updatedBetween);
            return this.parseMultipleChannels(resultGetTx);
        });
    }
    /**
     * Parses the return of getChannels function from data-access layer
     *
     * @param resultGetTx returned value from getChannels function
     * @returns decrypted and cleaned channels in the right format
     */
    parseMultipleChannels(resultGetTx) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Get the channels from the data-access layers to decrypt and clean them one by one
            const result = yield Object.keys(resultGetTx.result.transactions).reduce((accumulatorPromise, channelId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const cleaned = yield this.channelParser.decryptAndCleanChannel(channelId, resultGetTx.result.transactions[channelId]);
                // await for the accumulator promise at the end to parallelize the calls to decryptAndCleanChannel()
                const accumulator = yield accumulatorPromise;
                accumulator.transactions[channelId] = cleaned.transactions;
                accumulator.ignoredTransactions[channelId] = cleaned.ignoredTransactions;
                return accumulator;
            }), Promise.resolve({ transactions: {}, ignoredTransactions: {} }));
            return {
                meta: {
                    dataAccessMeta: resultGetTx.meta,
                    ignoredTransactions: result.ignoredTransactions,
                },
                result: { transactions: result.transactions },
            };
        });
    }
}
exports.default = TransactionManager;
//# sourceMappingURL=transaction-manager.js.map