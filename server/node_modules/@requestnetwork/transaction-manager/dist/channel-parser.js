"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const transactions_parser_1 = require("./transactions-parser");
/**
 * Class to parse channels from a list of transactions and their channel id
 */
class ChannelParser {
    constructor(decryptionProvider) {
        this.transactionParser = new transactions_parser_1.default(decryptionProvider);
    }
    /**
     * Decrypts and cleans a channel by removing the wrong transactions
     *
     * @param channelId the channelId of the channel
     * @param transactions the transactions of the channel to decrypt and clean
     * @returns Promise resolving the kept transactions and the ignored ones with the reason
     */
    decryptAndCleanChannel(channelId, transactions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let channelType = types_1.TransactionTypes.ChannelType.UNKNOWN;
            let encryptionMethod;
            // Search for channel key
            const { channelKey } = yield this.getChannelTypeAndChannelKey(channelId, transactions);
            // use of .reduce instead of .map to keep a sequential execution
            const validAndIgnoredTransactions = yield transactions.reduce((accumulatorPromise, timestampedTransaction) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const result = yield accumulatorPromise;
                let parsedData;
                try {
                    // Parse the transaction from data-access to get a transaction object and the channel key if encrypted
                    parsedData = yield this.transactionParser.parsePersistedTransaction(timestampedTransaction.transaction, channelType, channelKey, encryptionMethod);
                }
                catch (error) {
                    return result.concat([
                        {
                            ignored: {
                                reason: error.message,
                                transaction: timestampedTransaction,
                            },
                            valid: null,
                        },
                    ]);
                }
                const transaction = parsedData.transaction;
                // We check if the transaction is valid
                const error = yield transaction.getError();
                if (error !== '') {
                    return result.concat([
                        {
                            ignored: {
                                reason: error,
                                transaction: timestampedTransaction,
                            },
                            valid: null,
                        },
                    ]);
                }
                // If this is the first transaction, it removes the transaction if the hash is not the same as the channelId
                if (channelType === types_1.TransactionTypes.ChannelType.UNKNOWN) {
                    const hash = yield transaction.getHash();
                    if (hash !== channelId) {
                        return result.concat([
                            {
                                ignored: {
                                    reason: 'as first transaction, the hash of the transaction do not match the channelId',
                                    transaction: timestampedTransaction,
                                },
                                valid: null,
                            },
                        ]);
                    }
                    // from the first valid transaction, we can deduce the type of the channel
                    channelType = parsedData.channelKey
                        ? types_1.TransactionTypes.ChannelType.ENCRYPTED
                        : types_1.TransactionTypes.ChannelType.CLEAR;
                    encryptionMethod = parsedData.encryptionMethod;
                }
                const data = yield transaction.getData();
                // add the decrypted transaction as valid
                return result.concat([
                    {
                        ignored: null,
                        valid: {
                            state: timestampedTransaction.state,
                            timestamp: timestampedTransaction.timestamp,
                            transaction: { data },
                        },
                    },
                ]);
            }), Promise.resolve([]));
            const ignoredTransactions = validAndIgnoredTransactions.map((elem) => elem.ignored);
            const cleanTransactions = validAndIgnoredTransactions.map((elem) => elem.valid);
            // The cleaned result
            return {
                encryptionMethod,
                ignoredTransactions,
                transactions: cleanTransactions,
            };
        });
    }
    /**
     * Get channel type and channel key from a list of transactions (if applicable)
     *
     * @param _channelId the channelId of the channel
     * @param transactions the transactions of the channel to decrypt and clean
     * @returns Promise resolving the channel type and the channel key (if applicable)
     */
    getChannelTypeAndChannelKey(
    // TODO: Consider removing channelId argument
    _channelId, transactions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // use of .reduce instead of .map to keep a sequential execution
            const channelTypeAndKey = yield transactions.reduce((accumulatorPromise, timestampedTransaction) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const result = yield accumulatorPromise;
                // Skip remaining transactions if channel is CLEAR or after channelKey is found
                if (result.channelType === types_1.TransactionTypes.ChannelType.CLEAR || result.channelKey) {
                    return result;
                }
                let parsedData;
                try {
                    // Parse the transaction from data-access to get a transaction object and the channel key if encrypted
                    parsedData = yield this.transactionParser.parsePersistedTransaction(timestampedTransaction.transaction, result.channelType, result.channelKey, result.encryptionMethod);
                }
                catch (error) {
                    // If the transaction is encrypted but the channel key is not found, save channelType and encryptionMethod
                    if (error.message.startsWith('Impossible to decrypt the channel key from this transaction') &&
                        result.channelType === types_1.TransactionTypes.ChannelType.UNKNOWN) {
                        result.channelType = types_1.TransactionTypes.ChannelType.ENCRYPTED;
                        result.encryptionMethod = timestampedTransaction.transaction.encryptionMethod;
                    }
                    // Error during the parsing, we just ignore this transaction
                    return result;
                }
                const transaction = parsedData.transaction;
                // We check if the transaction is valid
                const error = yield transaction.getError();
                if (error !== '') {
                    // Error in the transaction, we just ignore it
                    return result;
                }
                // We can deduce the type of the channel
                result.channelType = parsedData.channelKey
                    ? types_1.TransactionTypes.ChannelType.ENCRYPTED
                    : types_1.TransactionTypes.ChannelType.CLEAR;
                // we keep the channelKey for this channel
                result.channelKey = parsedData.channelKey;
                // we keep the encryption method for this channel
                result.encryptionMethod = parsedData.encryptionMethod;
                return result;
            }), Promise.resolve({
                channelKey: undefined,
                channelType: types_1.TransactionTypes.ChannelType.UNKNOWN,
                encryptionMethod: undefined,
            }));
            return channelTypeAndKey;
        });
    }
}
exports.default = ChannelParser;
//# sourceMappingURL=channel-parser.js.map