"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const multi_format_1 = require("@requestnetwork/multi-format");
const types_1 = require("@requestnetwork/types");
const clear_transaction_1 = require("./clear-transaction");
const encrypted_transaction_1 = require("./encrypted-transaction");
/**
 * Class to parse transactions
 */
class TransactionsParser {
    constructor(decryptionProvider) {
        this.decryptionProvider = decryptionProvider;
    }
    /**
     * Parses a persisted transaction into a ClearTransaction or EncryptedTransaction, and decrypts the channel key if needed
     *
     * @param persistedTransaction the persisted transaction to parse
     * @param channelType The channel type (unknown, clear or encrypted)
     * @param channelKey the channel key to decrypt the transaction if needed
     * @param encryptionMethod the channel encryption method to decrypt the transaction if needed
     * @returns the transaction object and the channel key (if applicable)
     */
    parsePersistedTransaction(persistedTransaction, channelType, channelKey, encryptionMethod) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // looks like a clear transaction
            if (persistedTransaction.data) {
                if (channelType === types_1.TransactionTypes.ChannelType.ENCRYPTED) {
                    throw new Error('Clear transactions are not allowed in encrypted channel');
                }
                if (persistedTransaction.encryptedData ||
                    persistedTransaction.encryptionMethod ||
                    persistedTransaction.keys) {
                    throw new Error('only the property "data" is allowed for clear transaction');
                }
                return { transaction: new clear_transaction_1.default(persistedTransaction.data) };
            }
            // looks like an encrypted transaction
            if (persistedTransaction.encryptedData) {
                if (channelType === types_1.TransactionTypes.ChannelType.CLEAR) {
                    throw new Error('Encrypted transactions are not allowed in clear channel');
                }
                // no channel key, try to decrypt it and validate encryption method
                if (!channelKey) {
                    // no encryptionMethod, this is first tx, must contain encryptionMethod
                    if (!encryptionMethod) {
                        if (!persistedTransaction.encryptionMethod || !persistedTransaction.keys) {
                            throw new Error('the properties "encryptionMethod" and "keys" are needed to compute the channel key');
                        }
                        encryptionMethod = persistedTransaction.encryptionMethod;
                        channelKey = yield this.decryptChannelKey(persistedTransaction.keys, encryptionMethod);
                    }
                    // given encryptionMethod, this not first tx, must not contain encryptionMethod
                    else {
                        if (persistedTransaction.encryptionMethod) {
                            throw new Error('the "encryptionMethod" property has been already given for this channel');
                        }
                        if (!persistedTransaction.keys) {
                            throw new Error('the "keys" property is needed to compute the channel key');
                        }
                        channelKey = yield this.decryptChannelKey(persistedTransaction.keys, encryptionMethod);
                    }
                }
                // given channel key, validate encryption method
                else {
                    // no encryptionMethod, this is first tx, must contain encryptionMethod
                    if (!encryptionMethod) {
                        if (!persistedTransaction.encryptionMethod) {
                            throw new Error('the "encryptionMethod" property is needed to use the channel key');
                        }
                        encryptionMethod = persistedTransaction.encryptionMethod;
                    }
                    // given encryptionMethod, this not first tx, must not contain encryptionMethod
                    else {
                        if (persistedTransaction.encryptionMethod) {
                            throw new Error('the "encryptionMethod" property has been already given for this channel');
                        }
                    }
                }
                return {
                    channelKey,
                    encryptionMethod,
                    transaction: new encrypted_transaction_1.default(persistedTransaction.encryptedData, channelKey),
                };
            }
            throw new Error('Transaction must have a property "data" or "encryptedData"');
        });
    }
    /**
     * Decrypts a channel key
     *
     * @param keys encrypted keys indexed by identity
     * @param encryptionMethod encryption method used for the channel
     * @returns the channel key
     */
    decryptChannelKey(keys, encryptionMethod) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Check if the decryption provider is given
            if (!this.decryptionProvider) {
                throw new Error(`No decryption provider given`);
            }
            let channelKeyMethod;
            // Check the encryption method
            if (encryptionMethod === `${types_1.EncryptionTypes.METHOD.ECIES}-${types_1.EncryptionTypes.METHOD.AES256_CBC}`) {
                channelKeyMethod = types_1.EncryptionTypes.METHOD.AES256_CBC;
            }
            else if (encryptionMethod === `${types_1.EncryptionTypes.METHOD.ECIES}-${types_1.EncryptionTypes.METHOD.AES256_GCM}`) {
                channelKeyMethod = types_1.EncryptionTypes.METHOD.AES256_GCM;
            }
            else {
                throw new Error(`Encryption method not supported: ${encryptionMethod}`);
            }
            let errorReason = '';
            // Try to decrypt the channelKey
            const channelKey = yield Object.keys(keys || {}).reduce((decryptedChannelKeyPromise, identityMultiFormatted) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                let decryptedChannelKey = yield decryptedChannelKeyPromise;
                if (keys && decryptedChannelKey === '') {
                    let identity;
                    try {
                        identity = multi_format_1.default.deserialize(identityMultiFormatted);
                    }
                    catch (e) {
                        // if we cannot deserialize it, just ignore this identity
                    }
                    // Ignore what is not an identity Ethereum address
                    if (identity && identity.type === types_1.IdentityTypes.TYPE.ETHEREUM_ADDRESS) {
                        // Check if we can decrypt the key with this identity
                        if (this.decryptionProvider &&
                            (yield this.decryptionProvider.isIdentityRegistered(identity))) {
                            try {
                                const key = multi_format_1.default.deserialize(keys[identityMultiFormatted]);
                                decryptedChannelKey = yield this.decryptionProvider.decrypt(key, identity);
                            }
                            catch (e) {
                                errorReason = e.message;
                            }
                        }
                    }
                }
                return decryptedChannelKey;
            }), Promise.resolve(''));
            if (channelKey === '') {
                throw new Error(`Impossible to decrypt the channel key from this transaction (${errorReason})`);
            }
            return {
                key: channelKey,
                method: channelKeyMethod,
            };
        });
    }
}
exports.default = TransactionsParser;
//# sourceMappingURL=transactions-parser.js.map