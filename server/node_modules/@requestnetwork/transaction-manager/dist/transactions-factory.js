"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const multi_format_1 = require("@requestnetwork/multi-format");
const types_1 = require("@requestnetwork/types");
const utils_1 = require("@requestnetwork/utils");
/**
 * Class to create transactions (clear and encrypted)
 */
class TransactionsFactory {
    /**
     * Creates a clear transaction with data
     *
     * @param data The data to create the transaction with
     * @returns the transaction
     */
    static createClearTransaction(data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                JSON.parse(data);
            }
            catch (error) {
                throw new Error('Data not parsable');
            }
            return { data };
        });
    }
    /**
     * Creates an encrypted transaction without a channel key
     *
     * @param data The data to create the transaction with
     * @param encryptionParams Array of the encryption parameters to encrypt the key with
     * @returns the encrypted transaction
     */
    static createEncryptedTransactionInNewChannel(data, encryptionParams) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // format encryption method property
            const encryptionMethod = `${types_1.EncryptionTypes.METHOD.ECIES}-${types_1.EncryptionTypes.METHOD.AES256_GCM}`;
            // Generate a key for the AES encryption
            const symmetricKey = yield (0, utils_1.generate32BufferKey)();
            // Encrypt the data with the key and the AES256-GCM algorithm
            const encryptedData = yield (0, utils_1.encrypt)(data, {
                key: symmetricKey,
                method: types_1.EncryptionTypes.METHOD.AES256_GCM,
            });
            try {
                JSON.parse(data);
            }
            catch (error) {
                throw new Error('Data not parsable');
            }
            // Check that all the encryption parameters given are ECIES (the only encryption method supported for now)
            if (!encryptionParams.every((encryptionParam) => encryptionParam.method === types_1.EncryptionTypes.METHOD.ECIES)) {
                throw new Error(`encryptionParams method must be all: ${types_1.EncryptionTypes.METHOD.ECIES}`);
            }
            // Compute key encryption and identity hash for every encryption parameters given
            const encryptedKeyAndIdentityHashesPromises = encryptionParams.map((encryptionParam) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const encryptedKey = yield (0, utils_1.encrypt)(symmetricKey, encryptionParam);
                const identityEncryption = (0, utils_1.getIdentityFromEncryptionParams)(encryptionParam);
                const multiFormattedIdentity = multi_format_1.default.serialize(identityEncryption);
                return { encryptedKey, multiFormattedIdentity };
            }));
            const encryptedKeyAndIdentityHashes = yield Promise.all(encryptedKeyAndIdentityHashesPromises);
            // Create the encrypted keys object - Encrypted keys indexed by identity multi-format
            const keys = encryptedKeyAndIdentityHashes.reduce((allKeys, keyAndHash) => {
                const encryptedKeySerialized = multi_format_1.default.serialize(keyAndHash.encryptedKey);
                allKeys[keyAndHash.multiFormattedIdentity] = encryptedKeySerialized;
                return allKeys;
            }, {});
            const encryptedDataSerialized = multi_format_1.default.serialize(encryptedData);
            return { encryptedData: encryptedDataSerialized, keys, encryptionMethod };
        });
    }
    /**
     * Creates an encrypted transaction with a channel key
     *
     * @param data The data to create the transaction with
     * @param channelKey Channel key use to encrypt the transaction
     * @param encryptionParams Array of additional encryption parameters to encrypt the key with
  
     * @returns the encrypted transaction
     */
    static createEncryptedTransaction(data, channelKey, encryptionParams = []) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // check if the encryption method is the good one
            if (channelKey.method !== types_1.EncryptionTypes.METHOD.AES256_GCM) {
                throw new Error(`encryption method not supported for the channel key: ${channelKey.method}`);
            }
            // Encrypt the data with the key and the AES256-GCM algorithm
            const encryptedData = yield (0, utils_1.encrypt)(data, channelKey);
            try {
                JSON.parse(data);
            }
            catch (error) {
                throw new Error('Data not parsable');
            }
            const encryptedDataSerialized = multi_format_1.default.serialize(encryptedData);
            if (encryptionParams.length === 0) {
                return { encryptedData: encryptedDataSerialized };
            }
            else {
                // FIXME: Refactor, duplicated from createEncryptedTransactionInNewChannel
                // Check that all the encryption parameters given are ECIES (the only encryption method supported for now)
                if (!encryptionParams.every((encryptionParam) => encryptionParam.method === types_1.EncryptionTypes.METHOD.ECIES)) {
                    throw new Error(`encryptionParams method must be all: ${types_1.EncryptionTypes.METHOD.ECIES}`);
                }
                // Compute key encryption and identity hash for every encryption parameters given
                const encryptedKeyAndIdentityHashesPromises = encryptionParams.map((encryptionParam) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const encryptedKey = yield (0, utils_1.encrypt)(channelKey.key, encryptionParam);
                    const identityEncryption = (0, utils_1.getIdentityFromEncryptionParams)(encryptionParam);
                    const multiFormattedIdentity = multi_format_1.default.serialize(identityEncryption);
                    return { encryptedKey, multiFormattedIdentity };
                }));
                const encryptedKeyAndIdentityHashes = yield Promise.all(encryptedKeyAndIdentityHashesPromises);
                // Create the encrypted keys object - Encrypted keys indexed by identity multi-format
                const keys = encryptedKeyAndIdentityHashes.reduce((allKeys, keyAndHash) => {
                    const encryptedKeySerialized = multi_format_1.default.serialize(keyAndHash.encryptedKey);
                    allKeys[keyAndHash.multiFormattedIdentity] = encryptedKeySerialized;
                    return allKeys;
                }, {});
                return { encryptedData: encryptedDataSerialized, keys };
            }
        });
    }
}
exports.default = TransactionsFactory;
//# sourceMappingURL=transactions-factory.js.map