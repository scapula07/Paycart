import { DataAccessTypes, DecryptionProviderTypes, EncryptionTypes, TransactionTypes } from '@requestnetwork/types';
/**
 * Implementation of TransactionManager layer without encryption
 */
export default class TransactionManager implements TransactionTypes.ITransactionManager {
    private dataAccess;
    private channelParser;
    constructor(dataAccess: DataAccessTypes.IDataAccess, decryptionProvider?: DecryptionProviderTypes.IDecryptionProvider);
    /**
     * Persists a transaction and topics in storage. If encryptionParams is given, the transaction will be encrypted
     *
     * @param transactionData transaction to persist
     * @param channelId string to identify a group of transactions
     * @param topics list of string to topic the transaction
     * @param encryptionParams list of encryption parameters to encrypt the channel key with
     *
     * @returns object containing the meta-data of the persist
     */
    persistTransaction(transactionData: TransactionTypes.ITransactionData, channelId: string, topics?: string[], encryptionParams?: EncryptionTypes.IEncryptionParameters[]): Promise<TransactionTypes.IReturnPersistTransaction>;
    /**
     * Gets a list of transactions from a channel
     *
     * later it will handle decryption
     *
     * @param channelId channel id to retrieve the transactions from
     * @param timestampBoundaries timestamp boundaries of the transactions search
     * @returns list of transactions of the channel
     */
    getTransactionsByChannelId(channelId: string, timestampBoundaries?: TransactionTypes.ITimestampBoundaries): Promise<TransactionTypes.IReturnGetTransactions>;
    /**
     * Gets a list of channels indexed by topic
     *
     * @param topic topic to retrieve the channels from
     * @param updatedBetween filter the channel whose received new data in the boundaries
     * @returns list of channels indexed by topic
     */
    getChannelsByTopic(topic: string, updatedBetween?: TransactionTypes.ITimestampBoundaries): Promise<TransactionTypes.IReturnGetTransactionsByChannels>;
    /**
     * Gets a list of channels indexed by topics
     *
     * @param topics topics to retrieve the channels from
     * @param updatedBetween filter the channel whose hasn't received new data in the boundaries
     * @returns list of channels indexed by topics
     */
    getChannelsByMultipleTopics(topics: string[], updatedBetween?: TransactionTypes.ITimestampBoundaries): Promise<TransactionTypes.IReturnGetTransactionsByChannels>;
    /**
     * Parses the return of getChannels function from data-access layer
     *
     * @param resultGetTx returned value from getChannels function
     * @returns decrypted and cleaned channels in the right format
     */
    private parseMultipleChannels;
}
//# sourceMappingURL=transaction-manager.d.ts.map