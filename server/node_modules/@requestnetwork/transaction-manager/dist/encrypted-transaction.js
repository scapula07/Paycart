"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const multi_format_1 = require("@requestnetwork/multi-format");
const utils_1 = require("@requestnetwork/utils");
/**
 * Class representing an encrypted transaction
 */
class EncryptedTransaction {
    /**
     * Creates an instance of EncryptedTransaction.
     * @param persistedData the encrypted data of the transaction
     * @param channelKey decryption parameters to decrypted the encrypted data
     */
    constructor(persistedData, channelKey) {
        /** Decrypted data - start empty then filled by getData() */
        this.data = '';
        /** Hash computed from the decrypted data - start empty then filled by getHash() */
        this.dataHashSerialized = '';
        this.persistedData = persistedData;
        this.channelKey = channelKey;
    }
    /**
     * Gets the data of the transaction
     *
     * @returns a promise resolving the transaction data
     */
    getData() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.data === '') {
                try {
                    const encryptedData = multi_format_1.default.deserialize(this.persistedData);
                    this.data = yield (0, utils_1.decrypt)(encryptedData, this.channelKey);
                }
                catch (_a) {
                    throw new Error('Impossible to decrypt the transaction');
                }
            }
            return this.data;
        });
    }
    /**
     * Gets the transaction data hash
     *
     * @returns a promise resolving the transaction data hash
     */
    getHash() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.dataHashSerialized === '') {
                const data = yield this.getData();
                try {
                    const dataHash = (0, utils_1.normalizeKeccak256Hash)(JSON.parse(data));
                    this.dataHashSerialized = multi_format_1.default.serialize(dataHash);
                }
                catch (e) {
                    throw new Error('Impossible to JSON parse the decrypted transaction data');
                }
            }
            return this.dataHashSerialized;
        });
    }
    /**
     * Gets the transaction error
     *
     * @returns a promise resolving a string of the error if any, otherwise an empty string
     */
    getError() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let data = '';
            try {
                data = yield this.getData();
            }
            catch (e) {
                return e.message;
            }
            try {
                JSON.parse(data);
            }
            catch (e) {
                return 'Impossible to JSON parse the decrypted transaction data';
            }
            return '';
        });
    }
}
exports.default = EncryptedTransaction;
//# sourceMappingURL=encrypted-transaction.js.map