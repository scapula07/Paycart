"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const events_1 = require("events");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const types_1 = require("@requestnetwork/types");
const utils_1 = require("./utils");
const smart_contracts_1 = require("@requestnetwork/smart-contracts");
const utils_2 = require("@requestnetwork/utils");
/**
 * Class representing a request.
 * Instances of this class can be accepted, paid, refunded, etc.
 * Use the member function `getData` to access the properties of the Request.
 *
 * Requests should be created with `RequestNetwork.createRequest()`.
 */
class Request {
    /**
     * Creates an instance of Request
     *
     * @param requestLogic Instance of the request-logic layer
     * @param requestId ID of the Request
     * @param paymentNetwork Instance of a payment network to manage the request
     * @param contentDataManager Instance of content data manager
     * @param requestLogicCreateResult return from the first request creation (optimization)
     * @param options options
     */
    constructor(requestId, requestLogic, currencyManager, options) {
        this.paymentNetwork = null;
        /**
         * true if the creation emitted an event 'error'
         */
        this.confirmationErrorOccurredAtCreation = false;
        /**
         * Data of the request (see request-logic)
         */
        this.requestData = null;
        /**
         * Pending data of the request (see request-logic)
         */
        this.pendingData = null;
        /**
         * Content data parsed from the extensions data
         */
        this.contentData = null;
        /**
         * Meta data of the request (e.g: where the data have been retrieved from)
         */
        this.requestMeta = null;
        /**
         * Balance and payments/refund events
         */
        this.balance = null;
        /**
         * if true, skip the payment detection
         */
        this.skipPaymentDetection = false;
        /**
         * if true, do not send blockchain confirmation events (on creation, approval, etc.)
         */
        this.disableEvents = false;
        this.requestLogic = requestLogic;
        this.requestId = requestId;
        this.contentDataExtension = (options === null || options === void 0 ? void 0 : options.contentDataExtension) || null;
        this.paymentNetwork = (options === null || options === void 0 ? void 0 : options.paymentNetwork) || null;
        this.emitter = new events_1.EventEmitter();
        this.skipPaymentDetection = (options === null || options === void 0 ? void 0 : options.skipPaymentDetection) || false;
        this.disableEvents = (options === null || options === void 0 ? void 0 : options.disableEvents) || false;
        this.currencyManager = currencyManager;
        if ((options === null || options === void 0 ? void 0 : options.requestLogicCreateResult) && !this.disableEvents) {
            const originalEmitter = options.requestLogicCreateResult;
            originalEmitter
                .on('confirmed', () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    this.emitter.emit('confirmed', yield this.refresh());
                }
                catch (error) {
                    originalEmitter.emit('error', error);
                }
            }))
                .on('error', (error) => {
                this.confirmationErrorOccurredAtCreation = true;
                this.emitter.emit('error', error);
            });
        }
    }
    /**
     * Listen the confirmation of the creation
     *
     * @param type only "confirmed" event for now
     * @param callback callback to call when confirmed event is risen
     * @returns this
     */
    on(event, listener) {
        this.emitter.on(event, listener);
        return this;
    }
    /**
     * Wait for the confirmation
     *
     * @returns the request data
     */
    waitForConfirmation() {
        return new Promise((resolve, reject) => {
            this.on('confirmed', resolve);
            this.on('error', reject);
        });
    }
    /**
     * Accepts a request
     *
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @param refundInformation Refund information to add (any because it is specific to the payment network used by the request)
     * @returns The updated request
     */
    accept(signerIdentity, refundInformation) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const extensionsData = [];
            if (refundInformation) {
                if (!this.paymentNetwork) {
                    throw new Error('Cannot add refund information without payment network');
                }
                extensionsData.push(this.paymentNetwork.createExtensionsDataForAddRefundInformation(refundInformation));
            }
            const parameters = {
                extensionsData,
                requestId: this.requestId,
            };
            const acceptResult = yield this.requestLogic.acceptRequest(parameters, signerIdentity, true);
            return this.handleRequestDataEvents(acceptResult);
        });
    }
    /**
     * Cancels a request
     *
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @param refundInformation refund information to add (any because it is specific to the payment network used by the request)
     * @returns The updated request
     */
    cancel(signerIdentity, refundInformation) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const extensionsData = [];
            if (refundInformation) {
                if (!this.paymentNetwork) {
                    throw new Error('Cannot add refund information without payment network');
                }
                extensionsData.push(this.paymentNetwork.createExtensionsDataForAddRefundInformation(refundInformation));
            }
            const parameters = {
                extensionsData,
                requestId: this.requestId,
            };
            const cancelResult = yield this.requestLogic.cancelRequest(parameters, signerIdentity, true);
            return this.handleRequestDataEvents(cancelResult);
        });
    }
    /**
     * Increases the expected amount of the request.
     *
     * @param deltaAmount Amount by which to increase the expected amount
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @param refundInformation Refund information to add (any because it is specific to the payment network used by the request)
     * @returns The updated request
     */
    increaseExpectedAmountRequest(deltaAmount, signerIdentity, refundInformation) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const extensionsData = [];
            if (refundInformation) {
                if (!this.paymentNetwork) {
                    throw new Error('Cannot add refund information without payment network');
                }
                extensionsData.push(this.paymentNetwork.createExtensionsDataForAddRefundInformation(refundInformation));
            }
            const parameters = {
                deltaAmount,
                extensionsData,
                requestId: this.requestId,
            };
            const increaseExpectedResult = yield this.requestLogic.increaseExpectedAmountRequest(parameters, signerIdentity, true);
            return this.handleRequestDataEvents(increaseExpectedResult);
        });
    }
    /**
     * Reduces the expected amount of the request. This can be called by the payee e.g. to apply discounts or special offers.
     *
     * @param deltaAmount Amount by which to reduce the expected amount
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @param paymentInformation Payment information to add (any because it is specific to the payment network used by the request)
     * @returns The updated request
     */
    reduceExpectedAmountRequest(deltaAmount, signerIdentity, paymentInformation) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const extensionsData = [];
            if (paymentInformation) {
                if (!this.paymentNetwork) {
                    throw new Error('Cannot add payment information without payment network');
                }
                extensionsData.push(this.paymentNetwork.createExtensionsDataForAddPaymentInformation(paymentInformation));
            }
            const parameters = {
                deltaAmount,
                extensionsData,
                requestId: this.requestId,
            };
            const reduceExpectedResult = yield this.requestLogic.reduceExpectedAmountRequest(parameters, signerIdentity, true);
            return this.handleRequestDataEvents(reduceExpectedResult);
        });
    }
    /**
     * Adds stakeholders to a request
     *
     * @param IEncryptionParameters encryptionParams list of addtional encryption parameters to encrypt the channel key with
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @param refundInformation refund information to add (any because it is specific to the payment network used by the request)
     * @returns The updated request
     */
    addStakeholders(encryptionParams, signerIdentity, refundInformation) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const extensionsData = [];
            if (refundInformation) {
                if (!this.paymentNetwork) {
                    throw new Error('Cannot add refund information without payment network');
                }
                extensionsData.push(this.paymentNetwork.createExtensionsDataForAddRefundInformation(refundInformation));
            }
            const parameters = {
                extensionsData,
                requestId: this.requestId,
            };
            const addStakeholdersResult = yield this.requestLogic.addStakeholders(parameters, signerIdentity, encryptionParams, true);
            return this.handleRequestDataEvents(addStakeholdersResult);
        });
    }
    /**
     * Adds payment information
     *
     * @param paymentInformation Payment information to add (any because it is specific to the payment network used by the request)
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @returns The updated request
     */
    addPaymentInformation(paymentInformation, signerIdentity) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const extensionsData = [];
            if (!this.paymentNetwork) {
                throw new Error('Cannot add payment information without payment network');
            }
            extensionsData.push(this.paymentNetwork.createExtensionsDataForAddPaymentInformation(paymentInformation));
            const parameters = {
                extensionsData,
                requestId: this.requestId,
            };
            const addExtensionResult = yield this.requestLogic.addExtensionsDataRequest(parameters, signerIdentity, true);
            return this.handleRequestDataEvents(addExtensionResult);
        });
    }
    /**
     * Adds refund information
     *
     * @param refundInformation Refund information to add (any because it is specific to the payment network used by the request)
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @returns The updated request
     */
    addRefundInformation(refundInformation, signerIdentity) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const extensionsData = [];
            if (!this.paymentNetwork) {
                throw new Error('Cannot add refund information without payment network');
            }
            extensionsData.push(this.paymentNetwork.createExtensionsDataForAddRefundInformation(refundInformation));
            const parameters = {
                extensionsData,
                requestId: this.requestId,
            };
            const addExtensionResult = yield this.requestLogic.addExtensionsDataRequest(parameters, signerIdentity, true);
            return this.handleRequestDataEvents(addExtensionResult);
        });
    }
    /**
     * Declare a payment is sent for the declarative payment network
     *
     * @param amount Amount sent
     * @param note Note from payer about the sent payment
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @returns The updated request
     */
    declareSentPayment(amount, note, signerIdentity) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const extensionsData = [];
            if (!this.paymentNetwork) {
                throw new Error('Cannot declare sent payment without payment network');
            }
            // We need to cast the object since IPaymentNetwork doesn't implement createExtensionsDataForDeclareSentPayment
            const declarativePaymentNetwork = this.paymentNetwork;
            if (!declarativePaymentNetwork.createExtensionsDataForDeclareSentPayment) {
                throw new Error('Cannot declare sent payment without declarative payment network');
            }
            extensionsData.push(declarativePaymentNetwork.createExtensionsDataForDeclareSentPayment({
                amount,
                note,
            }));
            const parameters = {
                extensionsData,
                requestId: this.requestId,
            };
            const addExtensionResult = yield this.requestLogic.addExtensionsDataRequest(parameters, signerIdentity, true);
            return this.handleRequestDataEvents(addExtensionResult);
        });
    }
    /**
     * Declare a refund is sent for the declarative payment network
     *
     * @param amount Amount sent
     * @param note Note from payee about the sent refund
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @returns The updated request
     */
    declareSentRefund(amount, note, signerIdentity) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const extensionsData = [];
            if (!this.paymentNetwork) {
                throw new Error('Cannot declare sent refund without payment network');
            }
            // We need to cast the object since IPaymentNetwork doesn't implement createExtensionsDataForDeclareSentRefund
            const declarativePaymentNetwork = this.paymentNetwork;
            if (!declarativePaymentNetwork.createExtensionsDataForDeclareSentRefund) {
                throw new Error('Cannot declare sent refund without declarative payment network');
            }
            extensionsData.push(declarativePaymentNetwork.createExtensionsDataForDeclareSentRefund({
                amount,
                note,
            }));
            const parameters = {
                extensionsData,
                requestId: this.requestId,
            };
            const addExtensionResult = yield this.requestLogic.addExtensionsDataRequest(parameters, signerIdentity, true);
            return this.handleRequestDataEvents(addExtensionResult);
        });
    }
    /**
     * Declare a payment is received for the declarative payment network
     *
     * @param amount Amount received
     * @param note Note from payee about the received payment
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @param txHash transaction hash
     * @param network network of the transaction
     * @returns The updated request
     */
    declareReceivedPayment(amount, note, signerIdentity, txHash, network) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const extensionsData = [];
            if (!this.paymentNetwork) {
                throw new Error('Cannot declare received payment without payment network');
            }
            // We need to cast the object since IPaymentNetwork doesn't implement createExtensionsDataForDeclareReceivedPayment
            const declarativePaymentNetwork = this.paymentNetwork;
            if (!declarativePaymentNetwork.createExtensionsDataForDeclareReceivedPayment) {
                throw new Error('Cannot declare received payment without declarative payment network');
            }
            extensionsData.push(declarativePaymentNetwork.createExtensionsDataForDeclareReceivedPayment({
                amount,
                note,
                txHash,
                network,
            }));
            const parameters = {
                extensionsData,
                requestId: this.requestId,
            };
            const addExtensionResult = yield this.requestLogic.addExtensionsDataRequest(parameters, signerIdentity, true);
            return this.handleRequestDataEvents(addExtensionResult);
        });
    }
    /**
     * Declare a refund is received for the declarative payment network
     *
     * @param amount Amount received
     * @param note Note from payer about the received refund
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @param txHash transaction hash
     * @param network network of the transaction
     * @returns The updated request
     */
    declareReceivedRefund(amount, note, signerIdentity, txHash, network) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const extensionsData = [];
            if (!this.paymentNetwork) {
                throw new Error('Cannot declare received refund without payment network');
            }
            // We need to cast the object since IPaymentNetwork doesn't implement createExtensionsDataForDeclareReceivedRefund
            const declarativePaymentNetwork = this.paymentNetwork;
            if (!declarativePaymentNetwork.createExtensionsDataForDeclareReceivedRefund) {
                throw new Error('Cannot declare received refund without declarative payment network');
            }
            extensionsData.push(declarativePaymentNetwork.createExtensionsDataForDeclareReceivedRefund({
                amount,
                note,
                txHash,
                network,
            }));
            const parameters = {
                extensionsData,
                requestId: this.requestId,
            };
            const addExtensionResult = yield this.requestLogic.addExtensionsDataRequest(parameters, signerIdentity, true);
            return this.handleRequestDataEvents(addExtensionResult);
        });
    }
    /**
     * Add a delegate for the declarative payment network
     *
     * @param delegate Identity of the delegate
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @returns The updated request
     */
    addDeclarativeDelegate(delegate, signerIdentity) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const extensionsData = [];
            if (!this.paymentNetwork) {
                throw new Error('Cannot declare delegate without payment network');
            }
            // We need to cast the object since IPaymentNetwork doesn't implement createExtensionsDataForDeclareReceivedRefund
            const declarativePaymentNetwork = this.paymentNetwork;
            if (!declarativePaymentNetwork.createExtensionsDataForAddDelegate) {
                throw new Error('Cannot declare delegate without declarative payment network');
            }
            extensionsData.push(declarativePaymentNetwork.createExtensionsDataForAddDelegate({
                delegate,
            }));
            const parameters = {
                extensionsData,
                requestId: this.requestId,
            };
            const addExtensionResult = yield this.requestLogic.addExtensionsDataRequest(parameters, signerIdentity, true);
            return this.handleRequestDataEvents(addExtensionResult);
        });
    }
    handleRequestDataEvents(eventEmitter) {
        // refresh the local request data
        const requestDataPromise = this.refresh();
        if (!this.disableEvents) {
            eventEmitter
                .on('confirmed', () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    const requestData = yield requestDataPromise;
                    requestData.emit('confirmed', yield this.refresh());
                }
                catch (error) {
                    eventEmitter.emit('error', error);
                }
            }))
                .on('error', (error) => {
                this.emitter.emit('error', error);
            });
        }
        return requestDataPromise;
    }
    /**
     * Gets the request data
     *
     * @returns The updated request data
     */
    getData() {
        if (this.confirmationErrorOccurredAtCreation) {
            throw Error('request confirmation failed');
        }
        let requestData = (0, utils_2.deepCopy)(this.requestData);
        let pending = (0, utils_2.deepCopy)(this.pendingData);
        if (!requestData) {
            requestData = pending;
            requestData.state = types_1.RequestLogicTypes.STATE.PENDING;
            pending = { state: this.pendingData.state };
        }
        const currency = this.currencyManager.fromStorageCurrency(requestData.currency);
        return Object.assign(new events_1.EventEmitter(), Object.assign(Object.assign({}, requestData), { balance: this.balance, contentData: this.contentData, currency: currency ? currency.id : 'unknown', currencyInfo: requestData.currency, meta: this.requestMeta, pending }));
    }
    getEscrowData(paymentReference, network) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const escrowContractAddress = smart_contracts_1.erc20EscrowToPayArtifact.getAddress(network);
            const escrowInfoRetriever = new payment_detection_1.EscrowERC20InfoRetriever(paymentReference, escrowContractAddress, 0, '', '', network);
            return yield escrowInfoRetriever.getEscrowRequestMapping();
        });
    }
    /**
     * Refresh the request data and balance from the network (check if new events happened - e.g: accept, payments etc..) and return these data
     *
     * @param requestAndMeta return from getRequestFromId to avoid asking twice
     * @returns Refreshed request data
     */
    refresh(requestAndMeta) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.confirmationErrorOccurredAtCreation) {
                throw Error('request confirmation failed');
            }
            if (!requestAndMeta) {
                requestAndMeta = yield this.requestLogic.getRequestFromId(this.requestId);
            }
            if (!requestAndMeta.result.request && !requestAndMeta.result.pending) {
                throw new Error(`No request found for the id: ${this.requestId} - ${utils_1.default.formatGetRequestFromIdError(requestAndMeta)}`);
            }
            if (this.contentDataExtension) {
                // TODO: PROT-1131 - add a pending content
                this.contentData = yield this.contentDataExtension.getContent(requestAndMeta.result.request || requestAndMeta.result.pending);
            }
            this.requestData = requestAndMeta.result.request;
            this.pendingData = requestAndMeta.result.pending;
            this.requestMeta = requestAndMeta.meta;
            if (!this.skipPaymentDetection) {
                // let's refresh the balance
                yield this.refreshBalance();
            }
            return this.getData();
        });
    }
    /**
     * Refresh only the balance of the request and return it
     *
     * @returns return the balance
     */
    refreshBalance() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // TODO: PROT-1131 - add a pending balance
            if (this.paymentNetwork && this.requestData) {
                this.balance = yield this.paymentNetwork.getBalance(this.requestData);
            }
            return this.balance;
        });
    }
    /**
     * Enables the payment detection
     */
    enablePaymentDetection() {
        this.skipPaymentDetection = false;
    }
    /**
     * Disables the payment detection
     */
    disablePaymentDetection() {
        this.skipPaymentDetection = true;
    }
}
exports.default = Request;
//# sourceMappingURL=request.js.map