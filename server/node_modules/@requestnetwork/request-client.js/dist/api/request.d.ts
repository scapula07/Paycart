/// <reference types="node" />
import { EventEmitter } from 'events';
import { CurrencyTypes, EncryptionTypes, IdentityTypes, PaymentTypes, RequestLogicTypes } from '@requestnetwork/types';
import { ICurrencyManager } from '@requestnetwork/currency';
import * as Types from '../types';
import ContentDataExtension from './content-data-extension';
/**
 * Class representing a request.
 * Instances of this class can be accepted, paid, refunded, etc.
 * Use the member function `getData` to access the properties of the Request.
 *
 * Requests should be created with `RequestNetwork.createRequest()`.
 */
export default class Request {
    /**
     * Unique ID of the request
     */
    readonly requestId: RequestLogicTypes.RequestId;
    private requestLogic;
    private paymentNetwork;
    private contentDataExtension;
    private emitter;
    /**
     * true if the creation emitted an event 'error'
     */
    private confirmationErrorOccurredAtCreation;
    /**
     * Data of the request (see request-logic)
     */
    private requestData;
    /**
     * Pending data of the request (see request-logic)
     */
    private pendingData;
    /**
     * Content data parsed from the extensions data
     */
    private contentData;
    /**
     * Meta data of the request (e.g: where the data have been retrieved from)
     */
    private requestMeta;
    /**
     * Balance and payments/refund events
     */
    private balance;
    /**
     * if true, skip the payment detection
     */
    private skipPaymentDetection;
    /**
     * if true, do not send blockchain confirmation events (on creation, approval, etc.)
     */
    private disableEvents;
    /**
     * A list of known tokens
     */
    private currencyManager;
    /**
     * Creates an instance of Request
     *
     * @param requestLogic Instance of the request-logic layer
     * @param requestId ID of the Request
     * @param paymentNetwork Instance of a payment network to manage the request
     * @param contentDataManager Instance of content data manager
     * @param requestLogicCreateResult return from the first request creation (optimization)
     * @param options options
     */
    constructor(requestId: RequestLogicTypes.RequestId, requestLogic: RequestLogicTypes.IRequestLogic, currencyManager: ICurrencyManager, options?: {
        paymentNetwork?: PaymentTypes.IPaymentNetwork | null;
        contentDataExtension?: ContentDataExtension | null;
        requestLogicCreateResult?: RequestLogicTypes.IReturnCreateRequest;
        skipPaymentDetection?: boolean;
        disableEvents?: boolean;
    });
    /**
     * Listen the confirmation of the creation
     *
     * @param type only "confirmed" event for now
     * @param callback callback to call when confirmed event is risen
     * @returns this
     */
    on<K extends keyof Types.IRequestEvents>(event: K, listener: Types.IRequestEvents[K]): this;
    /**
     * Wait for the confirmation
     *
     * @returns the request data
     */
    waitForConfirmation(): Promise<Types.IRequestDataWithEvents>;
    /**
     * Accepts a request
     *
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @param refundInformation Refund information to add (any because it is specific to the payment network used by the request)
     * @returns The updated request
     */
    accept(signerIdentity: IdentityTypes.IIdentity, refundInformation?: any): Promise<Types.IRequestDataWithEvents>;
    /**
     * Cancels a request
     *
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @param refundInformation refund information to add (any because it is specific to the payment network used by the request)
     * @returns The updated request
     */
    cancel(signerIdentity: IdentityTypes.IIdentity, refundInformation?: any): Promise<Types.IRequestDataWithEvents>;
    /**
     * Increases the expected amount of the request.
     *
     * @param deltaAmount Amount by which to increase the expected amount
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @param refundInformation Refund information to add (any because it is specific to the payment network used by the request)
     * @returns The updated request
     */
    increaseExpectedAmountRequest(deltaAmount: RequestLogicTypes.Amount, signerIdentity: IdentityTypes.IIdentity, refundInformation?: any): Promise<Types.IRequestDataWithEvents>;
    /**
     * Reduces the expected amount of the request. This can be called by the payee e.g. to apply discounts or special offers.
     *
     * @param deltaAmount Amount by which to reduce the expected amount
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @param paymentInformation Payment information to add (any because it is specific to the payment network used by the request)
     * @returns The updated request
     */
    reduceExpectedAmountRequest(deltaAmount: RequestLogicTypes.Amount, signerIdentity: IdentityTypes.IIdentity, paymentInformation?: any): Promise<Types.IRequestDataWithEvents>;
    /**
     * Adds stakeholders to a request
     *
     * @param IEncryptionParameters encryptionParams list of addtional encryption parameters to encrypt the channel key with
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @param refundInformation refund information to add (any because it is specific to the payment network used by the request)
     * @returns The updated request
     */
    addStakeholders(encryptionParams: EncryptionTypes.IEncryptionParameters[], signerIdentity: IdentityTypes.IIdentity, refundInformation?: any): Promise<Types.IRequestDataWithEvents>;
    /**
     * Adds payment information
     *
     * @param paymentInformation Payment information to add (any because it is specific to the payment network used by the request)
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @returns The updated request
     */
    addPaymentInformation(paymentInformation: any, signerIdentity: IdentityTypes.IIdentity): Promise<Types.IRequestDataWithEvents>;
    /**
     * Adds refund information
     *
     * @param refundInformation Refund information to add (any because it is specific to the payment network used by the request)
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @returns The updated request
     */
    addRefundInformation(refundInformation: any, signerIdentity: IdentityTypes.IIdentity): Promise<Types.IRequestDataWithEvents>;
    /**
     * Declare a payment is sent for the declarative payment network
     *
     * @param amount Amount sent
     * @param note Note from payer about the sent payment
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @returns The updated request
     */
    declareSentPayment(amount: RequestLogicTypes.Amount, note: string, signerIdentity: IdentityTypes.IIdentity): Promise<Types.IRequestDataWithEvents>;
    /**
     * Declare a refund is sent for the declarative payment network
     *
     * @param amount Amount sent
     * @param note Note from payee about the sent refund
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @returns The updated request
     */
    declareSentRefund(amount: RequestLogicTypes.Amount, note: string, signerIdentity: IdentityTypes.IIdentity): Promise<Types.IRequestDataWithEvents>;
    /**
     * Declare a payment is received for the declarative payment network
     *
     * @param amount Amount received
     * @param note Note from payee about the received payment
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @param txHash transaction hash
     * @param network network of the transaction
     * @returns The updated request
     */
    declareReceivedPayment(amount: RequestLogicTypes.Amount, note: string, signerIdentity: IdentityTypes.IIdentity, txHash?: string, network?: string): Promise<Types.IRequestDataWithEvents>;
    /**
     * Declare a refund is received for the declarative payment network
     *
     * @param amount Amount received
     * @param note Note from payer about the received refund
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @param txHash transaction hash
     * @param network network of the transaction
     * @returns The updated request
     */
    declareReceivedRefund(amount: RequestLogicTypes.Amount, note: string, signerIdentity: IdentityTypes.IIdentity, txHash?: string, network?: string): Promise<Types.IRequestDataWithEvents>;
    /**
     * Add a delegate for the declarative payment network
     *
     * @param delegate Identity of the delegate
     * @param signerIdentity Identity of the signer. The identity type must be supported by the signature provider.
     * @returns The updated request
     */
    addDeclarativeDelegate(delegate: IdentityTypes.IIdentity, signerIdentity: IdentityTypes.IIdentity): Promise<Types.IRequestDataWithEvents>;
    protected handleRequestDataEvents(eventEmitter: EventEmitter): Promise<Types.IRequestDataWithEvents>;
    /**
     * Gets the request data
     *
     * @returns The updated request data
     */
    getData(): Types.IRequestDataWithEvents;
    getEscrowData(paymentReference: string, network: CurrencyTypes.EvmChainName): Promise<PaymentTypes.EscrowChainData>;
    /**
     * Refresh the request data and balance from the network (check if new events happened - e.g: accept, payments etc..) and return these data
     *
     * @param requestAndMeta return from getRequestFromId to avoid asking twice
     * @returns Refreshed request data
     */
    refresh(requestAndMeta?: RequestLogicTypes.IReturnGetRequestFromId): Promise<Types.IRequestDataWithEvents>;
    /**
     * Refresh only the balance of the request and return it
     *
     * @returns return the balance
     */
    refreshBalance(): Promise<Types.Payment.IBalanceWithEvents<any> | null>;
    /**
     * Enables the payment detection
     */
    enablePaymentDetection(): void;
    /**
     * Disables the payment detection
     */
    disablePaymentDetection(): void;
}
//# sourceMappingURL=request.d.ts.map