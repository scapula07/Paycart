"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const advanced_logic_1 = require("@requestnetwork/advanced-logic");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const request_logic_1 = require("@requestnetwork/request-logic");
const transaction_manager_1 = require("@requestnetwork/transaction-manager");
const utils_1 = require("@requestnetwork/utils");
const currency_1 = require("@requestnetwork/currency");
const content_data_extension_1 = require("./content-data-extension");
const request_1 = require("./request");
const utils_2 = require("./utils");
/**
 * Entry point of the request-client.js library. Create requests, get requests, manipulate requests.
 */
class RequestNetwork {
    /**
     * @param dataAccess instance of data-access layer
     * @param signatureProvider module in charge of the signatures
     * @param decryptionProvider module in charge of the decryption
     * @param paymentOptions options for payment detection
     */
    constructor({ dataAccess, signatureProvider, decryptionProvider, currencyManager, paymentOptions, }) {
        this.supportedIdentities = utils_1.supportedIdentities;
        this.currencyManager = currencyManager || currency_1.CurrencyManager.getDefault();
        this.advancedLogic = new advanced_logic_1.AdvancedLogic(this.currencyManager);
        this.transaction = new transaction_manager_1.TransactionManager(dataAccess, decryptionProvider);
        this.requestLogic = new request_logic_1.RequestLogic(this.transaction, signatureProvider, this.advancedLogic);
        this.contentData = new content_data_extension_1.default(this.advancedLogic);
        this.paymentNetworkFactory = new payment_detection_1.PaymentNetworkFactory(this.advancedLogic, this.currencyManager, paymentOptions);
    }
    /**
     * Creates a request.
     *
     * @param requestParameters Parameters to create a request
     * @returns The created request
     */
    createRequest(parameters, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { requestParameters, topics, paymentNetwork } = yield this.prepareRequestParameters(parameters);
            const requestLogicCreateResult = yield this.requestLogic.createRequest(requestParameters, parameters.signer, topics);
            // create the request object
            const request = new request_1.default(requestLogicCreateResult.result.requestId, this.requestLogic, this.currencyManager, {
                contentDataExtension: this.contentData,
                paymentNetwork,
                requestLogicCreateResult,
                skipPaymentDetection: parameters.disablePaymentDetection,
                disableEvents: parameters.disableEvents,
            });
            if (!(options === null || options === void 0 ? void 0 : options.skipRefresh)) {
                // refresh the local request data
                yield request.refresh();
            }
            return request;
        });
    }
    /**
     * Creates an encrypted request.
     *
     * @param parameters Parameters to create a request
     * @param encryptionParams Request encryption parameters
     * @returns The created encrypted request
     */
    _createEncryptedRequest(parameters, encryptionParams, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { requestParameters, topics, paymentNetwork } = yield this.prepareRequestParameters(parameters);
            const requestLogicCreateResult = yield this.requestLogic.createEncryptedRequest(requestParameters, parameters.signer, encryptionParams, topics);
            // create the request object
            const request = new request_1.default(requestLogicCreateResult.result.requestId, this.requestLogic, this.currencyManager, {
                contentDataExtension: this.contentData,
                paymentNetwork,
                requestLogicCreateResult,
                skipPaymentDetection: parameters.disablePaymentDetection,
                disableEvents: parameters.disableEvents,
            });
            if (!(options === null || options === void 0 ? void 0 : options.skipRefresh)) {
                // refresh the local request data
                yield request.refresh();
            }
            return request;
        });
    }
    /**
     * Gets the ID of a request without creating it.
     *
     * @param requestParameters Parameters to create a request
     * @returns The requestId
     */
    computeRequestId(parameters) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { requestParameters } = yield this.prepareRequestParameters(parameters);
            return this.requestLogic.computeRequestId(requestParameters, parameters.signer);
        });
    }
    /**
     * Create a Request instance from an existing Request's ID
     *
     * @param requestId The ID of the Request
     * @param options options
     * @returns the Request
     */
    fromRequestId(requestId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const requestAndMeta = yield this.requestLogic.getRequestFromId(requestId);
            // if no request found, throw a human readable message:
            if (!requestAndMeta.result.request && !requestAndMeta.result.pending) {
                throw new Error(utils_2.default.formatGetRequestFromIdError(requestAndMeta));
            }
            // get the request state. If the creation is not confirmed yet, get the pending state (useful for the payment network)
            const requestState = requestAndMeta.result.request
                ? requestAndMeta.result.request
                : requestAndMeta.result.pending;
            const paymentNetwork = this.paymentNetworkFactory.getPaymentNetworkFromRequest(requestState);
            // create the request object
            const request = new request_1.default(requestId, this.requestLogic, this.currencyManager, {
                contentDataExtension: this.contentData,
                paymentNetwork,
                skipPaymentDetection: options === null || options === void 0 ? void 0 : options.disablePaymentDetection,
                disableEvents: options === null || options === void 0 ? void 0 : options.disableEvents,
            });
            // refresh the local request data
            yield request.refresh(requestAndMeta);
            return request;
        });
    }
    /**
     * Create an array of request instances from an identity
     *
     * @param updatedBetween filter the requests with time boundaries
     * @param options options
     * @returns the Requests
     */
    fromIdentity(identity, updatedBetween, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.supportedIdentities.includes(identity.type)) {
                throw new Error(`${identity.type} is not supported`);
            }
            return this.fromTopic(identity, updatedBetween, options);
        });
    }
    /**
     * Create an array of request instances from multiple identities
     *
     * @param updatedBetween filter the requests with time boundaries
     * @param disablePaymentDetection if true, skip the payment detection
     * @returns the requests
     */
    fromMultipleIdentities(identities, updatedBetween, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const identityNotSupported = identities.find((identity) => !this.supportedIdentities.includes(identity.type));
            if (identityNotSupported) {
                throw new Error(`${identityNotSupported.type} is not supported`);
            }
            return this.fromMultipleTopics(identities, updatedBetween, options);
        });
    }
    /**
     * Create an array of request instances from a topic
     *
     * @param updatedBetween filter the requests with time boundaries
     * @param options options
     * @returns the Requests
     */
    fromTopic(topic, updatedBetween, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Gets all the requests indexed by the value of the identity
            const requestsAndMeta = yield this.requestLogic.getRequestsByTopic(topic, updatedBetween);
            // From the requests of the request-logic layer creates the request objects and gets the payment networks
            const requestPromises = requestsAndMeta.result.requests.map((requestFromLogic) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                // get the request state. If the creation is not confirmed yet, get the pending state (useful for the payment network)
                const requestState = requestFromLogic.request
                    ? requestFromLogic.request
                    : requestFromLogic.pending;
                const paymentNetwork = this.paymentNetworkFactory.getPaymentNetworkFromRequest(requestState);
                // create the request object
                const request = new request_1.default(requestState.requestId, this.requestLogic, this.currencyManager, {
                    contentDataExtension: this.contentData,
                    paymentNetwork,
                    skipPaymentDetection: options === null || options === void 0 ? void 0 : options.disablePaymentDetection,
                    disableEvents: options === null || options === void 0 ? void 0 : options.disableEvents,
                });
                // refresh the local request data
                yield request.refresh();
                return request;
            }));
            return Promise.all(requestPromises);
        });
    }
    /**
     * Create an array of request instances from a multiple topics
     *
     * @param updatedBetween filter the requests with time boundaries
     * @param options options
     * @returns the Requests
     */
    fromMultipleTopics(topics, updatedBetween, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Gets all the requests indexed by the value of the identity
            const requestsAndMeta = yield this.requestLogic.getRequestsByMultipleTopics(topics, updatedBetween);
            // From the requests of the request-logic layer creates the request objects and gets the payment networks
            const requestPromises = requestsAndMeta.result.requests.map((requestFromLogic) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                // get the request state. If the creation is not confirmed yet, get the pending state (useful for the payment network)
                const requestState = requestFromLogic.request
                    ? requestFromLogic.request
                    : requestFromLogic.pending;
                const paymentNetwork = this.paymentNetworkFactory.getPaymentNetworkFromRequest(requestState);
                // create the request object
                const request = new request_1.default(requestState.requestId, this.requestLogic, this.currencyManager, {
                    contentDataExtension: this.contentData,
                    paymentNetwork,
                    skipPaymentDetection: options === null || options === void 0 ? void 0 : options.disablePaymentDetection,
                    disableEvents: options === null || options === void 0 ? void 0 : options.disableEvents,
                });
                // refresh the local request data
                yield request.refresh();
                return request;
            }));
            return Promise.all(requestPromises);
        });
    }
    /*
     * If request currency is a string, convert it to currency object
     */
    getCurrency(input) {
        if (typeof input === 'string') {
            const currency = this.currencyManager.from(input);
            if (!currency) {
                throw new currency_1.UnsupportedCurrencyError(input);
            }
            return currency_1.CurrencyManager.toStorageCurrency(currency);
        }
        return input;
    }
    /**
     * A helper to validate and prepare the parameters of a request.
     * @param parameters Parameters to create a request
     * @returns the parameters, ready for request creation, the topics, and the paymentNetwork
     */
    prepareRequestParameters(parameters) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const currency = this.getCurrency(parameters.requestInfo.currency);
            const requestParameters = Object.assign(Object.assign({}, parameters.requestInfo), { currency });
            const contentData = parameters.contentData;
            const topics = ((_a = parameters.topics) === null || _a === void 0 ? void 0 : _a.slice()) || [];
            // Check that currency is valid
            if (!currency_1.CurrencyManager.validateCurrency(currency)) {
                throw new Error('The currency is not valid');
            }
            // avoid mutation of the parameters
            const copiedRequestParameters = (0, utils_1.deepCopy)(requestParameters);
            copiedRequestParameters.extensionsData = [];
            const detectionChain = ((_b = parameters === null || parameters === void 0 ? void 0 : parameters.paymentNetwork) === null || _b === void 0 ? void 0 : _b.parameters) && 'network' in parameters.paymentNetwork.parameters
                ? (_c = parameters.paymentNetwork.parameters.network) !== null && _c !== void 0 ? _c : requestParameters.currency.network
                : requestParameters.currency.network;
            const paymentNetwork = parameters.paymentNetwork
                ? this.paymentNetworkFactory.createPaymentNetwork(parameters.paymentNetwork.id, requestParameters.currency.type, detectionChain)
                : null;
            if (paymentNetwork) {
                // create the extensions data for the payment network
                copiedRequestParameters.extensionsData.push(yield paymentNetwork.createExtensionsDataForCreation((_d = parameters.paymentNetwork) === null || _d === void 0 ? void 0 : _d.parameters));
            }
            if (contentData) {
                // create the extensions data for the content data
                copiedRequestParameters.extensionsData.push(this.contentData.createExtensionsDataForCreation(contentData));
            }
            // add identities as topics
            if (copiedRequestParameters.payee) {
                topics.push(copiedRequestParameters.payee);
            }
            if (copiedRequestParameters.payer) {
                topics.push(copiedRequestParameters.payer);
            }
            if (requestParameters.extensionsData) {
                copiedRequestParameters.extensionsData.push(...requestParameters.extensionsData);
            }
            return { requestParameters: copiedRequestParameters, topics, paymentNetwork };
        });
    }
}
exports.default = RequestNetwork;
//# sourceMappingURL=request-network.js.map