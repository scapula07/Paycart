import { PaymentNetworkFactory, PaymentNetworkOptions } from '@requestnetwork/payment-detection';
import { DataAccessTypes, DecryptionProviderTypes, EncryptionTypes, IdentityTypes, RequestLogicTypes, SignatureProviderTypes } from '@requestnetwork/types';
import { ICurrencyManager } from '@requestnetwork/currency';
import * as Types from '../types';
import Request from './request';
/**
 * Entry point of the request-client.js library. Create requests, get requests, manipulate requests.
 */
export default class RequestNetwork {
    paymentNetworkFactory: PaymentNetworkFactory;
    supportedIdentities: IdentityTypes.TYPE[];
    private requestLogic;
    private transaction;
    private advancedLogic;
    private contentData;
    private currencyManager;
    /**
     * @param dataAccess instance of data-access layer
     * @param signatureProvider module in charge of the signatures
     * @param decryptionProvider module in charge of the decryption
     * @param paymentOptions options for payment detection
     */
    constructor({ dataAccess, signatureProvider, decryptionProvider, currencyManager, paymentOptions, }: {
        dataAccess: DataAccessTypes.IDataAccess;
        signatureProvider?: SignatureProviderTypes.ISignatureProvider;
        decryptionProvider?: DecryptionProviderTypes.IDecryptionProvider;
        currencyManager?: ICurrencyManager;
        paymentOptions?: Partial<PaymentNetworkOptions>;
    });
    /**
     * Creates a request.
     *
     * @param requestParameters Parameters to create a request
     * @returns The created request
     */
    createRequest(parameters: Types.ICreateRequestParameters, options?: Types.ICreateRequestOptions): Promise<Request>;
    /**
     * Creates an encrypted request.
     *
     * @param parameters Parameters to create a request
     * @param encryptionParams Request encryption parameters
     * @returns The created encrypted request
     */
    _createEncryptedRequest(parameters: Types.ICreateRequestParameters, encryptionParams: EncryptionTypes.IEncryptionParameters[], options?: Types.ICreateRequestOptions): Promise<Request>;
    /**
     * Gets the ID of a request without creating it.
     *
     * @param requestParameters Parameters to create a request
     * @returns The requestId
     */
    computeRequestId(parameters: Types.ICreateRequestParameters): Promise<RequestLogicTypes.RequestId>;
    /**
     * Create a Request instance from an existing Request's ID
     *
     * @param requestId The ID of the Request
     * @param options options
     * @returns the Request
     */
    fromRequestId(requestId: RequestLogicTypes.RequestId, options?: {
        disablePaymentDetection?: boolean;
        disableEvents?: boolean;
    }): Promise<Request>;
    /**
     * Create an array of request instances from an identity
     *
     * @param updatedBetween filter the requests with time boundaries
     * @param options options
     * @returns the Requests
     */
    fromIdentity(identity: IdentityTypes.IIdentity, updatedBetween?: Types.ITimestampBoundaries, options?: {
        disablePaymentDetection?: boolean;
        disableEvents?: boolean;
    }): Promise<Request[]>;
    /**
     * Create an array of request instances from multiple identities
     *
     * @param updatedBetween filter the requests with time boundaries
     * @param disablePaymentDetection if true, skip the payment detection
     * @returns the requests
     */
    fromMultipleIdentities(identities: IdentityTypes.IIdentity[], updatedBetween?: Types.ITimestampBoundaries, options?: {
        disablePaymentDetection?: boolean;
        disableEvents?: boolean;
    }): Promise<Request[]>;
    /**
     * Create an array of request instances from a topic
     *
     * @param updatedBetween filter the requests with time boundaries
     * @param options options
     * @returns the Requests
     */
    fromTopic(topic: any, updatedBetween?: Types.ITimestampBoundaries, options?: {
        disablePaymentDetection?: boolean;
        disableEvents?: boolean;
    }): Promise<Request[]>;
    /**
     * Create an array of request instances from a multiple topics
     *
     * @param updatedBetween filter the requests with time boundaries
     * @param options options
     * @returns the Requests
     */
    fromMultipleTopics(topics: any[], updatedBetween?: Types.ITimestampBoundaries, options?: {
        disablePaymentDetection?: boolean;
        disableEvents?: boolean;
    }): Promise<Request[]>;
    private getCurrency;
    /**
     * A helper to validate and prepare the parameters of a request.
     * @param parameters Parameters to create a request
     * @returns the parameters, ready for request creation, the topics, and the paymentNetwork
     */
    private prepareRequestParameters;
}
//# sourceMappingURL=request-network.d.ts.map