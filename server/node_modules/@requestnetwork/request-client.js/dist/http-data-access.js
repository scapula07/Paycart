"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const axios_1 = require("axios");
const events_1 = require("events");
const http_config_defaults_1 = require("./http-config-defaults");
const utils_1 = require("@requestnetwork/utils");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const packageJson = require('../package.json');
/**
 * Exposes a Data-Access module over HTTP
 */
class HttpDataAccess {
    /**
     * Creates an instance of HttpDataAccess.
     * @param httpConfig @see ClientTypes.IHttpDataAccessConfig for available options.
     * @param nodeConnectionConfig Configuration options to connect to the node. Follows Axios configuration format.
     */
    constructor({ httpConfig, nodeConnectionConfig, } = {
        httpConfig: {},
        nodeConnectionConfig: {},
    }) {
        // Get Request Client version to set it in the header
        const requestClientVersion = packageJson.version;
        this.httpConfig = Object.assign(Object.assign({}, http_config_defaults_1.default), httpConfig);
        this.axiosConfig = Object.assign({ baseURL: 'http://localhost:3000', headers: {
                [this.httpConfig.requestClientVersionHeader]: requestClientVersion,
            } }, nodeConnectionConfig);
    }
    /**
     * Initialize the module. Does nothing, exists only to implement IDataAccess
     *
     * @returns nothing
     */
    initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // no-op, nothing to do
            return;
        });
    }
    /**
     * Closes the module. Does nothing, exists only to implement IDataAccess
     *
     * @returns nothing
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // no-op, nothing to do
            return;
        });
    }
    /**
     * Persists a new transaction on a node through HTTP.
     *
     * @param transactionData The transaction data
     * @param topics The topics used to index the transaction
     */
    persistTransaction(transactionData, channelId, topics) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // We don't retry this request since it may fail because of a slow Storage
            // For example, if the Ethereum network is slow and we retry the request three times
            // three data will be persisted at the end
            const { data } = yield axios_1.default.post('/persistTransaction', {
                channelId,
                topics,
                transactionData,
            }, this.axiosConfig);
            const transactionHash = (0, utils_1.normalizeKeccak256Hash)(transactionData).value;
            // Create the return result with EventEmitter
            const result = Object.assign(new events_1.EventEmitter(), data);
            // Try to get the confirmation
            new Promise((r) => setTimeout(r, this.httpConfig.getConfirmationDeferDelay))
                .then(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const confirmedData = yield this.fetchAndRetry('/getConfirmedTransaction', {
                    transactionHash,
                }, {
                    maxRetries: this.httpConfig.getConfirmationMaxRetry,
                    retryDelay: this.httpConfig.getConfirmationRetryDelay,
                    exponentialBackoffDelay: this.httpConfig.getConfirmationExponentialBackoffDelay,
                    maxExponentialBackoffDelay: this.httpConfig.getConfirmationMaxExponentialBackoffDelay,
                });
                // when found, emit the event 'confirmed'
                result.emit('confirmed', confirmedData);
            }))
                .catch((e) => {
                let error = e;
                if (e.response.status === 404) {
                    error = new Error(`Transaction confirmation not receive after ${this.httpConfig.getConfirmationMaxRetry} retries`);
                }
                result.emit('error', error);
            });
            return result;
        });
    }
    /**
     * Gets the transactions for a channel from the node through HTTP.
     *
     * @param channelId The channel id to search for
     * @param timestampBoundaries filter timestamp boundaries
     */
    getTransactionsByChannelId(channelId, timestampBoundaries) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.fetchAndRetry('/getTransactionsByChannelId', { channelId, timestampBoundaries });
        });
    }
    /**
     * Gets all the transactions of channel indexed by topic from the node through HTTP.
     *
     * @param topic topic to search for
     * @param updatedBetween filter timestamp boundaries
     */
    getChannelsByTopic(topic, updatedBetween) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.fetchAndRetry('/getChannelsByTopic', { topic, updatedBetween });
        });
    }
    /**
     * Gets all the transactions of channel indexed by multiple topics from the node through HTTP.
     *
     * @param topics topics to search for
     * @param updatedBetween filter timestamp boundaries
     */
    getChannelsByMultipleTopics(topics, updatedBetween) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.fetchAndRetry('/getChannelsByMultipleTopics', { topics, updatedBetween });
        });
    }
    /**
     * Gets information from the node (version, files etc...)
     *
     * @param detailed if true get the list of files hashes
     */
    _getStatus(detailed) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.fetchAndRetry('/information', { detailed });
        });
    }
    /**
     * Sends an HTTP GET request to the node and retries until it succeeds.
     * Throws when the retry count reaches a maximum.
     *
     * @param url HTTP GET request url
     * @param params HTTP GET request parameters
     * @param retryConfig Maximum retry count, delay between retries, exponential backoff delay, and maximum exponential backoff delay
     */
    fetchAndRetry(url, params, retryConfig = {}) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            retryConfig.maxRetries = (_a = retryConfig.maxRetries) !== null && _a !== void 0 ? _a : this.httpConfig.httpRequestMaxRetry;
            retryConfig.retryDelay = (_b = retryConfig.retryDelay) !== null && _b !== void 0 ? _b : this.httpConfig.httpRequestRetryDelay;
            retryConfig.exponentialBackoffDelay =
                (_c = retryConfig.exponentialBackoffDelay) !== null && _c !== void 0 ? _c : this.httpConfig.httpRequestExponentialBackoffDelay;
            retryConfig.maxExponentialBackoffDelay =
                (_d = retryConfig.maxExponentialBackoffDelay) !== null && _d !== void 0 ? _d : this.httpConfig.httpRequestMaxExponentialBackoffDelay;
            const { data } = yield (0, utils_1.retry)(() => tslib_1.__awaiter(this, void 0, void 0, function* () { return axios_1.default.get(url, Object.assign(Object.assign({}, this.axiosConfig), { params })); }), retryConfig)();
            return data;
        });
    }
}
exports.default = HttpDataAccess;
//# sourceMappingURL=http-data-access.js.map