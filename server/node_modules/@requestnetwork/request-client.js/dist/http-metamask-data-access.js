"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const data_access_1 = require("@requestnetwork/data-access");
const smart_contracts_1 = require("@requestnetwork/smart-contracts");
const types_1 = require("@requestnetwork/types");
const axios_1 = require("axios");
const ethers_1 = require("ethers");
const events_1 = require("events");
const http_data_access_1 = require("./http-data-access");
const utils_1 = require("@requestnetwork/utils");
/**
 * Exposes a Data-Access module over HTTP
 */
class HttpMetaMaskDataAccess extends http_data_access_1.default {
    /**
     * Creates an instance of HttpDataAccess.
     * @param httpConfig Http config that will be used by the underlying http-data-access. @see ClientTypes.IHttpDataAccessConfig
     * @param nodeConnectionConfig Configuration options to connect to the node. Follows Axios configuration format.
     */
    constructor({ httpConfig, nodeConnectionConfig, web3, ethereumProviderUrl, } = {
        httpConfig: {},
        nodeConnectionConfig: {},
    }) {
        super({ httpConfig, nodeConnectionConfig });
        /**
         * Cache block persisted directly (in case the node did not have the time to retrieve it)
         * (public for easier testing)
         */
        this.cache = {};
        this.networkName = 'private';
        ethereumProviderUrl = ethereumProviderUrl ? ethereumProviderUrl : 'http://localhost:8545';
        // Creates a local or default provider
        this.provider = web3
            ? new ethers_1.ethers.providers.Web3Provider(web3)
            : new ethers_1.ethers.providers.JsonRpcProvider({ url: ethereumProviderUrl });
    }
    /**
     * Initialize the module. Does nothing, exists only to implement IDataAccess
     *
     * @returns nothing
     */
    initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // no-op, nothing to do
            return;
        });
    }
    /**
     * Persists a new transaction using the node only for IPFS but persisting on ethereum through local provider
     *
     * @param transactionData The transaction data
     * @param topics The topics used to index the transaction
     */
    persistTransaction(transactionData, channelId, topics) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.submitterContract) {
                const network = yield this.provider.getNetwork();
                this.networkName =
                    network.chainId === 1 ? 'mainnet' : network.chainId === 4 ? 'rinkeby' : 'private';
                this.submitterContract = new ethers_1.ethers.Contract(smart_contracts_1.requestHashSubmitterArtifact.getAddress(this.networkName), smart_contracts_1.requestHashSubmitterArtifact.getContractAbi(), this.provider.getSigner());
            }
            // We don't use the node to persist the transaction, but we will Do it ourselves
            // create a block and add the transaction in it
            const block = data_access_1.Block.pushTransaction(data_access_1.Block.createEmptyBlock(), transactionData, channelId, topics);
            // store the block on ipfs and get the the ipfs hash and size
            const { data: { ipfsHash, ipfsSize }, } = yield axios_1.default.post('/ipfsAdd', { data: block }, this.axiosConfig);
            // get the fee required to submit the hash
            const fee = yield this.submitterContract.getFeesAmount(ipfsSize);
            // submit the hash to ethereum
            const tx = yield this.submitterContract.submitHash(ipfsHash, 
            /* eslint-disable no-magic-numbers */
            ethers_1.ethers.utils.hexZeroPad(ethers_1.ethers.utils.hexlify(ipfsSize), 32), { value: fee });
            const ethBlock = yield this.provider.getBlock(tx.blockNumber);
            // create the storage meta from the transaction receipt
            const storageMeta = {
                blockConfirmation: tx.confirmations,
                blockNumber: tx.blockNumber,
                blockTimestamp: ethBlock.timestamp,
                fee,
                networkName: this.networkName,
                smartContractAddress: tx.to,
                transactionHash: tx.hash,
            };
            // Add the block to the cache
            if (!this.cache[channelId]) {
                this.cache[channelId] = {};
            }
            this.cache[channelId][ipfsHash] = { block, storageMeta };
            const eventEmitter = new events_1.EventEmitter();
            const result = {
                meta: {
                    storageMeta: {
                        ethereum: storageMeta,
                        ipfs: { size: ipfsSize },
                        state: types_1.StorageTypes.ContentState.PENDING,
                        timestamp: storageMeta.blockTimestamp,
                    },
                    topics: topics || [],
                    transactionStorageLocation: ipfsHash,
                },
                result: {},
            };
            // When the ethereum transaction is mined, emit an event 'confirmed'
            tx.wait().then((txConfirmed) => {
                // create the storage meta from the transaction receipt
                const storageMetaConfirmed = {
                    blockConfirmation: txConfirmed.confirmations,
                    blockNumber: txConfirmed.blockNumber,
                    blockTimestamp: ethBlock.timestamp,
                    fee,
                    networkName: this.networkName,
                    smartContractAddress: txConfirmed.to,
                    transactionHash: txConfirmed.hash,
                };
                // emit the event to tell the request transaction is confirmed
                eventEmitter.emit('confirmed', {
                    meta: {
                        storageMeta: storageMetaConfirmed,
                        topics: topics || [],
                        transactionStorageLocation: ipfsHash,
                    },
                    result: {},
                });
            });
            return Object.assign(eventEmitter, result);
        });
    }
    /**
     * Gets the transactions for a channel from the node through HTTP.
     *
     * @param channelId The channel id to search for
     * @param timestampBoundaries filter timestamp boundaries
     */
    getTransactionsByChannelId(channelId, timestampBoundaries) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { data } = yield (0, utils_1.retry)(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                return axios_1.default.get('/getTransactionsByChannelId', Object.assign(this.axiosConfig, {
                    params: { channelId, timestampBoundaries },
                }));
            }), {
                maxRetries: this.httpConfig.httpRequestMaxRetry,
                retryDelay: this.httpConfig.httpRequestRetryDelay,
            })();
            // get the transactions from the cache
            const transactionsCached = this.getCachedTransactionsAndCleanCache(channelId, data.meta.transactionsStorageLocation, timestampBoundaries);
            // merge cache and data from the node
            return {
                meta: {
                    storageMeta: data.meta.storageMeta.concat(transactionsCached.meta.storageMeta),
                    transactionsStorageLocation: data.meta.transactionsStorageLocation.concat(transactionsCached.meta.transactionsStorageLocation),
                },
                result: {
                    transactions: data.result.transactions.concat(transactionsCached.result.transactions),
                },
            };
        });
    }
    /**
     * Gets the cached transactions and remove the ones that have been retrieved from the node
     * (public for easier testing)
     *
     * @param channelId The channel id to search for
     * @param storageLocationFromNode location retrieved from the node
     * @param timestampBoundaries filter timestamp boundaries
     */
    getCachedTransactionsAndCleanCache(channelId, storageLocationFromNode, timestampBoundaries) {
        // Remove cache found by the node
        for (const location of storageLocationFromNode) {
            this.cache[channelId][location] = null;
        }
        // Create a IReturnGetTransactions object to be merged later with the one from the node
        return Object.keys(this.cache[channelId] || []).reduce((accumulator, location) => {
            var _a;
            const cache = this.cache[channelId][location];
            // For each cached block for the channel, we return the transaction if they are in the time boundaries
            if (this.cache[channelId][location] &&
                (!timestampBoundaries ||
                    ((timestampBoundaries.from === undefined ||
                        timestampBoundaries.from <= (cache === null || cache === void 0 ? void 0 : cache.storageMeta.blockTimestamp)) &&
                        (timestampBoundaries.to === undefined ||
                            timestampBoundaries.to >= (cache === null || cache === void 0 ? void 0 : cache.storageMeta.blockTimestamp))))) {
                (_a = accumulator.meta.storageMeta) === null || _a === void 0 ? void 0 : _a.push(cache === null || cache === void 0 ? void 0 : cache.storageMeta);
                accumulator.meta.transactionsStorageLocation.push(location);
                // cache?.block.transactions will always contain one transaction
                accumulator.result.transactions.push({
                    state: types_1.DataAccessTypes.TransactionState.PENDING,
                    timestamp: cache === null || cache === void 0 ? void 0 : cache.storageMeta.blockTimestamp,
                    transaction: cache === null || cache === void 0 ? void 0 : cache.block.transactions[0],
                });
            }
            return accumulator;
        }, {
            meta: { storageMeta: [], transactionsStorageLocation: [] },
            result: { transactions: [] },
        });
    }
}
exports.default = HttpMetaMaskDataAccess;
//# sourceMappingURL=http-metamask-data-access.js.map