"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const multi_format_1 = require("@requestnetwork/multi-format");
const types_1 = require("@requestnetwork/types");
const events_1 = require("events");
const utils_1 = require("@requestnetwork/utils");
/**
 * Storage layer implemented with in-memory hashmap, to be used for testing.
 */
class MockStorage {
    constructor() {
        this.data = new Map();
        // For test purpose we can force the next append call to emit Error
        this.forceEmitError = false;
    }
    initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    ipfsAdd(content) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!content) {
                throw Error('Error: no content provided');
            }
            const hash = multi_format_1.default.serialize((0, utils_1.normalizeKeccak256Hash)(content));
            const nowTimestampInSec = (0, utils_1.getCurrentTimestampInSecond)();
            this.data.set(hash, {
                content,
                state: types_1.StorageTypes.ContentState.PENDING,
                timestamp: nowTimestampInSec,
            });
            return {
                ipfsHash: hash,
                ipfsSize: content.length,
            };
        });
    }
    append(content) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!content) {
                throw Error('Error: no content provided');
            }
            const hash = multi_format_1.default.serialize((0, utils_1.normalizeKeccak256Hash)(content));
            const nowTimestampInSec = (0, utils_1.getCurrentTimestampInSecond)();
            const dataToStore = {
                content,
                state: types_1.StorageTypes.ContentState.PENDING,
                timestamp: nowTimestampInSec,
            };
            this.data.set(hash, dataToStore);
            const resultData = {
                content,
                id: hash,
                meta: {
                    state: types_1.StorageTypes.ContentState.PENDING,
                    storageType: types_1.StorageTypes.StorageSystemType.IN_MEMORY_MOCK,
                    timestamp: nowTimestampInSec,
                },
            };
            const result = Object.assign(new events_1.EventEmitter(), resultData);
            setTimeout(() => {
                if (this.forceEmitError) {
                    // emit error
                    this.forceEmitError = false;
                    result.emit('error', 'forced error asked by _makeNextAppendFailInsteadOfConfirmed()');
                }
                else {
                    // emit confirmed
                    dataToStore.state = types_1.StorageTypes.ContentState.CONFIRMED;
                    this.data.set(hash, dataToStore);
                    result.emit('confirmed', resultData);
                }
                // eslint-disable-next-line no-magic-numbers
            }, 100);
            return result;
        });
    }
    read(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!id) {
                throw Error('No id provided');
            }
            const data = this.data.get(id);
            if (!data) {
                throw Error('No content found from this id');
            }
            return {
                content: data.content,
                id,
                meta: {
                    state: data.state,
                    storageType: types_1.StorageTypes.StorageSystemType.IN_MEMORY_MOCK,
                    timestamp: data.timestamp,
                },
            };
        });
    }
    readMany(ids) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return Promise.all(ids.map((id) => this.read(id)));
        });
    }
    getData() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const entries = Array.from(this.data.entries()).map(([id, { content, state, timestamp }]) => ({
                content,
                id,
                meta: {
                    state,
                    storageType: types_1.StorageTypes.StorageSystemType.IN_MEMORY_MOCK,
                    timestamp,
                },
            }));
            const nowTimestampInSec = (0, utils_1.getCurrentTimestampInSecond)();
            return {
                entries,
                lastTimestamp: nowTimestampInSec,
            };
        });
    }
    getIgnoredData() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    /**
     * Gets information
     *
     * @param detailed if true get the list of files hash
     */
    _getStatus(detailed) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return {
                dataIds: {
                    count: Object.entries(this.data).length,
                    values: detailed ? Object.entries(this.data) : undefined,
                },
                ignoredDataIds: {
                    count: 0,
                    values: detailed ? [] : undefined,
                },
            };
        });
    }
    _makeNextAppendFailInsteadOfConfirmed() {
        this.forceEmitError = true;
    }
}
exports.default = MockStorage;
//# sourceMappingURL=mock-storage.js.map