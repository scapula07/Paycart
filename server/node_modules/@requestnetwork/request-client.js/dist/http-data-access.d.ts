import { ClientTypes, DataAccessTypes } from '@requestnetwork/types';
import { AxiosRequestConfig } from 'axios';
/**
 * Exposes a Data-Access module over HTTP
 */
export default class HttpDataAccess implements DataAccessTypes.IDataAccess {
    /**
     * Configuration that overrides http-config-defaults,
     * @see httpConfigDefaults for the default configuration.
     */
    protected httpConfig: ClientTypes.IHttpDataAccessConfig;
    /**
     * Configuration that will be sent to axios for each request.
     * We can also create a AxiosInstance with axios.create() but it dramatically complicates testing.
     */
    protected axiosConfig: AxiosRequestConfig;
    /**
     * Creates an instance of HttpDataAccess.
     * @param httpConfig @see ClientTypes.IHttpDataAccessConfig for available options.
     * @param nodeConnectionConfig Configuration options to connect to the node. Follows Axios configuration format.
     */
    constructor({ httpConfig, nodeConnectionConfig, }?: {
        httpConfig?: Partial<ClientTypes.IHttpDataAccessConfig>;
        nodeConnectionConfig?: AxiosRequestConfig;
    });
    /**
     * Initialize the module. Does nothing, exists only to implement IDataAccess
     *
     * @returns nothing
     */
    initialize(): Promise<void>;
    /**
     * Closes the module. Does nothing, exists only to implement IDataAccess
     *
     * @returns nothing
     */
    close(): Promise<void>;
    /**
     * Persists a new transaction on a node through HTTP.
     *
     * @param transactionData The transaction data
     * @param topics The topics used to index the transaction
     */
    persistTransaction(transactionData: DataAccessTypes.ITransaction, channelId: string, topics?: string[]): Promise<DataAccessTypes.IReturnPersistTransaction>;
    /**
     * Gets the transactions for a channel from the node through HTTP.
     *
     * @param channelId The channel id to search for
     * @param timestampBoundaries filter timestamp boundaries
     */
    getTransactionsByChannelId(channelId: string, timestampBoundaries?: DataAccessTypes.ITimestampBoundaries): Promise<DataAccessTypes.IReturnGetTransactions>;
    /**
     * Gets all the transactions of channel indexed by topic from the node through HTTP.
     *
     * @param topic topic to search for
     * @param updatedBetween filter timestamp boundaries
     */
    getChannelsByTopic(topic: string, updatedBetween?: DataAccessTypes.ITimestampBoundaries): Promise<DataAccessTypes.IReturnGetChannelsByTopic>;
    /**
     * Gets all the transactions of channel indexed by multiple topics from the node through HTTP.
     *
     * @param topics topics to search for
     * @param updatedBetween filter timestamp boundaries
     */
    getChannelsByMultipleTopics(topics: string[], updatedBetween?: DataAccessTypes.ITimestampBoundaries): Promise<DataAccessTypes.IReturnGetChannelsByTopic>;
    /**
     * Gets information from the node (version, files etc...)
     *
     * @param detailed if true get the list of files hashes
     */
    _getStatus(detailed?: boolean): Promise<any>;
    /**
     * Sends an HTTP GET request to the node and retries until it succeeds.
     * Throws when the retry count reaches a maximum.
     *
     * @param url HTTP GET request url
     * @param params HTTP GET request parameters
     * @param retryConfig Maximum retry count, delay between retries, exponential backoff delay, and maximum exponential backoff delay
     */
    protected fetchAndRetry(url: string, params: any, retryConfig?: {
        maxRetries?: number;
        retryDelay?: number;
        exponentialBackoffDelay?: number;
        maxExponentialBackoffDelay?: number;
    }): Promise<any>;
}
//# sourceMappingURL=http-data-access.d.ts.map