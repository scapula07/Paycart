"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultBitcoinDetectionProvider = void 0;
const tslib_1 = require("tslib");
const default_providers_1 = require("./default-providers");
/**
 * The default Bitcoin detection provider give access to the bitcoin blockchain through several external API's
 */
class DefaultBitcoinDetectionProvider {
    /**
     * Creates an instance of DefaultBitcoinDetectionProvider
     */
    constructor() {
        this.providers = [
            new default_providers_1.BlockchainInfoProvider(),
            new default_providers_1.BlockStreamInfoProvider(),
            new default_providers_1.ChainSoProvider(),
            new default_providers_1.BlockcypherComProvider(),
        ];
    }
    /**
     * Gets BTC address balance with events
     *
     * @param bitcoinNetworkId The Bitcoin network ID: 0 (mainnet) or 3 (testnet)
     * @param address BTC address to check
     * @param eventName Indicates if it is an address for payment or refund
     * @returns Object containing address info
     */
    getAddressBalanceWithEvents(bitcoinNetworkId, address, eventName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.providers.length < 2) {
                throw new Error('At least two bitcoin providers are needed');
            }
            let providerUsedIndex = 0;
            let infoFromProviders = [];
            // The two first calls to the providers
            infoFromProviders = yield Promise.all([
                this.providers[providerUsedIndex++].getAddressBalanceWithEvents(bitcoinNetworkId, address, eventName),
                this.providers[providerUsedIndex++].getAddressBalanceWithEvents(bitcoinNetworkId, address, eventName),
            ]);
            let mostCommon = this.getMostCommonBalance(infoFromProviders);
            // while there are not two identical balances, we try to get the information from another provider
            while ((!mostCommon || mostCommon.count < 2) && providerUsedIndex < this.providers.length) {
                infoFromProviders.push(yield this.providers[providerUsedIndex++].getAddressBalanceWithEvents(bitcoinNetworkId, address, eventName));
                mostCommon = this.getMostCommonBalance(infoFromProviders);
            }
            // If there are two identical balances we return it
            if (mostCommon && mostCommon.count >= 2) {
                return mostCommon.value;
            }
            throw new Error('Error getting the balance from the bitcoin providers');
        });
    }
    /**
     * Get the balance and events the most common in an array
     *
     * @param array array to count
     * @returns Object containing IBalanceWithEvents and the count
     */
    getMostCommonBalance(array) {
        // Reduce the array to an object indexed by balance with the count
        const duplicatesWithCount = array
            .filter((info) => info.balance !== '-1')
            .reduce((accumulator, elem) => {
            if (elem.balance !== null) {
                if (!accumulator[elem.balance]) {
                    accumulator[elem.balance] = { count: 0, value: elem };
                }
                accumulator[elem.balance].count++;
            }
            return accumulator;
        }, {});
        // Sort the array by the count
        const sortedArray = Object.values(duplicatesWithCount).sort((a, b) => b.count - a.count);
        // Get the first element
        return sortedArray[0];
    }
}
exports.DefaultBitcoinDetectionProvider = DefaultBitcoinDetectionProvider;
//# sourceMappingURL=default-bitcoin-detection-provider.js.map