import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
export type Maybe<T> = T | null;
export type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    BigDecimal: any;
    BigInt: any;
    Bytes: any;
};
export type BlockChangedFilter = {
    number_gte: Scalars['Int'];
};
export type Block_Height = {
    hash?: Maybe<Scalars['Bytes']>;
    number?: Maybe<Scalars['Int']>;
    number_gte?: Maybe<Scalars['Int']>;
};
export type Escrow = {
    __typename?: 'Escrow';
    id: Scalars['ID'];
    contractAddress: Scalars['Bytes'];
    paymentProxyAddress: Scalars['Bytes'];
    reference: Scalars['Bytes'];
    creationBlock: Scalars['Int'];
    creationTimestamp: Scalars['Int'];
    escrowState: EscrowState;
    tokenAddress: Scalars['Bytes'];
    amount: Scalars['BigDecimal'];
    feeAmount: Scalars['BigDecimal'];
    feeAddress: Scalars['Bytes'];
    from: Scalars['Bytes'];
    to?: Maybe<Scalars['Bytes']>;
    events?: Maybe<Array<EscrowEvent>>;
};
export type EscrowEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<EscrowEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<EscrowEvent_Filter>;
};
export type EscrowEvent = {
    __typename?: 'EscrowEvent';
    id: Scalars['ID'];
    contractAddress: Scalars['Bytes'];
    reference: Scalars['Bytes'];
    escrow: Escrow;
    block: Scalars['Int'];
    timestamp: Scalars['Int'];
    txHash: Scalars['Bytes'];
    eventName: EventName;
    from: Scalars['Bytes'];
    gasUsed: Scalars['BigInt'];
    gasPrice: Scalars['BigInt'];
};
export type EscrowEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    contractAddress?: Maybe<Scalars['Bytes']>;
    contractAddress_not?: Maybe<Scalars['Bytes']>;
    contractAddress_gt?: Maybe<Scalars['Bytes']>;
    contractAddress_lt?: Maybe<Scalars['Bytes']>;
    contractAddress_gte?: Maybe<Scalars['Bytes']>;
    contractAddress_lte?: Maybe<Scalars['Bytes']>;
    contractAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    contractAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    contractAddress_contains?: Maybe<Scalars['Bytes']>;
    contractAddress_not_contains?: Maybe<Scalars['Bytes']>;
    reference?: Maybe<Scalars['Bytes']>;
    reference_not?: Maybe<Scalars['Bytes']>;
    reference_gt?: Maybe<Scalars['Bytes']>;
    reference_lt?: Maybe<Scalars['Bytes']>;
    reference_gte?: Maybe<Scalars['Bytes']>;
    reference_lte?: Maybe<Scalars['Bytes']>;
    reference_in?: Maybe<Array<Scalars['Bytes']>>;
    reference_not_in?: Maybe<Array<Scalars['Bytes']>>;
    reference_contains?: Maybe<Scalars['Bytes']>;
    reference_not_contains?: Maybe<Scalars['Bytes']>;
    escrow?: Maybe<Scalars['String']>;
    escrow_not?: Maybe<Scalars['String']>;
    escrow_gt?: Maybe<Scalars['String']>;
    escrow_lt?: Maybe<Scalars['String']>;
    escrow_gte?: Maybe<Scalars['String']>;
    escrow_lte?: Maybe<Scalars['String']>;
    escrow_in?: Maybe<Array<Scalars['String']>>;
    escrow_not_in?: Maybe<Array<Scalars['String']>>;
    escrow_contains?: Maybe<Scalars['String']>;
    escrow_contains_nocase?: Maybe<Scalars['String']>;
    escrow_not_contains?: Maybe<Scalars['String']>;
    escrow_not_contains_nocase?: Maybe<Scalars['String']>;
    escrow_starts_with?: Maybe<Scalars['String']>;
    escrow_starts_with_nocase?: Maybe<Scalars['String']>;
    escrow_not_starts_with?: Maybe<Scalars['String']>;
    escrow_not_starts_with_nocase?: Maybe<Scalars['String']>;
    escrow_ends_with?: Maybe<Scalars['String']>;
    escrow_ends_with_nocase?: Maybe<Scalars['String']>;
    escrow_not_ends_with?: Maybe<Scalars['String']>;
    escrow_not_ends_with_nocase?: Maybe<Scalars['String']>;
    escrow_?: Maybe<Escrow_Filter>;
    block?: Maybe<Scalars['Int']>;
    block_not?: Maybe<Scalars['Int']>;
    block_gt?: Maybe<Scalars['Int']>;
    block_lt?: Maybe<Scalars['Int']>;
    block_gte?: Maybe<Scalars['Int']>;
    block_lte?: Maybe<Scalars['Int']>;
    block_in?: Maybe<Array<Scalars['Int']>>;
    block_not_in?: Maybe<Array<Scalars['Int']>>;
    timestamp?: Maybe<Scalars['Int']>;
    timestamp_not?: Maybe<Scalars['Int']>;
    timestamp_gt?: Maybe<Scalars['Int']>;
    timestamp_lt?: Maybe<Scalars['Int']>;
    timestamp_gte?: Maybe<Scalars['Int']>;
    timestamp_lte?: Maybe<Scalars['Int']>;
    timestamp_in?: Maybe<Array<Scalars['Int']>>;
    timestamp_not_in?: Maybe<Array<Scalars['Int']>>;
    txHash?: Maybe<Scalars['Bytes']>;
    txHash_not?: Maybe<Scalars['Bytes']>;
    txHash_gt?: Maybe<Scalars['Bytes']>;
    txHash_lt?: Maybe<Scalars['Bytes']>;
    txHash_gte?: Maybe<Scalars['Bytes']>;
    txHash_lte?: Maybe<Scalars['Bytes']>;
    txHash_in?: Maybe<Array<Scalars['Bytes']>>;
    txHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    txHash_contains?: Maybe<Scalars['Bytes']>;
    txHash_not_contains?: Maybe<Scalars['Bytes']>;
    eventName?: Maybe<EventName>;
    eventName_not?: Maybe<EventName>;
    eventName_in?: Maybe<Array<EventName>>;
    eventName_not_in?: Maybe<Array<EventName>>;
    from?: Maybe<Scalars['Bytes']>;
    from_not?: Maybe<Scalars['Bytes']>;
    from_gt?: Maybe<Scalars['Bytes']>;
    from_lt?: Maybe<Scalars['Bytes']>;
    from_gte?: Maybe<Scalars['Bytes']>;
    from_lte?: Maybe<Scalars['Bytes']>;
    from_in?: Maybe<Array<Scalars['Bytes']>>;
    from_not_in?: Maybe<Array<Scalars['Bytes']>>;
    from_contains?: Maybe<Scalars['Bytes']>;
    from_not_contains?: Maybe<Scalars['Bytes']>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<EscrowEvent_Filter>>>;
    or?: Maybe<Array<Maybe<EscrowEvent_Filter>>>;
};
export declare enum EscrowEvent_OrderBy {
    Id = "id",
    ContractAddress = "contractAddress",
    Reference = "reference",
    Escrow = "escrow",
    EscrowId = "escrow__id",
    EscrowContractAddress = "escrow__contractAddress",
    EscrowPaymentProxyAddress = "escrow__paymentProxyAddress",
    EscrowReference = "escrow__reference",
    EscrowCreationBlock = "escrow__creationBlock",
    EscrowCreationTimestamp = "escrow__creationTimestamp",
    EscrowEscrowState = "escrow__escrowState",
    EscrowTokenAddress = "escrow__tokenAddress",
    EscrowAmount = "escrow__amount",
    EscrowFeeAmount = "escrow__feeAmount",
    EscrowFeeAddress = "escrow__feeAddress",
    EscrowFrom = "escrow__from",
    EscrowTo = "escrow__to",
    Block = "block",
    Timestamp = "timestamp",
    TxHash = "txHash",
    EventName = "eventName",
    From = "from",
    GasUsed = "gasUsed",
    GasPrice = "gasPrice"
}
export declare enum EscrowState {
    PaidEscrow = "paidEscrow",
    PaidIssuer = "paidIssuer",
    Emergency = "emergency",
    Frozen = "frozen"
}
export type Escrow_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    contractAddress?: Maybe<Scalars['Bytes']>;
    contractAddress_not?: Maybe<Scalars['Bytes']>;
    contractAddress_gt?: Maybe<Scalars['Bytes']>;
    contractAddress_lt?: Maybe<Scalars['Bytes']>;
    contractAddress_gte?: Maybe<Scalars['Bytes']>;
    contractAddress_lte?: Maybe<Scalars['Bytes']>;
    contractAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    contractAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    contractAddress_contains?: Maybe<Scalars['Bytes']>;
    contractAddress_not_contains?: Maybe<Scalars['Bytes']>;
    paymentProxyAddress?: Maybe<Scalars['Bytes']>;
    paymentProxyAddress_not?: Maybe<Scalars['Bytes']>;
    paymentProxyAddress_gt?: Maybe<Scalars['Bytes']>;
    paymentProxyAddress_lt?: Maybe<Scalars['Bytes']>;
    paymentProxyAddress_gte?: Maybe<Scalars['Bytes']>;
    paymentProxyAddress_lte?: Maybe<Scalars['Bytes']>;
    paymentProxyAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    paymentProxyAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    paymentProxyAddress_contains?: Maybe<Scalars['Bytes']>;
    paymentProxyAddress_not_contains?: Maybe<Scalars['Bytes']>;
    reference?: Maybe<Scalars['Bytes']>;
    reference_not?: Maybe<Scalars['Bytes']>;
    reference_gt?: Maybe<Scalars['Bytes']>;
    reference_lt?: Maybe<Scalars['Bytes']>;
    reference_gte?: Maybe<Scalars['Bytes']>;
    reference_lte?: Maybe<Scalars['Bytes']>;
    reference_in?: Maybe<Array<Scalars['Bytes']>>;
    reference_not_in?: Maybe<Array<Scalars['Bytes']>>;
    reference_contains?: Maybe<Scalars['Bytes']>;
    reference_not_contains?: Maybe<Scalars['Bytes']>;
    creationBlock?: Maybe<Scalars['Int']>;
    creationBlock_not?: Maybe<Scalars['Int']>;
    creationBlock_gt?: Maybe<Scalars['Int']>;
    creationBlock_lt?: Maybe<Scalars['Int']>;
    creationBlock_gte?: Maybe<Scalars['Int']>;
    creationBlock_lte?: Maybe<Scalars['Int']>;
    creationBlock_in?: Maybe<Array<Scalars['Int']>>;
    creationBlock_not_in?: Maybe<Array<Scalars['Int']>>;
    creationTimestamp?: Maybe<Scalars['Int']>;
    creationTimestamp_not?: Maybe<Scalars['Int']>;
    creationTimestamp_gt?: Maybe<Scalars['Int']>;
    creationTimestamp_lt?: Maybe<Scalars['Int']>;
    creationTimestamp_gte?: Maybe<Scalars['Int']>;
    creationTimestamp_lte?: Maybe<Scalars['Int']>;
    creationTimestamp_in?: Maybe<Array<Scalars['Int']>>;
    creationTimestamp_not_in?: Maybe<Array<Scalars['Int']>>;
    escrowState?: Maybe<EscrowState>;
    escrowState_not?: Maybe<EscrowState>;
    escrowState_in?: Maybe<Array<EscrowState>>;
    escrowState_not_in?: Maybe<Array<EscrowState>>;
    tokenAddress?: Maybe<Scalars['Bytes']>;
    tokenAddress_not?: Maybe<Scalars['Bytes']>;
    tokenAddress_gt?: Maybe<Scalars['Bytes']>;
    tokenAddress_lt?: Maybe<Scalars['Bytes']>;
    tokenAddress_gte?: Maybe<Scalars['Bytes']>;
    tokenAddress_lte?: Maybe<Scalars['Bytes']>;
    tokenAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    tokenAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    tokenAddress_contains?: Maybe<Scalars['Bytes']>;
    tokenAddress_not_contains?: Maybe<Scalars['Bytes']>;
    amount?: Maybe<Scalars['BigDecimal']>;
    amount_not?: Maybe<Scalars['BigDecimal']>;
    amount_gt?: Maybe<Scalars['BigDecimal']>;
    amount_lt?: Maybe<Scalars['BigDecimal']>;
    amount_gte?: Maybe<Scalars['BigDecimal']>;
    amount_lte?: Maybe<Scalars['BigDecimal']>;
    amount_in?: Maybe<Array<Scalars['BigDecimal']>>;
    amount_not_in?: Maybe<Array<Scalars['BigDecimal']>>;
    feeAmount?: Maybe<Scalars['BigDecimal']>;
    feeAmount_not?: Maybe<Scalars['BigDecimal']>;
    feeAmount_gt?: Maybe<Scalars['BigDecimal']>;
    feeAmount_lt?: Maybe<Scalars['BigDecimal']>;
    feeAmount_gte?: Maybe<Scalars['BigDecimal']>;
    feeAmount_lte?: Maybe<Scalars['BigDecimal']>;
    feeAmount_in?: Maybe<Array<Scalars['BigDecimal']>>;
    feeAmount_not_in?: Maybe<Array<Scalars['BigDecimal']>>;
    feeAddress?: Maybe<Scalars['Bytes']>;
    feeAddress_not?: Maybe<Scalars['Bytes']>;
    feeAddress_gt?: Maybe<Scalars['Bytes']>;
    feeAddress_lt?: Maybe<Scalars['Bytes']>;
    feeAddress_gte?: Maybe<Scalars['Bytes']>;
    feeAddress_lte?: Maybe<Scalars['Bytes']>;
    feeAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    feeAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    feeAddress_contains?: Maybe<Scalars['Bytes']>;
    feeAddress_not_contains?: Maybe<Scalars['Bytes']>;
    from?: Maybe<Scalars['Bytes']>;
    from_not?: Maybe<Scalars['Bytes']>;
    from_gt?: Maybe<Scalars['Bytes']>;
    from_lt?: Maybe<Scalars['Bytes']>;
    from_gte?: Maybe<Scalars['Bytes']>;
    from_lte?: Maybe<Scalars['Bytes']>;
    from_in?: Maybe<Array<Scalars['Bytes']>>;
    from_not_in?: Maybe<Array<Scalars['Bytes']>>;
    from_contains?: Maybe<Scalars['Bytes']>;
    from_not_contains?: Maybe<Scalars['Bytes']>;
    to?: Maybe<Scalars['Bytes']>;
    to_not?: Maybe<Scalars['Bytes']>;
    to_gt?: Maybe<Scalars['Bytes']>;
    to_lt?: Maybe<Scalars['Bytes']>;
    to_gte?: Maybe<Scalars['Bytes']>;
    to_lte?: Maybe<Scalars['Bytes']>;
    to_in?: Maybe<Array<Scalars['Bytes']>>;
    to_not_in?: Maybe<Array<Scalars['Bytes']>>;
    to_contains?: Maybe<Scalars['Bytes']>;
    to_not_contains?: Maybe<Scalars['Bytes']>;
    events_?: Maybe<EscrowEvent_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<Escrow_Filter>>>;
    or?: Maybe<Array<Maybe<Escrow_Filter>>>;
};
export declare enum Escrow_OrderBy {
    Id = "id",
    ContractAddress = "contractAddress",
    PaymentProxyAddress = "paymentProxyAddress",
    Reference = "reference",
    CreationBlock = "creationBlock",
    CreationTimestamp = "creationTimestamp",
    EscrowState = "escrowState",
    TokenAddress = "tokenAddress",
    Amount = "amount",
    FeeAmount = "feeAmount",
    FeeAddress = "feeAddress",
    From = "from",
    To = "to",
    Events = "events"
}
export declare enum EventName {
    PaidEscrow = "paidEscrow",
    PaidIssuer = "paidIssuer",
    InitiateEmergencyClaim = "initiateEmergencyClaim",
    RevertEmergencyClaim = "revertEmergencyClaim",
    FreezeEscrow = "freezeEscrow"
}
/** Defines the order direction, either ascending or descending */
export declare enum OrderDirection {
    Asc = "asc",
    Desc = "desc"
}
export type Payment = {
    __typename?: 'Payment';
    id: Scalars['ID'];
    contractAddress: Scalars['Bytes'];
    tokenAddress?: Maybe<Scalars['Bytes']>;
    to: Scalars['Bytes'];
    from: Scalars['Bytes'];
    reference: Scalars['Bytes'];
    block: Scalars['Int'];
    timestamp: Scalars['Int'];
    txHash: Scalars['Bytes'];
    gasUsed: Scalars['BigInt'];
    gasPrice: Scalars['BigInt'];
    amount: Scalars['BigDecimal'];
    feeAmount?: Maybe<Scalars['BigDecimal']>;
    feeAddress?: Maybe<Scalars['Bytes']>;
    currency?: Maybe<Scalars['Bytes']>;
    amountInCrypto?: Maybe<Scalars['BigDecimal']>;
    feeAmountInCrypto?: Maybe<Scalars['BigDecimal']>;
    maxRateTimespan?: Maybe<Scalars['Int']>;
};
export type Payment_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    contractAddress?: Maybe<Scalars['Bytes']>;
    contractAddress_not?: Maybe<Scalars['Bytes']>;
    contractAddress_gt?: Maybe<Scalars['Bytes']>;
    contractAddress_lt?: Maybe<Scalars['Bytes']>;
    contractAddress_gte?: Maybe<Scalars['Bytes']>;
    contractAddress_lte?: Maybe<Scalars['Bytes']>;
    contractAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    contractAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    contractAddress_contains?: Maybe<Scalars['Bytes']>;
    contractAddress_not_contains?: Maybe<Scalars['Bytes']>;
    tokenAddress?: Maybe<Scalars['Bytes']>;
    tokenAddress_not?: Maybe<Scalars['Bytes']>;
    tokenAddress_gt?: Maybe<Scalars['Bytes']>;
    tokenAddress_lt?: Maybe<Scalars['Bytes']>;
    tokenAddress_gte?: Maybe<Scalars['Bytes']>;
    tokenAddress_lte?: Maybe<Scalars['Bytes']>;
    tokenAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    tokenAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    tokenAddress_contains?: Maybe<Scalars['Bytes']>;
    tokenAddress_not_contains?: Maybe<Scalars['Bytes']>;
    to?: Maybe<Scalars['Bytes']>;
    to_not?: Maybe<Scalars['Bytes']>;
    to_gt?: Maybe<Scalars['Bytes']>;
    to_lt?: Maybe<Scalars['Bytes']>;
    to_gte?: Maybe<Scalars['Bytes']>;
    to_lte?: Maybe<Scalars['Bytes']>;
    to_in?: Maybe<Array<Scalars['Bytes']>>;
    to_not_in?: Maybe<Array<Scalars['Bytes']>>;
    to_contains?: Maybe<Scalars['Bytes']>;
    to_not_contains?: Maybe<Scalars['Bytes']>;
    from?: Maybe<Scalars['Bytes']>;
    from_not?: Maybe<Scalars['Bytes']>;
    from_gt?: Maybe<Scalars['Bytes']>;
    from_lt?: Maybe<Scalars['Bytes']>;
    from_gte?: Maybe<Scalars['Bytes']>;
    from_lte?: Maybe<Scalars['Bytes']>;
    from_in?: Maybe<Array<Scalars['Bytes']>>;
    from_not_in?: Maybe<Array<Scalars['Bytes']>>;
    from_contains?: Maybe<Scalars['Bytes']>;
    from_not_contains?: Maybe<Scalars['Bytes']>;
    reference?: Maybe<Scalars['Bytes']>;
    reference_not?: Maybe<Scalars['Bytes']>;
    reference_gt?: Maybe<Scalars['Bytes']>;
    reference_lt?: Maybe<Scalars['Bytes']>;
    reference_gte?: Maybe<Scalars['Bytes']>;
    reference_lte?: Maybe<Scalars['Bytes']>;
    reference_in?: Maybe<Array<Scalars['Bytes']>>;
    reference_not_in?: Maybe<Array<Scalars['Bytes']>>;
    reference_contains?: Maybe<Scalars['Bytes']>;
    reference_not_contains?: Maybe<Scalars['Bytes']>;
    block?: Maybe<Scalars['Int']>;
    block_not?: Maybe<Scalars['Int']>;
    block_gt?: Maybe<Scalars['Int']>;
    block_lt?: Maybe<Scalars['Int']>;
    block_gte?: Maybe<Scalars['Int']>;
    block_lte?: Maybe<Scalars['Int']>;
    block_in?: Maybe<Array<Scalars['Int']>>;
    block_not_in?: Maybe<Array<Scalars['Int']>>;
    timestamp?: Maybe<Scalars['Int']>;
    timestamp_not?: Maybe<Scalars['Int']>;
    timestamp_gt?: Maybe<Scalars['Int']>;
    timestamp_lt?: Maybe<Scalars['Int']>;
    timestamp_gte?: Maybe<Scalars['Int']>;
    timestamp_lte?: Maybe<Scalars['Int']>;
    timestamp_in?: Maybe<Array<Scalars['Int']>>;
    timestamp_not_in?: Maybe<Array<Scalars['Int']>>;
    txHash?: Maybe<Scalars['Bytes']>;
    txHash_not?: Maybe<Scalars['Bytes']>;
    txHash_gt?: Maybe<Scalars['Bytes']>;
    txHash_lt?: Maybe<Scalars['Bytes']>;
    txHash_gte?: Maybe<Scalars['Bytes']>;
    txHash_lte?: Maybe<Scalars['Bytes']>;
    txHash_in?: Maybe<Array<Scalars['Bytes']>>;
    txHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    txHash_contains?: Maybe<Scalars['Bytes']>;
    txHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    amount?: Maybe<Scalars['BigDecimal']>;
    amount_not?: Maybe<Scalars['BigDecimal']>;
    amount_gt?: Maybe<Scalars['BigDecimal']>;
    amount_lt?: Maybe<Scalars['BigDecimal']>;
    amount_gte?: Maybe<Scalars['BigDecimal']>;
    amount_lte?: Maybe<Scalars['BigDecimal']>;
    amount_in?: Maybe<Array<Scalars['BigDecimal']>>;
    amount_not_in?: Maybe<Array<Scalars['BigDecimal']>>;
    feeAmount?: Maybe<Scalars['BigDecimal']>;
    feeAmount_not?: Maybe<Scalars['BigDecimal']>;
    feeAmount_gt?: Maybe<Scalars['BigDecimal']>;
    feeAmount_lt?: Maybe<Scalars['BigDecimal']>;
    feeAmount_gte?: Maybe<Scalars['BigDecimal']>;
    feeAmount_lte?: Maybe<Scalars['BigDecimal']>;
    feeAmount_in?: Maybe<Array<Scalars['BigDecimal']>>;
    feeAmount_not_in?: Maybe<Array<Scalars['BigDecimal']>>;
    feeAddress?: Maybe<Scalars['Bytes']>;
    feeAddress_not?: Maybe<Scalars['Bytes']>;
    feeAddress_gt?: Maybe<Scalars['Bytes']>;
    feeAddress_lt?: Maybe<Scalars['Bytes']>;
    feeAddress_gte?: Maybe<Scalars['Bytes']>;
    feeAddress_lte?: Maybe<Scalars['Bytes']>;
    feeAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    feeAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    feeAddress_contains?: Maybe<Scalars['Bytes']>;
    feeAddress_not_contains?: Maybe<Scalars['Bytes']>;
    currency?: Maybe<Scalars['Bytes']>;
    currency_not?: Maybe<Scalars['Bytes']>;
    currency_gt?: Maybe<Scalars['Bytes']>;
    currency_lt?: Maybe<Scalars['Bytes']>;
    currency_gte?: Maybe<Scalars['Bytes']>;
    currency_lte?: Maybe<Scalars['Bytes']>;
    currency_in?: Maybe<Array<Scalars['Bytes']>>;
    currency_not_in?: Maybe<Array<Scalars['Bytes']>>;
    currency_contains?: Maybe<Scalars['Bytes']>;
    currency_not_contains?: Maybe<Scalars['Bytes']>;
    amountInCrypto?: Maybe<Scalars['BigDecimal']>;
    amountInCrypto_not?: Maybe<Scalars['BigDecimal']>;
    amountInCrypto_gt?: Maybe<Scalars['BigDecimal']>;
    amountInCrypto_lt?: Maybe<Scalars['BigDecimal']>;
    amountInCrypto_gte?: Maybe<Scalars['BigDecimal']>;
    amountInCrypto_lte?: Maybe<Scalars['BigDecimal']>;
    amountInCrypto_in?: Maybe<Array<Scalars['BigDecimal']>>;
    amountInCrypto_not_in?: Maybe<Array<Scalars['BigDecimal']>>;
    feeAmountInCrypto?: Maybe<Scalars['BigDecimal']>;
    feeAmountInCrypto_not?: Maybe<Scalars['BigDecimal']>;
    feeAmountInCrypto_gt?: Maybe<Scalars['BigDecimal']>;
    feeAmountInCrypto_lt?: Maybe<Scalars['BigDecimal']>;
    feeAmountInCrypto_gte?: Maybe<Scalars['BigDecimal']>;
    feeAmountInCrypto_lte?: Maybe<Scalars['BigDecimal']>;
    feeAmountInCrypto_in?: Maybe<Array<Scalars['BigDecimal']>>;
    feeAmountInCrypto_not_in?: Maybe<Array<Scalars['BigDecimal']>>;
    maxRateTimespan?: Maybe<Scalars['Int']>;
    maxRateTimespan_not?: Maybe<Scalars['Int']>;
    maxRateTimespan_gt?: Maybe<Scalars['Int']>;
    maxRateTimespan_lt?: Maybe<Scalars['Int']>;
    maxRateTimespan_gte?: Maybe<Scalars['Int']>;
    maxRateTimespan_lte?: Maybe<Scalars['Int']>;
    maxRateTimespan_in?: Maybe<Array<Scalars['Int']>>;
    maxRateTimespan_not_in?: Maybe<Array<Scalars['Int']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<Payment_Filter>>>;
    or?: Maybe<Array<Maybe<Payment_Filter>>>;
};
export declare enum Payment_OrderBy {
    Id = "id",
    ContractAddress = "contractAddress",
    TokenAddress = "tokenAddress",
    To = "to",
    From = "from",
    Reference = "reference",
    Block = "block",
    Timestamp = "timestamp",
    TxHash = "txHash",
    GasUsed = "gasUsed",
    GasPrice = "gasPrice",
    Amount = "amount",
    FeeAmount = "feeAmount",
    FeeAddress = "feeAddress",
    Currency = "currency",
    AmountInCrypto = "amountInCrypto",
    FeeAmountInCrypto = "feeAmountInCrypto",
    MaxRateTimespan = "maxRateTimespan"
}
export type Query = {
    __typename?: 'Query';
    payment?: Maybe<Payment>;
    payments: Array<Payment>;
    escrow?: Maybe<Escrow>;
    escrows: Array<Escrow>;
    escrowEvent?: Maybe<EscrowEvent>;
    escrowEvents: Array<EscrowEvent>;
    /** Access to subgraph metadata */
    _meta?: Maybe<_Meta_>;
};
export type QueryPaymentArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryPaymentsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Payment_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Payment_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryEscrowArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryEscrowsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Escrow_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Escrow_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryEscrowEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryEscrowEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<EscrowEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<EscrowEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type Query_MetaArgs = {
    block?: Maybe<Block_Height>;
};
export type Subscription = {
    __typename?: 'Subscription';
    payment?: Maybe<Payment>;
    payments: Array<Payment>;
    escrow?: Maybe<Escrow>;
    escrows: Array<Escrow>;
    escrowEvent?: Maybe<EscrowEvent>;
    escrowEvents: Array<EscrowEvent>;
    /** Access to subgraph metadata */
    _meta?: Maybe<_Meta_>;
};
export type SubscriptionPaymentArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionPaymentsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Payment_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Payment_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionEscrowArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionEscrowsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Escrow_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Escrow_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionEscrowEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionEscrowEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<EscrowEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<EscrowEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type Subscription_MetaArgs = {
    block?: Maybe<Block_Height>;
};
export type _Block_ = {
    __typename?: '_Block_';
    /** The hash of the block */
    hash?: Maybe<Scalars['Bytes']>;
    /** The block number */
    number: Scalars['Int'];
    /** Integer representation of the timestamp stored in blocks for the chain */
    timestamp?: Maybe<Scalars['Int']>;
};
/** The type for the top-level _meta field */
export type _Meta_ = {
    __typename?: '_Meta_';
    /**
     * Information about a specific subgraph block. The hash of the block
     * will be null if the _meta field has a block constraint that asks for
     * a block number. It will be filled if the _meta field has no block constraint
     * and therefore asks for the latest  block
     */
    block: _Block_;
    /** The deployment ID */
    deployment: Scalars['String'];
    /** If `true`, the subgraph encountered indexing errors at some past block */
    hasIndexingErrors: Scalars['Boolean'];
};
export declare enum _SubgraphErrorPolicy_ {
    /** Data will be returned even if the subgraph has indexing errors */
    Allow = "allow",
    /** If the subgraph has indexing errors, data will be omitted. The default. */
    Deny = "deny"
}
export type GetLastSyncedBlockQueryVariables = Exact<{
    [key: string]: never;
}>;
export type GetLastSyncedBlockQuery = ({
    __typename?: 'Query';
} & {
    _meta?: Maybe<({
        __typename?: '_Meta_';
    } & {
        block: ({
            __typename?: '_Block_';
        } & Pick<_Block_, 'number' | 'hash'>);
    })>;
});
export type PaymentEventResultFragment = ({
    __typename?: 'Payment';
} & Pick<Payment, 'amount' | 'block' | 'txHash' | 'feeAmount' | 'feeAddress' | 'from' | 'gasUsed' | 'gasPrice' | 'timestamp' | 'contractAddress' | 'to' | 'tokenAddress' | 'currency' | 'amountInCrypto' | 'feeAmountInCrypto' | 'maxRateTimespan'>);
export type EscrowEventResultFragment = ({
    __typename?: 'EscrowEvent';
} & Pick<EscrowEvent, 'txHash' | 'eventName' | 'from' | 'timestamp' | 'block' | 'gasUsed' | 'gasPrice'>);
export type GetPaymentsAndEscrowStateQueryVariables = Exact<{
    reference: Scalars['Bytes'];
    to: Scalars['Bytes'];
    tokenAddress?: Maybe<Scalars['Bytes']>;
    contractAddress: Scalars['Bytes'];
}>;
export type GetPaymentsAndEscrowStateQuery = ({
    __typename?: 'Query';
} & {
    payments: Array<({
        __typename?: 'Payment';
    } & PaymentEventResultFragment)>;
    escrowEvents: Array<({
        __typename?: 'EscrowEvent';
    } & EscrowEventResultFragment)>;
});
export type GetAnyToFungiblePaymentsQueryVariables = Exact<{
    reference: Scalars['Bytes'];
    to: Scalars['Bytes'];
    currency: Scalars['Bytes'];
    acceptedTokens?: Maybe<Array<Scalars['Bytes']> | Scalars['Bytes']>;
    contractAddress: Scalars['Bytes'];
}>;
export type GetAnyToFungiblePaymentsQuery = ({
    __typename?: 'Query';
} & {
    payments: Array<({
        __typename?: 'Payment';
    } & PaymentEventResultFragment)>;
});
export type GetAnyToNativePaymentsQueryVariables = Exact<{
    reference: Scalars['Bytes'];
    to: Scalars['Bytes'];
    currency: Scalars['Bytes'];
    contractAddress: Scalars['Bytes'];
}>;
export type GetAnyToNativePaymentsQuery = ({
    __typename?: 'Query';
} & {
    payments: Array<({
        __typename?: 'Payment';
    } & PaymentEventResultFragment)>;
});
export type GetPaymentsAndEscrowStateForReceivablesQueryVariables = Exact<{
    reference: Scalars['Bytes'];
    tokenAddress: Scalars['Bytes'];
    contractAddress: Scalars['Bytes'];
}>;
export type GetPaymentsAndEscrowStateForReceivablesQuery = ({
    __typename?: 'Query';
} & {
    payments: Array<({
        __typename?: 'Payment';
    } & PaymentEventResultFragment)>;
    escrowEvents: Array<({
        __typename?: 'EscrowEvent';
    } & EscrowEventResultFragment)>;
});
export type GetSyncedBlockQueryVariables = Exact<{
    blockHash: Scalars['Bytes'];
}>;
export type GetSyncedBlockQuery = ({
    __typename?: 'Query';
} & {
    _meta?: Maybe<({
        __typename?: '_Meta_';
    } & {
        block: ({
            __typename?: '_Block_';
        } & Pick<_Block_, 'number' | 'hash'>);
    })>;
});
export declare const PaymentEventResultFragmentDoc: import("graphql/language/ast").DocumentNode;
export declare const EscrowEventResultFragmentDoc: import("graphql/language/ast").DocumentNode;
export declare const GetLastSyncedBlockDocument: import("graphql/language/ast").DocumentNode;
export declare const GetPaymentsAndEscrowStateDocument: import("graphql/language/ast").DocumentNode;
export declare const GetAnyToFungiblePaymentsDocument: import("graphql/language/ast").DocumentNode;
export declare const GetAnyToNativePaymentsDocument: import("graphql/language/ast").DocumentNode;
export declare const GetPaymentsAndEscrowStateForReceivablesDocument: import("graphql/language/ast").DocumentNode;
export declare const GetSyncedBlockDocument: import("graphql/language/ast").DocumentNode;
export type SdkFunctionWrapper = <T>(action: (requestHeaders?: Record<string, string>) => Promise<T>, operationName: string) => Promise<T>;
export declare function getSdk(client: GraphQLClient, withWrapper?: SdkFunctionWrapper): {
    GetLastSyncedBlock(variables?: GetLastSyncedBlockQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetLastSyncedBlockQuery>;
    GetPaymentsAndEscrowState(variables: GetPaymentsAndEscrowStateQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetPaymentsAndEscrowStateQuery>;
    GetAnyToFungiblePayments(variables: GetAnyToFungiblePaymentsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetAnyToFungiblePaymentsQuery>;
    GetAnyToNativePayments(variables: GetAnyToNativePaymentsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetAnyToNativePaymentsQuery>;
    GetPaymentsAndEscrowStateForReceivables(variables: GetPaymentsAndEscrowStateForReceivablesQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetPaymentsAndEscrowStateForReceivablesQuery>;
    GetSyncedBlock(variables: GetSyncedBlockQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetSyncedBlockQuery>;
};
export type Sdk = ReturnType<typeof getSdk>;
export declare const PaymentEventResult: import("graphql/language/ast").DocumentNode;
export declare const EscrowEventResult: import("graphql/language/ast").DocumentNode;
export declare const GetLastSyncedBlock: import("graphql/language/ast").DocumentNode;
export declare const GetPaymentsAndEscrowState: import("graphql/language/ast").DocumentNode;
export declare const GetAnyToFungiblePayments: import("graphql/language/ast").DocumentNode;
export declare const GetAnyToNativePayments: import("graphql/language/ast").DocumentNode;
export declare const GetPaymentsAndEscrowStateForReceivables: import("graphql/language/ast").DocumentNode;
export declare const GetSyncedBlock: import("graphql/language/ast").DocumentNode;
//# sourceMappingURL=graphql.d.ts.map