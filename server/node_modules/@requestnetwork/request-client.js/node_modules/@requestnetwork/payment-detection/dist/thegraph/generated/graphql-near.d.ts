import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
export type Maybe<T> = T | null;
export type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    BigDecimal: any;
    BigInt: any;
    Bytes: any;
};
export type BlockChangedFilter = {
    number_gte: Scalars['Int'];
};
export type Block_Height = {
    hash?: Maybe<Scalars['Bytes']>;
    number?: Maybe<Scalars['Int']>;
    number_gte?: Maybe<Scalars['Int']>;
};
export type Escrow = {
    __typename?: 'Escrow';
    id: Scalars['ID'];
    contractAddress: Scalars['Bytes'];
    paymentProxyAddress: Scalars['Bytes'];
    reference: Scalars['Bytes'];
    creationBlock: Scalars['Int'];
    creationTimestamp: Scalars['Int'];
    escrowState: EscrowState;
    tokenAddress: Scalars['Bytes'];
    amount: Scalars['BigDecimal'];
    feeAmount: Scalars['BigDecimal'];
    feeAddress: Scalars['Bytes'];
    from: Scalars['Bytes'];
    to?: Maybe<Scalars['Bytes']>;
    events?: Maybe<Array<EscrowEvent>>;
};
export type EscrowEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<EscrowEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<EscrowEvent_Filter>;
};
export type EscrowEvent = {
    __typename?: 'EscrowEvent';
    id: Scalars['ID'];
    contractAddress: Scalars['Bytes'];
    reference: Scalars['Bytes'];
    escrow: Escrow;
    block: Scalars['Int'];
    timestamp: Scalars['Int'];
    txHash: Scalars['Bytes'];
    eventName: EventName;
    from: Scalars['Bytes'];
    gasUsed: Scalars['BigInt'];
    gasPrice: Scalars['BigInt'];
};
export type EscrowEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    contractAddress?: Maybe<Scalars['Bytes']>;
    contractAddress_not?: Maybe<Scalars['Bytes']>;
    contractAddress_gt?: Maybe<Scalars['Bytes']>;
    contractAddress_lt?: Maybe<Scalars['Bytes']>;
    contractAddress_gte?: Maybe<Scalars['Bytes']>;
    contractAddress_lte?: Maybe<Scalars['Bytes']>;
    contractAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    contractAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    contractAddress_contains?: Maybe<Scalars['Bytes']>;
    contractAddress_not_contains?: Maybe<Scalars['Bytes']>;
    reference?: Maybe<Scalars['Bytes']>;
    reference_not?: Maybe<Scalars['Bytes']>;
    reference_gt?: Maybe<Scalars['Bytes']>;
    reference_lt?: Maybe<Scalars['Bytes']>;
    reference_gte?: Maybe<Scalars['Bytes']>;
    reference_lte?: Maybe<Scalars['Bytes']>;
    reference_in?: Maybe<Array<Scalars['Bytes']>>;
    reference_not_in?: Maybe<Array<Scalars['Bytes']>>;
    reference_contains?: Maybe<Scalars['Bytes']>;
    reference_not_contains?: Maybe<Scalars['Bytes']>;
    escrow?: Maybe<Scalars['String']>;
    escrow_not?: Maybe<Scalars['String']>;
    escrow_gt?: Maybe<Scalars['String']>;
    escrow_lt?: Maybe<Scalars['String']>;
    escrow_gte?: Maybe<Scalars['String']>;
    escrow_lte?: Maybe<Scalars['String']>;
    escrow_in?: Maybe<Array<Scalars['String']>>;
    escrow_not_in?: Maybe<Array<Scalars['String']>>;
    escrow_contains?: Maybe<Scalars['String']>;
    escrow_contains_nocase?: Maybe<Scalars['String']>;
    escrow_not_contains?: Maybe<Scalars['String']>;
    escrow_not_contains_nocase?: Maybe<Scalars['String']>;
    escrow_starts_with?: Maybe<Scalars['String']>;
    escrow_starts_with_nocase?: Maybe<Scalars['String']>;
    escrow_not_starts_with?: Maybe<Scalars['String']>;
    escrow_not_starts_with_nocase?: Maybe<Scalars['String']>;
    escrow_ends_with?: Maybe<Scalars['String']>;
    escrow_ends_with_nocase?: Maybe<Scalars['String']>;
    escrow_not_ends_with?: Maybe<Scalars['String']>;
    escrow_not_ends_with_nocase?: Maybe<Scalars['String']>;
    escrow_?: Maybe<Escrow_Filter>;
    block?: Maybe<Scalars['Int']>;
    block_not?: Maybe<Scalars['Int']>;
    block_gt?: Maybe<Scalars['Int']>;
    block_lt?: Maybe<Scalars['Int']>;
    block_gte?: Maybe<Scalars['Int']>;
    block_lte?: Maybe<Scalars['Int']>;
    block_in?: Maybe<Array<Scalars['Int']>>;
    block_not_in?: Maybe<Array<Scalars['Int']>>;
    timestamp?: Maybe<Scalars['Int']>;
    timestamp_not?: Maybe<Scalars['Int']>;
    timestamp_gt?: Maybe<Scalars['Int']>;
    timestamp_lt?: Maybe<Scalars['Int']>;
    timestamp_gte?: Maybe<Scalars['Int']>;
    timestamp_lte?: Maybe<Scalars['Int']>;
    timestamp_in?: Maybe<Array<Scalars['Int']>>;
    timestamp_not_in?: Maybe<Array<Scalars['Int']>>;
    txHash?: Maybe<Scalars['Bytes']>;
    txHash_not?: Maybe<Scalars['Bytes']>;
    txHash_gt?: Maybe<Scalars['Bytes']>;
    txHash_lt?: Maybe<Scalars['Bytes']>;
    txHash_gte?: Maybe<Scalars['Bytes']>;
    txHash_lte?: Maybe<Scalars['Bytes']>;
    txHash_in?: Maybe<Array<Scalars['Bytes']>>;
    txHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    txHash_contains?: Maybe<Scalars['Bytes']>;
    txHash_not_contains?: Maybe<Scalars['Bytes']>;
    eventName?: Maybe<EventName>;
    eventName_not?: Maybe<EventName>;
    eventName_in?: Maybe<Array<EventName>>;
    eventName_not_in?: Maybe<Array<EventName>>;
    from?: Maybe<Scalars['Bytes']>;
    from_not?: Maybe<Scalars['Bytes']>;
    from_gt?: Maybe<Scalars['Bytes']>;
    from_lt?: Maybe<Scalars['Bytes']>;
    from_gte?: Maybe<Scalars['Bytes']>;
    from_lte?: Maybe<Scalars['Bytes']>;
    from_in?: Maybe<Array<Scalars['Bytes']>>;
    from_not_in?: Maybe<Array<Scalars['Bytes']>>;
    from_contains?: Maybe<Scalars['Bytes']>;
    from_not_contains?: Maybe<Scalars['Bytes']>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<EscrowEvent_Filter>>>;
    or?: Maybe<Array<Maybe<EscrowEvent_Filter>>>;
};
export declare enum EscrowEvent_OrderBy {
    Id = "id",
    ContractAddress = "contractAddress",
    Reference = "reference",
    Escrow = "escrow",
    EscrowId = "escrow__id",
    EscrowContractAddress = "escrow__contractAddress",
    EscrowPaymentProxyAddress = "escrow__paymentProxyAddress",
    EscrowReference = "escrow__reference",
    EscrowCreationBlock = "escrow__creationBlock",
    EscrowCreationTimestamp = "escrow__creationTimestamp",
    EscrowEscrowState = "escrow__escrowState",
    EscrowTokenAddress = "escrow__tokenAddress",
    EscrowAmount = "escrow__amount",
    EscrowFeeAmount = "escrow__feeAmount",
    EscrowFeeAddress = "escrow__feeAddress",
    EscrowFrom = "escrow__from",
    EscrowTo = "escrow__to",
    Block = "block",
    Timestamp = "timestamp",
    TxHash = "txHash",
    EventName = "eventName",
    From = "from",
    GasUsed = "gasUsed",
    GasPrice = "gasPrice"
}
export declare enum EscrowState {
    PaidEscrow = "paidEscrow",
    PaidIssuer = "paidIssuer",
    Emergency = "emergency",
    Frozen = "frozen"
}
export type Escrow_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    contractAddress?: Maybe<Scalars['Bytes']>;
    contractAddress_not?: Maybe<Scalars['Bytes']>;
    contractAddress_gt?: Maybe<Scalars['Bytes']>;
    contractAddress_lt?: Maybe<Scalars['Bytes']>;
    contractAddress_gte?: Maybe<Scalars['Bytes']>;
    contractAddress_lte?: Maybe<Scalars['Bytes']>;
    contractAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    contractAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    contractAddress_contains?: Maybe<Scalars['Bytes']>;
    contractAddress_not_contains?: Maybe<Scalars['Bytes']>;
    paymentProxyAddress?: Maybe<Scalars['Bytes']>;
    paymentProxyAddress_not?: Maybe<Scalars['Bytes']>;
    paymentProxyAddress_gt?: Maybe<Scalars['Bytes']>;
    paymentProxyAddress_lt?: Maybe<Scalars['Bytes']>;
    paymentProxyAddress_gte?: Maybe<Scalars['Bytes']>;
    paymentProxyAddress_lte?: Maybe<Scalars['Bytes']>;
    paymentProxyAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    paymentProxyAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    paymentProxyAddress_contains?: Maybe<Scalars['Bytes']>;
    paymentProxyAddress_not_contains?: Maybe<Scalars['Bytes']>;
    reference?: Maybe<Scalars['Bytes']>;
    reference_not?: Maybe<Scalars['Bytes']>;
    reference_gt?: Maybe<Scalars['Bytes']>;
    reference_lt?: Maybe<Scalars['Bytes']>;
    reference_gte?: Maybe<Scalars['Bytes']>;
    reference_lte?: Maybe<Scalars['Bytes']>;
    reference_in?: Maybe<Array<Scalars['Bytes']>>;
    reference_not_in?: Maybe<Array<Scalars['Bytes']>>;
    reference_contains?: Maybe<Scalars['Bytes']>;
    reference_not_contains?: Maybe<Scalars['Bytes']>;
    creationBlock?: Maybe<Scalars['Int']>;
    creationBlock_not?: Maybe<Scalars['Int']>;
    creationBlock_gt?: Maybe<Scalars['Int']>;
    creationBlock_lt?: Maybe<Scalars['Int']>;
    creationBlock_gte?: Maybe<Scalars['Int']>;
    creationBlock_lte?: Maybe<Scalars['Int']>;
    creationBlock_in?: Maybe<Array<Scalars['Int']>>;
    creationBlock_not_in?: Maybe<Array<Scalars['Int']>>;
    creationTimestamp?: Maybe<Scalars['Int']>;
    creationTimestamp_not?: Maybe<Scalars['Int']>;
    creationTimestamp_gt?: Maybe<Scalars['Int']>;
    creationTimestamp_lt?: Maybe<Scalars['Int']>;
    creationTimestamp_gte?: Maybe<Scalars['Int']>;
    creationTimestamp_lte?: Maybe<Scalars['Int']>;
    creationTimestamp_in?: Maybe<Array<Scalars['Int']>>;
    creationTimestamp_not_in?: Maybe<Array<Scalars['Int']>>;
    escrowState?: Maybe<EscrowState>;
    escrowState_not?: Maybe<EscrowState>;
    escrowState_in?: Maybe<Array<EscrowState>>;
    escrowState_not_in?: Maybe<Array<EscrowState>>;
    tokenAddress?: Maybe<Scalars['Bytes']>;
    tokenAddress_not?: Maybe<Scalars['Bytes']>;
    tokenAddress_gt?: Maybe<Scalars['Bytes']>;
    tokenAddress_lt?: Maybe<Scalars['Bytes']>;
    tokenAddress_gte?: Maybe<Scalars['Bytes']>;
    tokenAddress_lte?: Maybe<Scalars['Bytes']>;
    tokenAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    tokenAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    tokenAddress_contains?: Maybe<Scalars['Bytes']>;
    tokenAddress_not_contains?: Maybe<Scalars['Bytes']>;
    amount?: Maybe<Scalars['BigDecimal']>;
    amount_not?: Maybe<Scalars['BigDecimal']>;
    amount_gt?: Maybe<Scalars['BigDecimal']>;
    amount_lt?: Maybe<Scalars['BigDecimal']>;
    amount_gte?: Maybe<Scalars['BigDecimal']>;
    amount_lte?: Maybe<Scalars['BigDecimal']>;
    amount_in?: Maybe<Array<Scalars['BigDecimal']>>;
    amount_not_in?: Maybe<Array<Scalars['BigDecimal']>>;
    feeAmount?: Maybe<Scalars['BigDecimal']>;
    feeAmount_not?: Maybe<Scalars['BigDecimal']>;
    feeAmount_gt?: Maybe<Scalars['BigDecimal']>;
    feeAmount_lt?: Maybe<Scalars['BigDecimal']>;
    feeAmount_gte?: Maybe<Scalars['BigDecimal']>;
    feeAmount_lte?: Maybe<Scalars['BigDecimal']>;
    feeAmount_in?: Maybe<Array<Scalars['BigDecimal']>>;
    feeAmount_not_in?: Maybe<Array<Scalars['BigDecimal']>>;
    feeAddress?: Maybe<Scalars['Bytes']>;
    feeAddress_not?: Maybe<Scalars['Bytes']>;
    feeAddress_gt?: Maybe<Scalars['Bytes']>;
    feeAddress_lt?: Maybe<Scalars['Bytes']>;
    feeAddress_gte?: Maybe<Scalars['Bytes']>;
    feeAddress_lte?: Maybe<Scalars['Bytes']>;
    feeAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    feeAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    feeAddress_contains?: Maybe<Scalars['Bytes']>;
    feeAddress_not_contains?: Maybe<Scalars['Bytes']>;
    from?: Maybe<Scalars['Bytes']>;
    from_not?: Maybe<Scalars['Bytes']>;
    from_gt?: Maybe<Scalars['Bytes']>;
    from_lt?: Maybe<Scalars['Bytes']>;
    from_gte?: Maybe<Scalars['Bytes']>;
    from_lte?: Maybe<Scalars['Bytes']>;
    from_in?: Maybe<Array<Scalars['Bytes']>>;
    from_not_in?: Maybe<Array<Scalars['Bytes']>>;
    from_contains?: Maybe<Scalars['Bytes']>;
    from_not_contains?: Maybe<Scalars['Bytes']>;
    to?: Maybe<Scalars['Bytes']>;
    to_not?: Maybe<Scalars['Bytes']>;
    to_gt?: Maybe<Scalars['Bytes']>;
    to_lt?: Maybe<Scalars['Bytes']>;
    to_gte?: Maybe<Scalars['Bytes']>;
    to_lte?: Maybe<Scalars['Bytes']>;
    to_in?: Maybe<Array<Scalars['Bytes']>>;
    to_not_in?: Maybe<Array<Scalars['Bytes']>>;
    to_contains?: Maybe<Scalars['Bytes']>;
    to_not_contains?: Maybe<Scalars['Bytes']>;
    events_?: Maybe<EscrowEvent_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<Escrow_Filter>>>;
    or?: Maybe<Array<Maybe<Escrow_Filter>>>;
};
export declare enum Escrow_OrderBy {
    Id = "id",
    ContractAddress = "contractAddress",
    PaymentProxyAddress = "paymentProxyAddress",
    Reference = "reference",
    CreationBlock = "creationBlock",
    CreationTimestamp = "creationTimestamp",
    EscrowState = "escrowState",
    TokenAddress = "tokenAddress",
    Amount = "amount",
    FeeAmount = "feeAmount",
    FeeAddress = "feeAddress",
    From = "from",
    To = "to",
    Events = "events"
}
export declare enum EventName {
    PaidEscrow = "paidEscrow",
    PaidIssuer = "paidIssuer",
    InitiateEmergencyClaim = "initiateEmergencyClaim",
    RevertEmergencyClaim = "revertEmergencyClaim",
    FreezeEscrow = "freezeEscrow"
}
/** Defines the order direction, either ascending or descending */
export declare enum OrderDirection {
    Asc = "asc",
    Desc = "desc"
}
export type Payment = {
    __typename?: 'Payment';
    id: Scalars['ID'];
    contractAddress: Scalars['String'];
    tokenAddress?: Maybe<Scalars['String']>;
    to: Scalars['String'];
    from: Scalars['String'];
    reference: Scalars['String'];
    block: Scalars['Int'];
    timestamp: Scalars['BigInt'];
    txHash?: Maybe<Scalars['String']>;
    receiptId: Scalars['String'];
    gasUsed: Scalars['BigInt'];
    gasPrice: Scalars['BigInt'];
    amount: Scalars['BigDecimal'];
    currency: Scalars['String'];
    feeAmount?: Maybe<Scalars['BigDecimal']>;
    feeAddress?: Maybe<Scalars['String']>;
    amountInCrypto?: Maybe<Scalars['BigDecimal']>;
    feeAmountInCrypto?: Maybe<Scalars['BigDecimal']>;
    maxRateTimespan?: Maybe<Scalars['Int']>;
};
export type Payment_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    contractAddress?: Maybe<Scalars['String']>;
    contractAddress_not?: Maybe<Scalars['String']>;
    contractAddress_gt?: Maybe<Scalars['String']>;
    contractAddress_lt?: Maybe<Scalars['String']>;
    contractAddress_gte?: Maybe<Scalars['String']>;
    contractAddress_lte?: Maybe<Scalars['String']>;
    contractAddress_in?: Maybe<Array<Scalars['String']>>;
    contractAddress_not_in?: Maybe<Array<Scalars['String']>>;
    contractAddress_contains?: Maybe<Scalars['String']>;
    contractAddress_contains_nocase?: Maybe<Scalars['String']>;
    contractAddress_not_contains?: Maybe<Scalars['String']>;
    contractAddress_not_contains_nocase?: Maybe<Scalars['String']>;
    contractAddress_starts_with?: Maybe<Scalars['String']>;
    contractAddress_starts_with_nocase?: Maybe<Scalars['String']>;
    contractAddress_not_starts_with?: Maybe<Scalars['String']>;
    contractAddress_not_starts_with_nocase?: Maybe<Scalars['String']>;
    contractAddress_ends_with?: Maybe<Scalars['String']>;
    contractAddress_ends_with_nocase?: Maybe<Scalars['String']>;
    contractAddress_not_ends_with?: Maybe<Scalars['String']>;
    contractAddress_not_ends_with_nocase?: Maybe<Scalars['String']>;
    tokenAddress?: Maybe<Scalars['String']>;
    tokenAddress_not?: Maybe<Scalars['String']>;
    tokenAddress_gt?: Maybe<Scalars['String']>;
    tokenAddress_lt?: Maybe<Scalars['String']>;
    tokenAddress_gte?: Maybe<Scalars['String']>;
    tokenAddress_lte?: Maybe<Scalars['String']>;
    tokenAddress_in?: Maybe<Array<Scalars['String']>>;
    tokenAddress_not_in?: Maybe<Array<Scalars['String']>>;
    tokenAddress_contains?: Maybe<Scalars['String']>;
    tokenAddress_contains_nocase?: Maybe<Scalars['String']>;
    tokenAddress_not_contains?: Maybe<Scalars['String']>;
    tokenAddress_not_contains_nocase?: Maybe<Scalars['String']>;
    tokenAddress_starts_with?: Maybe<Scalars['String']>;
    tokenAddress_starts_with_nocase?: Maybe<Scalars['String']>;
    tokenAddress_not_starts_with?: Maybe<Scalars['String']>;
    tokenAddress_not_starts_with_nocase?: Maybe<Scalars['String']>;
    tokenAddress_ends_with?: Maybe<Scalars['String']>;
    tokenAddress_ends_with_nocase?: Maybe<Scalars['String']>;
    tokenAddress_not_ends_with?: Maybe<Scalars['String']>;
    tokenAddress_not_ends_with_nocase?: Maybe<Scalars['String']>;
    to?: Maybe<Scalars['String']>;
    to_not?: Maybe<Scalars['String']>;
    to_gt?: Maybe<Scalars['String']>;
    to_lt?: Maybe<Scalars['String']>;
    to_gte?: Maybe<Scalars['String']>;
    to_lte?: Maybe<Scalars['String']>;
    to_in?: Maybe<Array<Scalars['String']>>;
    to_not_in?: Maybe<Array<Scalars['String']>>;
    to_contains?: Maybe<Scalars['String']>;
    to_contains_nocase?: Maybe<Scalars['String']>;
    to_not_contains?: Maybe<Scalars['String']>;
    to_not_contains_nocase?: Maybe<Scalars['String']>;
    to_starts_with?: Maybe<Scalars['String']>;
    to_starts_with_nocase?: Maybe<Scalars['String']>;
    to_not_starts_with?: Maybe<Scalars['String']>;
    to_not_starts_with_nocase?: Maybe<Scalars['String']>;
    to_ends_with?: Maybe<Scalars['String']>;
    to_ends_with_nocase?: Maybe<Scalars['String']>;
    to_not_ends_with?: Maybe<Scalars['String']>;
    to_not_ends_with_nocase?: Maybe<Scalars['String']>;
    from?: Maybe<Scalars['String']>;
    from_not?: Maybe<Scalars['String']>;
    from_gt?: Maybe<Scalars['String']>;
    from_lt?: Maybe<Scalars['String']>;
    from_gte?: Maybe<Scalars['String']>;
    from_lte?: Maybe<Scalars['String']>;
    from_in?: Maybe<Array<Scalars['String']>>;
    from_not_in?: Maybe<Array<Scalars['String']>>;
    from_contains?: Maybe<Scalars['String']>;
    from_contains_nocase?: Maybe<Scalars['String']>;
    from_not_contains?: Maybe<Scalars['String']>;
    from_not_contains_nocase?: Maybe<Scalars['String']>;
    from_starts_with?: Maybe<Scalars['String']>;
    from_starts_with_nocase?: Maybe<Scalars['String']>;
    from_not_starts_with?: Maybe<Scalars['String']>;
    from_not_starts_with_nocase?: Maybe<Scalars['String']>;
    from_ends_with?: Maybe<Scalars['String']>;
    from_ends_with_nocase?: Maybe<Scalars['String']>;
    from_not_ends_with?: Maybe<Scalars['String']>;
    from_not_ends_with_nocase?: Maybe<Scalars['String']>;
    reference?: Maybe<Scalars['String']>;
    reference_not?: Maybe<Scalars['String']>;
    reference_gt?: Maybe<Scalars['String']>;
    reference_lt?: Maybe<Scalars['String']>;
    reference_gte?: Maybe<Scalars['String']>;
    reference_lte?: Maybe<Scalars['String']>;
    reference_in?: Maybe<Array<Scalars['String']>>;
    reference_not_in?: Maybe<Array<Scalars['String']>>;
    reference_contains?: Maybe<Scalars['String']>;
    reference_contains_nocase?: Maybe<Scalars['String']>;
    reference_not_contains?: Maybe<Scalars['String']>;
    reference_not_contains_nocase?: Maybe<Scalars['String']>;
    reference_starts_with?: Maybe<Scalars['String']>;
    reference_starts_with_nocase?: Maybe<Scalars['String']>;
    reference_not_starts_with?: Maybe<Scalars['String']>;
    reference_not_starts_with_nocase?: Maybe<Scalars['String']>;
    reference_ends_with?: Maybe<Scalars['String']>;
    reference_ends_with_nocase?: Maybe<Scalars['String']>;
    reference_not_ends_with?: Maybe<Scalars['String']>;
    reference_not_ends_with_nocase?: Maybe<Scalars['String']>;
    block?: Maybe<Scalars['Int']>;
    block_not?: Maybe<Scalars['Int']>;
    block_gt?: Maybe<Scalars['Int']>;
    block_lt?: Maybe<Scalars['Int']>;
    block_gte?: Maybe<Scalars['Int']>;
    block_lte?: Maybe<Scalars['Int']>;
    block_in?: Maybe<Array<Scalars['Int']>>;
    block_not_in?: Maybe<Array<Scalars['Int']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    txHash?: Maybe<Scalars['String']>;
    txHash_not?: Maybe<Scalars['String']>;
    txHash_gt?: Maybe<Scalars['String']>;
    txHash_lt?: Maybe<Scalars['String']>;
    txHash_gte?: Maybe<Scalars['String']>;
    txHash_lte?: Maybe<Scalars['String']>;
    txHash_in?: Maybe<Array<Scalars['String']>>;
    txHash_not_in?: Maybe<Array<Scalars['String']>>;
    txHash_contains?: Maybe<Scalars['String']>;
    txHash_contains_nocase?: Maybe<Scalars['String']>;
    txHash_not_contains?: Maybe<Scalars['String']>;
    txHash_not_contains_nocase?: Maybe<Scalars['String']>;
    txHash_starts_with?: Maybe<Scalars['String']>;
    txHash_starts_with_nocase?: Maybe<Scalars['String']>;
    txHash_not_starts_with?: Maybe<Scalars['String']>;
    txHash_not_starts_with_nocase?: Maybe<Scalars['String']>;
    txHash_ends_with?: Maybe<Scalars['String']>;
    txHash_ends_with_nocase?: Maybe<Scalars['String']>;
    txHash_not_ends_with?: Maybe<Scalars['String']>;
    txHash_not_ends_with_nocase?: Maybe<Scalars['String']>;
    receiptId?: Maybe<Scalars['String']>;
    receiptId_not?: Maybe<Scalars['String']>;
    receiptId_gt?: Maybe<Scalars['String']>;
    receiptId_lt?: Maybe<Scalars['String']>;
    receiptId_gte?: Maybe<Scalars['String']>;
    receiptId_lte?: Maybe<Scalars['String']>;
    receiptId_in?: Maybe<Array<Scalars['String']>>;
    receiptId_not_in?: Maybe<Array<Scalars['String']>>;
    receiptId_contains?: Maybe<Scalars['String']>;
    receiptId_contains_nocase?: Maybe<Scalars['String']>;
    receiptId_not_contains?: Maybe<Scalars['String']>;
    receiptId_not_contains_nocase?: Maybe<Scalars['String']>;
    receiptId_starts_with?: Maybe<Scalars['String']>;
    receiptId_starts_with_nocase?: Maybe<Scalars['String']>;
    receiptId_not_starts_with?: Maybe<Scalars['String']>;
    receiptId_not_starts_with_nocase?: Maybe<Scalars['String']>;
    receiptId_ends_with?: Maybe<Scalars['String']>;
    receiptId_ends_with_nocase?: Maybe<Scalars['String']>;
    receiptId_not_ends_with?: Maybe<Scalars['String']>;
    receiptId_not_ends_with_nocase?: Maybe<Scalars['String']>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    amount?: Maybe<Scalars['BigDecimal']>;
    amount_not?: Maybe<Scalars['BigDecimal']>;
    amount_gt?: Maybe<Scalars['BigDecimal']>;
    amount_lt?: Maybe<Scalars['BigDecimal']>;
    amount_gte?: Maybe<Scalars['BigDecimal']>;
    amount_lte?: Maybe<Scalars['BigDecimal']>;
    amount_in?: Maybe<Array<Scalars['BigDecimal']>>;
    amount_not_in?: Maybe<Array<Scalars['BigDecimal']>>;
    currency?: Maybe<Scalars['String']>;
    currency_not?: Maybe<Scalars['String']>;
    currency_gt?: Maybe<Scalars['String']>;
    currency_lt?: Maybe<Scalars['String']>;
    currency_gte?: Maybe<Scalars['String']>;
    currency_lte?: Maybe<Scalars['String']>;
    currency_in?: Maybe<Array<Scalars['String']>>;
    currency_not_in?: Maybe<Array<Scalars['String']>>;
    currency_contains?: Maybe<Scalars['String']>;
    currency_contains_nocase?: Maybe<Scalars['String']>;
    currency_not_contains?: Maybe<Scalars['String']>;
    currency_not_contains_nocase?: Maybe<Scalars['String']>;
    currency_starts_with?: Maybe<Scalars['String']>;
    currency_starts_with_nocase?: Maybe<Scalars['String']>;
    currency_not_starts_with?: Maybe<Scalars['String']>;
    currency_not_starts_with_nocase?: Maybe<Scalars['String']>;
    currency_ends_with?: Maybe<Scalars['String']>;
    currency_ends_with_nocase?: Maybe<Scalars['String']>;
    currency_not_ends_with?: Maybe<Scalars['String']>;
    currency_not_ends_with_nocase?: Maybe<Scalars['String']>;
    feeAmount?: Maybe<Scalars['BigDecimal']>;
    feeAmount_not?: Maybe<Scalars['BigDecimal']>;
    feeAmount_gt?: Maybe<Scalars['BigDecimal']>;
    feeAmount_lt?: Maybe<Scalars['BigDecimal']>;
    feeAmount_gte?: Maybe<Scalars['BigDecimal']>;
    feeAmount_lte?: Maybe<Scalars['BigDecimal']>;
    feeAmount_in?: Maybe<Array<Scalars['BigDecimal']>>;
    feeAmount_not_in?: Maybe<Array<Scalars['BigDecimal']>>;
    feeAddress?: Maybe<Scalars['String']>;
    feeAddress_not?: Maybe<Scalars['String']>;
    feeAddress_gt?: Maybe<Scalars['String']>;
    feeAddress_lt?: Maybe<Scalars['String']>;
    feeAddress_gte?: Maybe<Scalars['String']>;
    feeAddress_lte?: Maybe<Scalars['String']>;
    feeAddress_in?: Maybe<Array<Scalars['String']>>;
    feeAddress_not_in?: Maybe<Array<Scalars['String']>>;
    feeAddress_contains?: Maybe<Scalars['String']>;
    feeAddress_contains_nocase?: Maybe<Scalars['String']>;
    feeAddress_not_contains?: Maybe<Scalars['String']>;
    feeAddress_not_contains_nocase?: Maybe<Scalars['String']>;
    feeAddress_starts_with?: Maybe<Scalars['String']>;
    feeAddress_starts_with_nocase?: Maybe<Scalars['String']>;
    feeAddress_not_starts_with?: Maybe<Scalars['String']>;
    feeAddress_not_starts_with_nocase?: Maybe<Scalars['String']>;
    feeAddress_ends_with?: Maybe<Scalars['String']>;
    feeAddress_ends_with_nocase?: Maybe<Scalars['String']>;
    feeAddress_not_ends_with?: Maybe<Scalars['String']>;
    feeAddress_not_ends_with_nocase?: Maybe<Scalars['String']>;
    amountInCrypto?: Maybe<Scalars['BigDecimal']>;
    amountInCrypto_not?: Maybe<Scalars['BigDecimal']>;
    amountInCrypto_gt?: Maybe<Scalars['BigDecimal']>;
    amountInCrypto_lt?: Maybe<Scalars['BigDecimal']>;
    amountInCrypto_gte?: Maybe<Scalars['BigDecimal']>;
    amountInCrypto_lte?: Maybe<Scalars['BigDecimal']>;
    amountInCrypto_in?: Maybe<Array<Scalars['BigDecimal']>>;
    amountInCrypto_not_in?: Maybe<Array<Scalars['BigDecimal']>>;
    feeAmountInCrypto?: Maybe<Scalars['BigDecimal']>;
    feeAmountInCrypto_not?: Maybe<Scalars['BigDecimal']>;
    feeAmountInCrypto_gt?: Maybe<Scalars['BigDecimal']>;
    feeAmountInCrypto_lt?: Maybe<Scalars['BigDecimal']>;
    feeAmountInCrypto_gte?: Maybe<Scalars['BigDecimal']>;
    feeAmountInCrypto_lte?: Maybe<Scalars['BigDecimal']>;
    feeAmountInCrypto_in?: Maybe<Array<Scalars['BigDecimal']>>;
    feeAmountInCrypto_not_in?: Maybe<Array<Scalars['BigDecimal']>>;
    maxRateTimespan?: Maybe<Scalars['Int']>;
    maxRateTimespan_not?: Maybe<Scalars['Int']>;
    maxRateTimespan_gt?: Maybe<Scalars['Int']>;
    maxRateTimespan_lt?: Maybe<Scalars['Int']>;
    maxRateTimespan_gte?: Maybe<Scalars['Int']>;
    maxRateTimespan_lte?: Maybe<Scalars['Int']>;
    maxRateTimespan_in?: Maybe<Array<Scalars['Int']>>;
    maxRateTimespan_not_in?: Maybe<Array<Scalars['Int']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<Payment_Filter>>>;
    or?: Maybe<Array<Maybe<Payment_Filter>>>;
};
export declare enum Payment_OrderBy {
    Id = "id",
    ContractAddress = "contractAddress",
    TokenAddress = "tokenAddress",
    To = "to",
    From = "from",
    Reference = "reference",
    Block = "block",
    Timestamp = "timestamp",
    TxHash = "txHash",
    ReceiptId = "receiptId",
    GasUsed = "gasUsed",
    GasPrice = "gasPrice",
    Amount = "amount",
    Currency = "currency",
    FeeAmount = "feeAmount",
    FeeAddress = "feeAddress",
    AmountInCrypto = "amountInCrypto",
    FeeAmountInCrypto = "feeAmountInCrypto",
    MaxRateTimespan = "maxRateTimespan"
}
export type Query = {
    __typename?: 'Query';
    payment?: Maybe<Payment>;
    payments: Array<Payment>;
    escrow?: Maybe<Escrow>;
    escrows: Array<Escrow>;
    escrowEvent?: Maybe<EscrowEvent>;
    escrowEvents: Array<EscrowEvent>;
    /** Access to subgraph metadata */
    _meta?: Maybe<_Meta_>;
};
export type QueryPaymentArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryPaymentsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Payment_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Payment_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryEscrowArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryEscrowsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Escrow_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Escrow_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryEscrowEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryEscrowEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<EscrowEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<EscrowEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type Query_MetaArgs = {
    block?: Maybe<Block_Height>;
};
export type Subscription = {
    __typename?: 'Subscription';
    payment?: Maybe<Payment>;
    payments: Array<Payment>;
    escrow?: Maybe<Escrow>;
    escrows: Array<Escrow>;
    escrowEvent?: Maybe<EscrowEvent>;
    escrowEvents: Array<EscrowEvent>;
    /** Access to subgraph metadata */
    _meta?: Maybe<_Meta_>;
};
export type SubscriptionPaymentArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionPaymentsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Payment_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Payment_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionEscrowArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionEscrowsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Escrow_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Escrow_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionEscrowEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionEscrowEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<EscrowEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<EscrowEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type Subscription_MetaArgs = {
    block?: Maybe<Block_Height>;
};
export type _Block_ = {
    __typename?: '_Block_';
    /** The hash of the block */
    hash?: Maybe<Scalars['Bytes']>;
    /** The block number */
    number: Scalars['Int'];
    /** Integer representation of the timestamp stored in blocks for the chain */
    timestamp?: Maybe<Scalars['Int']>;
};
/** The type for the top-level _meta field */
export type _Meta_ = {
    __typename?: '_Meta_';
    /**
     * Information about a specific subgraph block. The hash of the block
     * will be null if the _meta field has a block constraint that asks for
     * a block number. It will be filled if the _meta field has no block constraint
     * and therefore asks for the latest  block
     */
    block: _Block_;
    /** The deployment ID */
    deployment: Scalars['String'];
    /** If `true`, the subgraph encountered indexing errors at some past block */
    hasIndexingErrors: Scalars['Boolean'];
};
export declare enum _SubgraphErrorPolicy_ {
    /** Data will be returned even if the subgraph has indexing errors */
    Allow = "allow",
    /** If the subgraph has indexing errors, data will be omitted. The default. */
    Deny = "deny"
}
export type GetAnyToNativePaymentsQueryVariables = Exact<{
    reference: Scalars['String'];
    to: Scalars['String'];
    currency: Scalars['String'];
    maxRateTimespan: Scalars['Int'];
    contractAddress: Scalars['String'];
}>;
export type GetAnyToNativePaymentsQuery = ({
    __typename?: 'Query';
} & {
    payments: Array<({
        __typename?: 'Payment';
    } & Pick<Payment, 'amount' | 'block' | 'receiptId' | 'feeAmount' | 'feeAddress' | 'from' | 'timestamp' | 'currency' | 'gasPrice' | 'gasUsed' | 'maxRateTimespan' | 'amountInCrypto' | 'feeAmountInCrypto'>)>;
});
export type NearPaymentEventResultFragment = ({
    __typename?: 'Payment';
} & Pick<Payment, 'amount' | 'block' | 'receiptId' | 'txHash' | 'feeAmount' | 'feeAddress' | 'from' | 'gasUsed' | 'gasPrice' | 'timestamp' | 'contractAddress' | 'to' | 'tokenAddress' | 'currency' | 'amountInCrypto' | 'feeAmountInCrypto' | 'maxRateTimespan'>);
export type GetFungibleTokenPaymentsQueryVariables = Exact<{
    reference: Scalars['String'];
    to: Scalars['String'];
    contractAddress: Scalars['String'];
    tokenAddress: Scalars['String'];
}>;
export type GetFungibleTokenPaymentsQuery = ({
    __typename?: 'Query';
} & {
    payments: Array<({
        __typename?: 'Payment';
    } & NearPaymentEventResultFragment)>;
});
export type GetNearPaymentsQueryVariables = Exact<{
    reference: Scalars['String'];
    to: Scalars['String'];
    contractAddress: Scalars['String'];
}>;
export type GetNearPaymentsQuery = ({
    __typename?: 'Query';
} & {
    payments: Array<({
        __typename?: 'Payment';
    } & Pick<Payment, 'amount' | 'currency' | 'block' | 'receiptId' | 'feeAmount' | 'feeAddress' | 'from' | 'timestamp' | 'gasPrice' | 'gasUsed'>)>;
});
export declare const NearPaymentEventResultFragmentDoc: import("graphql/language/ast").DocumentNode;
export declare const GetAnyToNativePaymentsDocument: import("graphql/language/ast").DocumentNode;
export declare const GetFungibleTokenPaymentsDocument: import("graphql/language/ast").DocumentNode;
export declare const GetNearPaymentsDocument: import("graphql/language/ast").DocumentNode;
export type SdkFunctionWrapper = <T>(action: (requestHeaders?: Record<string, string>) => Promise<T>, operationName: string) => Promise<T>;
export declare function getSdk(client: GraphQLClient, withWrapper?: SdkFunctionWrapper): {
    GetAnyToNativePayments(variables: GetAnyToNativePaymentsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetAnyToNativePaymentsQuery>;
    GetFungibleTokenPayments(variables: GetFungibleTokenPaymentsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetFungibleTokenPaymentsQuery>;
    GetNearPayments(variables: GetNearPaymentsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetNearPaymentsQuery>;
};
export type Sdk = ReturnType<typeof getSdk>;
export declare const NearPaymentEventResult: import("graphql/language/ast").DocumentNode;
export declare const GetAnyToNativePayments: import("graphql/language/ast").DocumentNode;
export declare const GetFungibleTokenPayments: import("graphql/language/ast").DocumentNode;
export declare const GetNearPayments: import("graphql/language/ast").DocumentNode;
//# sourceMappingURL=graphql-near.d.ts.map