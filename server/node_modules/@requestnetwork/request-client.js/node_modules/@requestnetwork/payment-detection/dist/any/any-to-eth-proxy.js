"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnyToEthFeeProxyPaymentDetector = void 0;
const tslib_1 = require("tslib");
const SmartContracts = require("@requestnetwork/smart-contracts");
const types_1 = require("@requestnetwork/types");
const currency_1 = require("@requestnetwork/currency");
const any_to_eth_proxy_1 = require("./retrievers/any-to-eth-proxy");
const any_to_any_detector_1 = require("../any-to-any-detector");
const utils_1 = require("../utils");
const conversion_info_retriever_1 = require("../thegraph/conversion-info-retriever");
const PROXY_CONTRACT_ADDRESS_MAP = {
    ['0.1.0']: '0.1.0',
    ['0.2.0']: '0.2.0',
};
/**
 * Handle payment networks with ETH input data extension
 */
class AnyToEthFeeProxyPaymentDetector extends any_to_any_detector_1.AnyToAnyDetector {
    /**
     * @param extension The advanced logic payment network extensions
     */
    constructor({ advancedLogic, currencyManager, getSubgraphClient, }) {
        super(types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ETH_PROXY, advancedLogic.extensions.anyToEthProxy, currencyManager);
        this.getSubgraphClient = getSubgraphClient;
    }
    /**
     * Extracts payment events of an address matching an address and a payment reference
     *
     * @param toAddress Address to check
     * @param eventName Indicate if it is an address for payment or refund
     * @param requestCurrency The request currency
     * @param paymentReference The reference to identify the payment
     * @param paymentNetwork the payment network
     * @returns The balance
     */
    extractEvents(eventName, toAddress, paymentReference, requestCurrency, paymentChain, paymentNetwork) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!toAddress) {
                return {
                    paymentEvents: [],
                };
            }
            const contractInfo = AnyToEthFeeProxyPaymentDetector.getDeploymentInformation(paymentChain, paymentNetwork.version);
            const currency = this.currencyManager.fromStorageCurrency(requestCurrency);
            if (!currency) {
                throw new currency_1.UnsupportedCurrencyError(requestCurrency.value);
            }
            const subgraphClient = this.getSubgraphClient(paymentChain);
            if (subgraphClient) {
                const infoRetriever = new conversion_info_retriever_1.TheGraphConversionInfoRetriever(subgraphClient, this.currencyManager);
                return yield infoRetriever.getTransferEvents({
                    paymentReference,
                    contractAddress: contractInfo.address,
                    toAddress,
                    eventName,
                    paymentChain,
                    maxRateTimespan: (_a = paymentNetwork.values) === null || _a === void 0 ? void 0 : _a.maxRateTimespan,
                    requestCurrency: currency,
                });
            }
            const abi = SmartContracts.ethConversionArtifact.getContractAbi(contractInfo.contractVersion);
            const infoRetriever = new any_to_eth_proxy_1.AnyToEthInfoRetriever(currency, paymentReference, contractInfo.address, contractInfo.creationBlockNumber, abi, toAddress, eventName, paymentChain, undefined, (_b = paymentNetwork.values) === null || _b === void 0 ? void 0 : _b.maxRateTimespan);
            const paymentEvents = yield infoRetriever.getTransferEvents();
            return {
                paymentEvents,
            };
        });
    }
    /**
     * Get the network of the payment
     *
     * @param requestCurrency The request currency
     * @param paymentNetwork the payment network
     * @returns The network of payment
     */
    getPaymentChain(request) {
        const network = this.getPaymentExtension(request).values.network;
        if (!network) {
            throw Error(`request.extensions[${this.paymentNetworkId}].values.network must be defined`);
        }
        currency_1.EvmChains.assertChainSupported(network);
        return network;
    }
}
exports.AnyToEthFeeProxyPaymentDetector = AnyToEthFeeProxyPaymentDetector;
/*
 * Returns deployment information for the underlying smart contract for a given payment network version
 */
AnyToEthFeeProxyPaymentDetector.getDeploymentInformation = (0, utils_1.makeGetDeploymentInformation)(SmartContracts.ethConversionArtifact, PROXY_CONTRACT_ADDRESS_MAP);
//# sourceMappingURL=any-to-eth-proxy.js.map