"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERC20FeeProxyPaymentDetector = exports.ERC20FeeProxyPaymentDetectorBase = void 0;
const tslib_1 = require("tslib");
const smart_contracts_1 = require("@requestnetwork/smart-contracts");
const types_1 = require("@requestnetwork/types");
const currency_1 = require("@requestnetwork/currency");
const proxy_info_retriever_1 = require("./proxy-info-retriever");
const currency_2 = require("./currency");
const fee_reference_based_detector_1 = require("../fee-reference-based-detector");
const utils_1 = require("../utils");
const thegraph_1 = require("../thegraph");
const near_1 = require("../near");
const balance_error_1 = require("../balance-error");
const PROXY_CONTRACT_ADDRESS_MAP = {
    ['0.1.0']: '0.1.0',
    ['0.2.0']: '0.2.0',
    ['NEAR-0.1.0']: 'near',
};
/**
 * Handle payment networks with ERC20 fee proxy contract extension, or derived
 */
class ERC20FeeProxyPaymentDetectorBase extends fee_reference_based_detector_1.FeeReferenceBasedDetector {
    /**
     * @param extension The advanced logic payment network extensions
     */
    constructor(paymentNetworkId, extension, currencyManager) {
        super(paymentNetworkId, extension, currencyManager);
    }
    getCurrency(storageCurrency) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const currency = this.currencyManager.fromStorageCurrency(storageCurrency);
            if (currency) {
                return currency;
            }
            if (storageCurrency.type !== types_1.RequestLogicTypes.CURRENCY.ERC20) {
                throw new Error(`Currency ${storageCurrency.value} not known`);
            }
            const contractCurrency = yield (0, currency_2.loadCurrencyFromContract)(storageCurrency);
            if (!contractCurrency) {
                throw new Error(`Cannot retrieve currency for contrat ${storageCurrency.value} (${storageCurrency.network})`);
            }
            return contractCurrency;
        });
    }
}
exports.ERC20FeeProxyPaymentDetectorBase = ERC20FeeProxyPaymentDetectorBase;
/*
 * Returns deployment information for the underlying smart contract for a given payment network version
 */
ERC20FeeProxyPaymentDetectorBase.getDeploymentInformation = (0, utils_1.makeGetDeploymentInformation)(smart_contracts_1.erc20FeeProxyArtifact, PROXY_CONTRACT_ADDRESS_MAP);
/**
 * Handle payment networks with ERC20 fee proxy contract extension on EVM (default) or Near chains
 */
class ERC20FeeProxyPaymentDetector extends ERC20FeeProxyPaymentDetectorBase {
    constructor({ advancedLogic, currencyManager, getSubgraphClient, network, }) {
        var _a;
        super(types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT, (_a = advancedLogic.getFeeProxyContractErc20ForNetwork(network)) !== null && _a !== void 0 ? _a : advancedLogic.extensions.feeProxyContractErc20, currencyManager);
        this.getSubgraphClient = getSubgraphClient;
        this.network = network;
    }
    /**
     * Extracts the payment events of a request
     */
    extractEvents(eventName, toAddress, paymentReference, requestCurrency, paymentChain, paymentNetwork) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.network && !(0, currency_1.isSameChain)(paymentChain, this.network)) {
                throw new balance_error_1.NetworkNotSupported(`Unsupported network '${paymentChain}' for payment detector instanciated with '${this.network}'`);
            }
            if (!toAddress) {
                return Promise.resolve({
                    paymentEvents: [],
                });
            }
            const { address: proxyContractAddress, creationBlockNumber: proxyCreationBlockNumber } = ERC20FeeProxyPaymentDetector.getDeploymentInformation(paymentChain, paymentNetwork.version);
            const subgraphClient = this.getSubgraphClient(paymentChain);
            if (subgraphClient) {
                const graphInfoRetriever = this.getTheGraphInfoRetriever(paymentChain, subgraphClient);
                return graphInfoRetriever.getTransferEvents({
                    eventName,
                    paymentReference,
                    toAddress,
                    contractAddress: proxyContractAddress,
                    paymentChain,
                    acceptedTokens: [requestCurrency.value],
                });
            }
            else {
                if (!currency_1.EvmChains.isChainSupported(paymentChain)) {
                    throw new Error(`Could not get a TheGraph-based info retriever for chain ${paymentChain} and RPC-based info retrievers are only compatible with EVM chains.`);
                }
                const proxyInfoRetriever = new proxy_info_retriever_1.default(paymentReference, proxyContractAddress, proxyCreationBlockNumber, requestCurrency.value, toAddress, eventName, paymentChain);
                const paymentEvents = yield proxyInfoRetriever.getTransferEvents();
                return {
                    paymentEvents,
                };
            }
        });
    }
    getTheGraphInfoRetriever(paymentChain, subgraphClient) {
        const graphInfoRetriever = currency_1.EvmChains.isChainSupported(paymentChain)
            ? new thegraph_1.TheGraphInfoRetriever(subgraphClient, this.currencyManager)
            : currency_1.NearChains.isChainSupported(paymentChain) && this.network
                ? new near_1.NearInfoRetriever(subgraphClient)
                : undefined;
        if (!graphInfoRetriever) {
            throw new Error(`Could not find graphInfoRetriever for chain ${paymentChain} in payment detector`);
        }
        return graphInfoRetriever;
    }
}
exports.ERC20FeeProxyPaymentDetector = ERC20FeeProxyPaymentDetector;
//# sourceMappingURL=fee-proxy-contract.js.map