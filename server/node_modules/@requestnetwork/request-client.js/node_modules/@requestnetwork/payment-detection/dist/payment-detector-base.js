"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaymentDetectorBase = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const types_1 = require("@requestnetwork/types");
const balance_error_1 = require("./balance-error");
class PaymentDetectorBase {
    constructor(paymentNetworkId, extension) {
        this.paymentNetworkId = paymentNetworkId;
        this.extension = extension;
    }
    /**
     * Gets the balance and the payment/refund events
     *
     * @param request the request to check
     * @returns the balance and the payment/refund events
     */
    getBalance(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const allNetworkEvents = yield this.getEvents(request);
                const rawPaymentEvents = allNetworkEvents.paymentEvents;
                const events = this.sortEvents(rawPaymentEvents);
                const balance = this.computeBalance(events).toString();
                const escrowEvents = this.sortEscrowEvents(allNetworkEvents.escrowEvents || []);
                return {
                    balance,
                    events,
                    escrowEvents,
                };
            }
            catch (error) {
                return (0, balance_error_1.getBalanceErrorObject)(error);
            }
        });
    }
    getPaymentExtension(request) {
        const extension = request.extensions[this.paymentNetworkId];
        if (!extension) {
            throw new balance_error_1.BalanceError(`The request does not have the extension: ${this.paymentNetworkId}`, types_1.PaymentTypes.BALANCE_ERROR_CODE.WRONG_EXTENSION);
        }
        return extension;
    }
    computeBalance(events) {
        return events.reduce((sum, curr) => curr.name === types_1.PaymentTypes.EVENTS_NAMES.PAYMENT
            ? sum.add(curr.amount)
            : curr.name === types_1.PaymentTypes.EVENTS_NAMES.REFUND
                ? sum.sub(curr.amount)
                : sum, ethers_1.BigNumber.from(0));
    }
    sortEvents(events) {
        return events.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
    }
    sortEscrowEvents(events) {
        return events.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
    }
    checkRequiredParameter(value, name) {
        if (!value) {
            throw new balance_error_1.ExtensionMissingRequiredValue(this.paymentNetworkId, name);
        }
    }
}
exports.PaymentDetectorBase = PaymentDetectorBase;
//# sourceMappingURL=payment-detector-base.js.map