"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const utils_1 = require("../utils");
const utils_2 = require("@requestnetwork/utils");
// The ERC20 proxy smart contract ABI fragment containing TransferWithReference event
const erc20proxyContractAbiFragment = [
    'event TransferWithReference(address tokenAddress,address to,uint256 amount,bytes indexed paymentReference)',
    'event TransferWithReferenceAndFee(address tokenAddress, address to,uint256 amount,bytes indexed paymentReference,uint256 feeAmount,address feeAddress)',
];
/**
 * Retrieves a list of payment events from a payment reference, a destination address, a token address and a proxy contract
 */
class ProxyERC20InfoRetriever {
    /**
     * @param paymentReference The reference to identify the payment
     * @param proxyContractAddress The address of the proxy contract
     * @param proxyCreationBlockNumber The block that created the proxy contract
     * @param tokenContractAddress The address of the ERC20 contract
     * @param toAddress Address of the balance we want to check
     * @param eventName Indicate if it is an address for payment or refund
     * @param network The Ethereum network to use
     */
    constructor(paymentReference, proxyContractAddress, proxyCreationBlockNumber, tokenContractAddress, toAddress, eventName, network) {
        this.paymentReference = paymentReference;
        this.proxyContractAddress = proxyContractAddress;
        this.proxyCreationBlockNumber = proxyCreationBlockNumber;
        this.tokenContractAddress = tokenContractAddress;
        this.toAddress = toAddress;
        this.eventName = eventName;
        this.network = network;
        // Creates a local or default provider
        this.provider = (0, utils_2.getDefaultProvider)(this.network);
        // Set up the ERC20 proxy contract interface
        this.contractProxy = new ethers_1.ethers.Contract(this.proxyContractAddress, erc20proxyContractAbiFragment, this.provider);
    }
    /**
     * Retrieves transfer events for the current contract, address and network.
     * @param isTransferable Whether or not the request is expected to be paid
     * through a receivable proxy contract
     */
    getTransferEvents(isTransferable = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create a filter to find all the Transfer logs for the toAddress
            const filter = this.contractProxy.filters.TransferWithReference(null, null, null, '0x' + this.paymentReference);
            filter.fromBlock = this.proxyCreationBlockNumber;
            filter.toBlock = 'latest';
            // Get the proxy contract event logs
            const proxyLogs = yield this.provider.getLogs(filter);
            // Create a filter to find all the Fee Transfer logs with the payment reference
            const feeFilter = this.contractProxy.filters.TransferWithReferenceAndFee(null, null, null, '0x' + this.paymentReference, null, null);
            feeFilter.fromBlock = this.proxyCreationBlockNumber;
            feeFilter.toBlock = 'latest';
            // Get the fee proxy contract event logs
            const feeProxyLogs = yield this.provider.getLogs(feeFilter);
            // Merge both events
            const logs = [...proxyLogs, ...feeProxyLogs];
            // Parses, filters and creates the events from the logs with the payment reference
            const eventPromises = logs
                // Parses the logs
                .map((log) => {
                const parsedLog = this.contractProxy.interface.parseLog(log);
                return {
                    parsedLog: (0, utils_1.parseLogArgs)(parsedLog),
                    blockNumber: log.blockNumber,
                    transactionHash: log.transactionHash,
                };
            })
                // Keeps only the log with the right token and the right destination address
                .filter(({ parsedLog }) => parsedLog.tokenAddress.toLowerCase() === this.tokenContractAddress.toLowerCase() &&
                (isTransferable || parsedLog.to.toLowerCase() === this.toAddress.toLowerCase()))
                // Creates the balance events
                .map(({ parsedLog, blockNumber, transactionHash }) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                var _a;
                return ({
                    amount: parsedLog.amount.toString(),
                    name: this.eventName,
                    parameters: {
                        block: blockNumber,
                        feeAddress: parsedLog.feeAddress || undefined,
                        feeAmount: ((_a = parsedLog.feeAmount) === null || _a === void 0 ? void 0 : _a.toString()) || undefined,
                        to: parsedLog.to,
                        txHash: transactionHash,
                    },
                    timestamp: (yield this.provider.getBlock(blockNumber || 0)).timestamp,
                });
            }));
            return Promise.all(eventPromises);
        });
    }
}
exports.default = ProxyERC20InfoRetriever;
//# sourceMappingURL=proxy-info-retriever.js.map