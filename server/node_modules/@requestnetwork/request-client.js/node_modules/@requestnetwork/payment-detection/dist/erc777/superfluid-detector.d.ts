import { CurrencyTypes, ExtensionTypes, PaymentTypes, RequestLogicTypes } from '@requestnetwork/types';
import { ReferenceBasedDetector } from '../reference-based-detector';
import { ReferenceBasedDetectorOptions } from '../types';
/**
 * Handle payment networks with ERC777 Superfluid streaming extension
 */
export declare class SuperFluidPaymentDetector extends ReferenceBasedDetector<ExtensionTypes.PnReferenceBased.IReferenceBased, PaymentTypes.IERC777PaymentEventParameters> {
    /**
     * @param extension The advanced logic payment network extensions
     */
    constructor({ advancedLogic, currencyManager }: ReferenceBasedDetectorOptions);
    protected isSubsequentRequest(request: RequestLogicTypes.IRequest): boolean;
    /**
     * This returns the specific values we store for the ERC777 extensions.
     * @param request The request we are processing
     */
    protected getSubsequentValues(request: RequestLogicTypes.IRequest): ExtensionTypes.PnStreamReferenceBased.ISubsequentRequestCreationParameters;
    /**
     * With streaming requests we have a custom balance computation.
     * It is possible to have only one streaming event, start stream,
     * but have 10 requests being created each month for the same stream.
     * For the original request, the first one, the balance computation is easy because we don't care about previous expected balance.
     * For subsequent requests we must take into consideration how many requests were before this one and then attribute the rest of the balance to this one.
     * At this point we are not detecting overpayment because in case of overpayment we are considering that another request should have been created in the series.
     * @param request The request we are calculating balance for
     * @returns Balance object with balance value and payment/refund events
     */
    getBalance(request: RequestLogicTypes.IRequest): Promise<PaymentTypes.IBalanceWithEvents<PaymentTypes.IERC777PaymentEventParameters | PaymentTypes.IDeclarativePaymentEventParameters>>;
    /**
     * Extracts payment events of an address matching an address and a payment reference
     *
     * @param eventName Indicate if it is an address for payment or refund
     * @param address Address to check
     * @param paymentReference The reference to identify the payment
     * @param requestCurrency The request currency
     * @param paymentChain the payment network
     * @returns List of payment events
     */
    protected extractEvents(eventName: PaymentTypes.EVENTS_NAMES, address: string | undefined, paymentReference: string, requestCurrency: RequestLogicTypes.ICurrency, paymentChain: CurrencyTypes.EvmChainName): Promise<PaymentTypes.AllNetworkEvents<PaymentTypes.IERC777PaymentEventParameters>>;
    /**
     * In the case of the first, original request that starts the streaming,
     * we calculate the payment reference from its own data: requestId, salt, paymentAddress.
     * In the case of subsequent requests we need to have the same payment reference from the original request,
     * so we need to use the original requests requestId, which we have stored in
     * extension values as originalRequestId, the salt and paymentAddress are the same.
     * @param request The request we need payment reference for
     * @returns The payment reference
     */
    protected getPaymentReference(request: RequestLogicTypes.IRequest): string;
}
//# sourceMappingURL=superfluid-detector.d.ts.map