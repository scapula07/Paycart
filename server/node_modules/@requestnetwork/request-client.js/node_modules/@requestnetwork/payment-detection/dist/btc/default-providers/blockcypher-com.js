"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockcypherComProvider = void 0;
const tslib_1 = require("tslib");
const axios_1 = require("axios");
const ethers_1 = require("ethers");
const utils_1 = require("@requestnetwork/utils");
// Maximum number of api requests to retry when an error is encountered (ECONNRESET, EPIPE, ENOTFOUND)
const BLOCKCYPHER_REQUEST_MAX_RETRY = 3;
// Delay between retries in ms
const BLOCKCYPHER_REQUEST_RETRY_DELAY = 100;
/**
 * The Bitcoin Info retriever give access to the bitcoin blockchain through the api of blockcypher.com
 */
class BlockcypherComProvider {
    /**
     * Gets BTC address info using blockcypher.com public API
     *
     * @param bitcoinNetworkId The Bitcoin network ID: 0 (mainnet) or 3 (testnet)
     * @param address BTC address to check
     * @param eventName Indicates if it is an address for payment or refund
     * @returns Object containing address info
     */
    getAddressBalanceWithEvents(bitcoinNetworkId, address, eventName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const baseUrl = this.getBaseUrl(bitcoinNetworkId);
            const queryUrl = `${baseUrl}/addrs/${address}`;
            try {
                const res = yield (0, utils_1.retry)(() => tslib_1.__awaiter(this, void 0, void 0, function* () { return axios_1.default.get(queryUrl); }), {
                    maxRetries: BLOCKCYPHER_REQUEST_MAX_RETRY,
                    retryDelay: BLOCKCYPHER_REQUEST_RETRY_DELAY,
                })();
                // eslint-disable-next-line no-magic-numbers
                if (res.status >= 400) {
                    throw new Error(`Error ${res.status}. Bad response from server ${queryUrl}`);
                }
                const addressInfo = yield res.data;
                return this.parse(addressInfo, eventName);
            }
            catch (err) {
                // eslint-disable-next-line no-console
                console.warn(err.message || err);
                return { balance: '-1', events: [] };
            }
        });
    }
    /**
     * Parses the address information from the data of blockcypher.com
     *
     * @param addressInfo Data of blockchain.info
     * @param eventName Indicates if it is an address for payment or refund
     * @returns Balance with events
     */
    parse(addressInfo, eventName) {
        const balance = ethers_1.BigNumber.from(addressInfo.total_received).toString();
        // Retrieves all the transaction hash of the transactions having as input the current address
        const inputTxHashes = addressInfo.txrefs
            .filter((tx) => tx.tx_output_n === -1)
            .map((tx) => tx.tx_hash);
        const events = addressInfo.txrefs
            // keep only the transaction with this address as output
            .filter((tx) => tx.tx_input_n === -1)
            // exclude the transactions coming from the same address
            .filter((tx) => !inputTxHashes.includes(tx.tx_hash))
            .map((tx) => ({
            amount: tx.value.toString(),
            name: eventName,
            parameters: {
                block: tx.block_height,
                txHash: tx.tx_hash,
            },
            // timestamp - not given by this API
        }));
        return { balance, events };
    }
    /**
     * Gets the base url to fetch according to the networkId
     *
     * @param bitcoinNetworkId the Bitcoin network ID: 0 (mainnet) or 3 (testnet)
     * @returns The blockchain info URL
     */
    getBaseUrl(bitcoinNetworkId) {
        if (bitcoinNetworkId === 0) {
            return 'https://api.blockcypher.com/v1/btc/main/';
        }
        if (bitcoinNetworkId === 3) {
            return 'https://api.blockcypher.com/v1/btc/test3';
        }
        throw new Error(`Invalid network 0 (mainnet) or 3 (testnet) was expected but ${bitcoinNetworkId} was given`);
    }
}
exports.BlockcypherComProvider = BlockcypherComProvider;
//# sourceMappingURL=blockcypher-com.js.map