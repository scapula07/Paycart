"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnyToERC20PaymentDetector = void 0;
const tslib_1 = require("tslib");
const smart_contracts_1 = require("@requestnetwork/smart-contracts");
const types_1 = require("@requestnetwork/types");
const fee_proxy_contract_1 = require("../erc20/fee-proxy-contract");
const any_to_erc20_proxy_1 = require("./retrievers/any-to-erc20-proxy");
const conversion_info_retriever_1 = require("../thegraph/conversion-info-retriever");
const utils_1 = require("../utils");
const utils_2 = require("@requestnetwork/utils");
const currency_1 = require("@requestnetwork/currency");
const PROXY_CONTRACT_ADDRESS_MAP = {
    ['0.1.0']: '0.1.0',
};
/**
 * Handle payment networks with conversion proxy contract extension
 */
class AnyToERC20PaymentDetector extends fee_proxy_contract_1.ERC20FeeProxyPaymentDetectorBase {
    /**
     * @param extension The advanced logic payment network extensions
     */
    constructor({ advancedLogic, currencyManager, getSubgraphClient, }) {
        super(types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY, advancedLogic.extensions.anyToErc20Proxy, currencyManager);
        this.getSubgraphClient = getSubgraphClient;
    }
    /**
     * Creates the extensions data for the creation of this extension.
     * Will set a salt if none is already given
     *
     * @param paymentNetworkCreationParameters Parameters to create the extension
     * @returns The extensionData object
     */
    createExtensionsDataForCreation(paymentNetworkCreationParameters) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // If no salt is given, generate one
            const salt = paymentNetworkCreationParameters.salt || (yield (0, utils_2.generate8randomBytes)());
            return this.extension.createCreationAction({
                feeAddress: paymentNetworkCreationParameters.feeAddress,
                feeAmount: paymentNetworkCreationParameters.feeAmount,
                paymentAddress: paymentNetworkCreationParameters.paymentAddress,
                refundAddress: paymentNetworkCreationParameters.refundAddress,
                network: paymentNetworkCreationParameters.network,
                acceptedTokens: paymentNetworkCreationParameters.acceptedTokens,
                maxRateTimespan: paymentNetworkCreationParameters.maxRateTimespan,
                salt,
            });
        });
    }
    /**
     * Extracts the balance and events of a request
     *
     * @private
     * @param request Address to check
     * @param salt Payment reference salt
     * @param toAddress Payee address
     * @param eventName Indicate if it is an address for payment or refund
     * @param paymentNetwork Payment network state
     * @returns The balance and events
     */
    extractEvents(eventName, toAddress, paymentReference, requestCurrency, paymentChain, paymentNetwork) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!toAddress) {
                return {
                    paymentEvents: [],
                };
            }
            const { acceptedTokens, maxRateTimespan = 0 } = paymentNetwork.values;
            const { address: conversionProxyContractAddress, creationBlockNumber: conversionProxyCreationBlockNumber, } = AnyToERC20PaymentDetector.getDeploymentInformation(paymentChain, paymentNetwork.version);
            const conversionProxyAbi = smart_contracts_1.erc20ConversionProxy.getContractAbi(paymentNetwork.version);
            const currency = yield this.getCurrency(requestCurrency);
            const subgraphClient = this.getSubgraphClient(paymentChain);
            if (subgraphClient) {
                const infoRetriever = new conversion_info_retriever_1.TheGraphConversionInfoRetriever(subgraphClient, this.currencyManager);
                return yield infoRetriever.getTransferEvents({
                    paymentReference,
                    contractAddress: conversionProxyContractAddress,
                    toAddress,
                    eventName,
                    paymentChain,
                    acceptedTokens,
                    maxRateTimespan,
                    requestCurrency: currency,
                });
            }
            const infoRetriever = new any_to_erc20_proxy_1.AnyToErc20InfoRetriever(currency, paymentReference, conversionProxyContractAddress, conversionProxyCreationBlockNumber, conversionProxyAbi, toAddress, eventName, paymentChain, acceptedTokens, maxRateTimespan);
            const paymentEvents = (yield infoRetriever.getTransferEvents());
            return {
                paymentEvents,
            };
        });
    }
    getPaymentChain(request) {
        const network = this.getPaymentExtension(request).values.network;
        if (!network) {
            throw Error(`request.extensions[${this.paymentNetworkId}].values.network must be defined`);
        }
        currency_1.EvmChains.assertChainSupported(network);
        return network;
    }
}
exports.AnyToERC20PaymentDetector = AnyToERC20PaymentDetector;
AnyToERC20PaymentDetector.getDeploymentInformation = (0, utils_1.makeGetDeploymentInformation)(smart_contracts_1.erc20ConversionProxy, PROXY_CONTRACT_ADDRESS_MAP);
//# sourceMappingURL=any-to-erc20-proxy.js.map