"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversionInfoRetriever = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const utils_1 = require("../../utils");
const utils_2 = require("@requestnetwork/utils");
/**
 * Retrieves a list of payment events from a payment reference, a destination address, a token address and a proxy contract
 */
class ConversionInfoRetriever {
    /**
     * @param requestCurrency The request currency
     * @param paymentReference The reference to identify the payment
     * @param conversionProxyContractAddress The address of the conversion proxy contract
     * @param conversionProxyCreationBlockNumber The block that created the conversion proxy contract
     * @param toAddress Address of the balance we want to check
     * @param eventName Indicate if it is an address for payment or refund
     * @param network The Ethereum network to use
     */
    constructor(requestCurrency, paymentReference, conversionProxyContractAddress, conversionProxyCreationBlockNumber, conversionProxyContractAbiFragment, toAddress, eventName, network, acceptedTokens, maxRateTimespan = 0) {
        this.requestCurrency = requestCurrency;
        this.paymentReference = paymentReference;
        this.conversionProxyContractAddress = conversionProxyContractAddress;
        this.conversionProxyCreationBlockNumber = conversionProxyCreationBlockNumber;
        this.conversionProxyContractAbiFragment = conversionProxyContractAbiFragment;
        this.toAddress = toAddress;
        this.eventName = eventName;
        this.network = network;
        this.acceptedTokens = acceptedTokens;
        this.maxRateTimespan = maxRateTimespan;
        // Creates a local or default provider
        this.provider = (0, utils_2.getDefaultProvider)(this.network);
        // Setup the conversion proxy contract interface
        this.contractConversionProxy = new ethers_1.ethers.Contract(this.conversionProxyContractAddress, this.conversionProxyContractAbiFragment, this.provider);
        this.acceptedTokens = acceptedTokens === null || acceptedTokens === void 0 ? void 0 : acceptedTokens.map((token) => token.toLowerCase());
    }
    /**
     * Retrieves transfer events from the payment proxy and conversion proxy.
     * Logs from both proxies are matched by transaction hash, as both proxies should
     * be called in one transaction.
     *
     * The conversion proxy's logs are used to compute the amounts in request currency (typically fiat).
     * The payment proxy's logs are used the same way as for a pn-fee-proxy request.
     */
    getTransferEvents() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create a filter to find all the Fee Transfer logs with the payment reference
            const conversionFilter = this.contractConversionProxy.filters.TransferWithConversionAndReference(null, null, '0x' + this.paymentReference, null, null);
            conversionFilter.fromBlock = this.conversionProxyCreationBlockNumber;
            conversionFilter.toBlock = 'latest';
            // Get the conversion contract event logs
            const conversionLogs = yield this.provider.getLogs(conversionFilter);
            // Create a filter to find all the Fee Transfer logs with the payment reference
            const feeFilter = this.getFeeFilter();
            // Get the fee proxy contract event logs
            const feeProxyLogs = yield this.provider.getLogs(feeFilter);
            // Parses, filters and creates the events from the logs with the payment reference
            const eventPromises = conversionLogs
                // Parses the logs
                .map((log) => {
                const parsedConversionLog = this.contractConversionProxy.interface.parseLog(log);
                const proxyLog = feeProxyLogs.find((l) => l.transactionHash === log.transactionHash);
                if (!proxyLog) {
                    throw new Error('proxy log not found');
                }
                const parsedProxyLog = this.contractConversionProxy.interface.parseLog(proxyLog);
                return {
                    transactionHash: log.transactionHash,
                    blockNumber: log.blockNumber,
                    conversionLog: (0, utils_1.parseLogArgs)(parsedConversionLog),
                    proxyLog: (0, utils_1.parseLogArgs)(parsedProxyLog),
                };
            })
                // Keeps only the log with the right token and the right destination address
                // With ethers v5, the criteria below can be added to the conversionFilter (PROT-1234)
                .filter(({ conversionLog, proxyLog }) => 
            // filter the token allowed
            (!this.acceptedTokens ||
                !proxyLog.tokenAddress ||
                this.acceptedTokens.includes(proxyLog.tokenAddress.toLowerCase())) &&
                // check the rate timespan
                this.maxRateTimespan >= conversionLog.maxRateTimespan.toNumber() &&
                // check the requestCurrency
                this.requestCurrency.hash.toLowerCase() === conversionLog.currency.toLowerCase() &&
                // check to address
                proxyLog.to.toLowerCase() === this.toAddress.toLowerCase())
                // Creates the balance events
                .map(({ conversionLog, proxyLog, blockNumber, transactionHash }) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const requestCurrency = this.requestCurrency;
                const amount = (0, utils_1.unpadAmountFromChainlink)(conversionLog.amount, requestCurrency).toString();
                const feeAmount = (0, utils_1.unpadAmountFromChainlink)(conversionLog.feeAmount, requestCurrency).toString();
                return {
                    amount,
                    name: this.eventName,
                    parameters: {
                        block: blockNumber,
                        feeAddress: proxyLog.feeAddress || undefined,
                        feeAmount,
                        feeAmountInCrypto: proxyLog.feeAmount.toString() || undefined,
                        amountInCrypto: proxyLog.amount.toString(),
                        tokenAddress: proxyLog.tokenAddress,
                        to: this.toAddress,
                        txHash: transactionHash,
                        maxRateTimespan: conversionLog.maxRateTimespan.toString(),
                    },
                    timestamp: (yield this.provider.getBlock(blockNumber || 0)).timestamp,
                };
            }));
            return Promise.all(eventPromises);
        });
    }
}
exports.ConversionInfoRetriever = ConversionInfoRetriever;
//# sourceMappingURL=any-to-any-proxy.js.map