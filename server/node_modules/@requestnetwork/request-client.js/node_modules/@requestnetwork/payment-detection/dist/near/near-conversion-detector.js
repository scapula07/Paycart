"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NearConversionNativeTokenPaymentDetector = void 0;
const tslib_1 = require("tslib");
const currency_1 = require("@requestnetwork/currency");
const near_conversion_info_retriever_1 = require("./retrievers/near-conversion-info-retriever");
const any_to_native_detector_1 = require("../any-to-native-detector");
const balance_error_1 = require("../balance-error");
// the versions 0.1.0 and 0.2.0 have the same contracts
const CONTRACT_ADDRESS_MAP = {
    ['0.1.0']: '0.1.0',
};
/**
 * Handle payment detection for NEAR native token payment with conversion
 */
class NearConversionNativeTokenPaymentDetector extends any_to_native_detector_1.AnyToNativeDetector {
    constructor(args) {
        super(args);
        this.getSubgraphClient = args.getSubgraphClient;
    }
    /**
     * Extracts the events for an address and a payment reference
     *
     * @param toAddress Address to check
     * @param eventName Indicate if it is an address for payment or refund
     * @param requestCurrency The request currency
     * @param paymentReference The reference to identify the payment
     * @param paymentNetwork the payment network state
     * @returns The balance with events
     */
    extractEvents(eventName, toAddress, paymentReference, requestCurrency, paymentChain, paymentNetwork) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!toAddress) {
                return {
                    paymentEvents: [],
                };
            }
            const currency = this.currencyManager.fromStorageCurrency(requestCurrency);
            if (!currency) {
                throw new currency_1.UnsupportedCurrencyError(requestCurrency.value);
            }
            const subgraphClient = this.getSubgraphClient(paymentChain);
            if (!subgraphClient) {
                throw new Error(`Error getting subgraph client for ${paymentChain}`);
            }
            const infoRetriever = new near_conversion_info_retriever_1.NearConversionInfoRetriever(subgraphClient);
            const transferEvents = yield infoRetriever.getTransferEvents({
                requestCurrency: currency,
                paymentReference,
                toAddress,
                contractAddress: NearConversionNativeTokenPaymentDetector.getContractName(paymentChain, paymentNetwork.version),
                eventName,
                paymentChain,
                maxRateTimespan: paymentNetwork.values.maxRateTimespan,
            });
            return transferEvents;
        });
    }
    getPaymentChain(request) {
        const network = this.getPaymentExtension(request).values.network;
        if (!network) {
            throw Error(`request.extensions[${this.paymentNetworkId}].values.network must be defined`);
        }
        currency_1.NearChains.assertChainSupported(network);
        return network;
    }
}
exports.NearConversionNativeTokenPaymentDetector = NearConversionNativeTokenPaymentDetector;
NearConversionNativeTokenPaymentDetector.getContractName = (chainName, paymentNetworkVersion = '0.1.0') => {
    var _a;
    const version = NearConversionNativeTokenPaymentDetector.getVersionOrThrow(paymentNetworkVersion);
    const versionMap = {
        aurora: { '0.1.0': 'native.conversion.reqnetwork.near' },
        near: { '0.1.0': 'native.conversion.reqnetwork.near' },
        'aurora-testnet': {
            '0.1.0': 'native.conversion.reqnetwork.testnet',
        },
        'near-testnet': {
            '0.1.0': 'native.conversion.reqnetwork.testnet',
        },
    };
    if ((_a = versionMap[chainName]) === null || _a === void 0 ? void 0 : _a[version]) {
        return versionMap[chainName][version];
    }
    throw new balance_error_1.NetworkNotSupported(`Unconfigured near-conversion-detector chain '${chainName}' and version '${version}'`);
};
NearConversionNativeTokenPaymentDetector.getVersionOrThrow = (paymentNetworkVersion) => {
    if (!CONTRACT_ADDRESS_MAP[paymentNetworkVersion]) {
        throw Error(`Near payment detection not implemented for version ${paymentNetworkVersion}`);
    }
    return CONTRACT_ADDRESS_MAP[paymentNetworkVersion];
};
//# sourceMappingURL=near-conversion-detector.js.map