"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TheGraphInfoRetriever = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const ethers_1 = require("ethers");
const lodash_1 = require("lodash");
const utils_1 = require("../utils");
/**
 * TheGraph info retriever for payments without conversion on EVMs
 */
class TheGraphInfoRetriever {
    constructor(client, currencyManager) {
        this.client = client;
        this.currencyManager = currencyManager;
    }
    getTransferEvents(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (params.acceptedTokens && params.acceptedTokens.length > 1) {
                throw new Error('TheGraphInfoRetriever only supports no or 1 acceptedToken.');
            }
            const { payments, escrowEvents } = yield this.client.GetPaymentsAndEscrowState({
                reference: ethers_1.utils.keccak256(`0x${params.paymentReference}`),
                to: params.toAddress.toLowerCase(),
                tokenAddress: params.acceptedTokens ? params.acceptedTokens[0].toLowerCase() : null,
                contractAddress: params.contractAddress.toLowerCase(),
            });
            return {
                paymentEvents: payments.map((payment) => this.mapPaymentEvents(payment, params)),
                escrowEvents: escrowEvents.map((escrow) => this.mapEscrowEvents(escrow, params)),
            };
        });
    }
    // FIXME: this method should probably have the same filter as `getTransferEvents`.
    getReceivableEvents(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (params.acceptedTokens && params.acceptedTokens.length > 1) {
                throw new Error('TheGraphInfoRetriever only supports no or 1 acceptedToken.');
            }
            const { payments, escrowEvents } = yield this.client.GetPaymentsAndEscrowStateForReceivables({
                reference: ethers_1.utils.keccak256(`0x${params.paymentReference}`),
                tokenAddress: params.acceptedTokens ? params.acceptedTokens[0].toLowerCase() : null,
                contractAddress: params.contractAddress.toLowerCase(),
            });
            return {
                paymentEvents: payments.map((payment) => this.mapPaymentEvents(payment, params)),
                escrowEvents: escrowEvents.map((escrow) => this.mapEscrowEvents(escrow, params)),
            };
        });
    }
    mapPaymentEvents(payment, params) {
        let amount = payment.amount;
        let feeAmount = payment.feeAmount;
        if (payment.currency) {
            // account for the possibility the searched currency is of type ISO4217 and has no network
            const ccy = this.currencyManager.fromHash(payment.currency, params.paymentChain) ||
                this.currencyManager.fromHash(payment.currency);
            if (!ccy) {
                throw new Error(`Currency with hash ${payment.currency} is unknown`);
            }
            amount = (0, utils_1.unpadAmountFromChainlink)(amount, ccy).toString();
            feeAmount = (0, utils_1.unpadAmountFromChainlink)(feeAmount, ccy).toString();
        }
        return {
            amount,
            name: params.eventName,
            timestamp: payment.timestamp,
            parameters: Object.assign(Object.assign({ feeAmount, block: payment.block, to: (0, utils_1.formatAddress)(payment.to, 'to') }, (0, lodash_1.mapValues)((0, lodash_1.pick)(payment, 'txHash', 'gasUsed', 'gasPrice', 'amountInCrypto', 'feeAmountInCrypto', 'maxRateTimespan'), (val) => (val !== null ? String(val) : undefined))), (0, lodash_1.mapValues)((0, lodash_1.pick)(payment, 'from', 'feeAddress', 'tokenAddress'), (str, key) => str ? (0, utils_1.formatAddress)(str, key) : undefined)),
        };
    }
    mapEscrowEvents(escrow, params) {
        return {
            name: types_1.PaymentTypes.EVENTS_NAMES.ESCROW,
            timestamp: escrow.timestamp,
            parameters: {
                to: params.toAddress,
                from: escrow.from,
                txHash: escrow.txHash,
                block: escrow.block,
                eventName: escrow.eventName,
                gasUsed: escrow.gasUsed,
                gasPrice: escrow.gasPrice,
            },
        };
    }
}
exports.TheGraphInfoRetriever = TheGraphInfoRetriever;
//# sourceMappingURL=info-retriever.js.map