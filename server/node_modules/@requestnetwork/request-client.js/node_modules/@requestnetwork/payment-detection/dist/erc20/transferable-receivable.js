"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERC20TransferableReceivablePaymentDetector = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const thegraph_1 = require("../thegraph");
const smart_contracts_1 = require("@requestnetwork/smart-contracts");
const utils_1 = require("../utils");
const fee_reference_based_detector_1 = require("../fee-reference-based-detector");
const proxy_info_retriever_1 = require("./proxy-info-retriever");
const ERC20_TRANSFERABLE_RECEIVABLE_CONTRACT_ADDRESS_MAP = {
    ['0.1.0']: '0.1.0',
};
/**
 * Handle payment networks with ERC20 transferable receivable contract extension
 */
class ERC20TransferableReceivablePaymentDetector extends fee_reference_based_detector_1.FeeReferenceBasedDetector {
    /**
     * @param extension The advanced logic payment network extensions
     */
    constructor({ advancedLogic, currencyManager, getSubgraphClient, }) {
        super(types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_TRANSFERABLE_RECEIVABLE, advancedLogic.extensions.erc20TransferableReceivable, currencyManager);
        this.getSubgraphClient = getSubgraphClient;
    }
    /**
     * Extracts the balance and events of an address
     *
     * @private
     * @param address Address to check
     * @param eventName Indicate if it is an address for payment or refund
     * @param network The id of network we want to check
     * @param tokenContractAddress the address of the token contract
     * @returns The balance and events
     */
    extractEvents(eventName, toAddress, paymentReference, requestCurrency, paymentChain, paymentNetwork) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // To satisfy typescript
            toAddress;
            if (!paymentReference) {
                return {
                    paymentEvents: [],
                };
            }
            const { address: receivableContractAddress, creationBlockNumber: receivableCreationBlockNumber, } = ERC20TransferableReceivablePaymentDetector.getDeploymentInformation(paymentChain, paymentNetwork.version);
            const subgraphClient = this.getSubgraphClient(paymentChain);
            if (subgraphClient) {
                const graphInfoRetriever = new thegraph_1.TheGraphInfoRetriever(subgraphClient, this.currencyManager);
                return graphInfoRetriever.getReceivableEvents({
                    paymentReference,
                    toAddress: '',
                    contractAddress: receivableContractAddress,
                    paymentChain,
                    eventName,
                    acceptedTokens: [requestCurrency.value],
                });
            }
            else {
                const transferableReceivableInfoRetriever = new proxy_info_retriever_1.default(paymentReference, receivableContractAddress, receivableCreationBlockNumber, requestCurrency.value, '', eventName, paymentChain);
                const paymentEvents = yield transferableReceivableInfoRetriever.getTransferEvents(true /* isReceivable */);
                return {
                    paymentEvents,
                };
            }
        });
    }
}
exports.ERC20TransferableReceivablePaymentDetector = ERC20TransferableReceivablePaymentDetector;
/*
 * Returns deployment information for the underlying smart contract for a given payment network version
 */
ERC20TransferableReceivablePaymentDetector.getDeploymentInformation = (0, utils_1.makeGetDeploymentInformation)(smart_contracts_1.erc20TransferableReceivableArtifact, ERC20_TRANSFERABLE_RECEIVABLE_CONTRACT_ADDRESS_MAP);
//# sourceMappingURL=transferable-receivable.js.map