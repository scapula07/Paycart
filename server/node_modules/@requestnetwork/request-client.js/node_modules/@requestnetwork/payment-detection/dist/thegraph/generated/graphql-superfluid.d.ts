import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
export type Maybe<T> = T | null;
export type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    BigDecimal: any;
    BigInt: any;
    Bytes: any;
};
/** Account: A higher order entity created for any addresses which interact with Superfluid contracts. */
export type Account = {
    __typename?: 'Account';
    id: Scalars['ID'];
    createdAtTimestamp: Scalars['BigInt'];
    createdAtBlockNumber: Scalars['BigInt'];
    updatedAtTimestamp: Scalars['BigInt'];
    updatedAtBlockNumber: Scalars['BigInt'];
    /** Indicates whether the address/account is a super app. */
    isSuperApp: Scalars['Boolean'];
    inflows: Array<Stream>;
    outflows: Array<Stream>;
    subscriptions: Array<IndexSubscription>;
    publishedIndexes: Array<Index>;
    sentTransferEvents: Array<TransferEvent>;
    receivedTransferEvents: Array<TransferEvent>;
    tokenUpgradedEvents: Array<TokenUpgradedEvent>;
    tokenDowngradedEvents: Array<TokenDowngradedEvent>;
    accountTokenSnapshots: Array<AccountTokenSnapshot>;
};
/** Account: A higher order entity created for any addresses which interact with Superfluid contracts. */
export type AccountInflowsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Stream_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Stream_Filter>;
};
/** Account: A higher order entity created for any addresses which interact with Superfluid contracts. */
export type AccountOutflowsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Stream_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Stream_Filter>;
};
/** Account: A higher order entity created for any addresses which interact with Superfluid contracts. */
export type AccountSubscriptionsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexSubscription_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexSubscription_Filter>;
};
/** Account: A higher order entity created for any addresses which interact with Superfluid contracts. */
export type AccountPublishedIndexesArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Index_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Index_Filter>;
};
/** Account: A higher order entity created for any addresses which interact with Superfluid contracts. */
export type AccountSentTransferEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TransferEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TransferEvent_Filter>;
};
/** Account: A higher order entity created for any addresses which interact with Superfluid contracts. */
export type AccountReceivedTransferEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TransferEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TransferEvent_Filter>;
};
/** Account: A higher order entity created for any addresses which interact with Superfluid contracts. */
export type AccountTokenUpgradedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenUpgradedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenUpgradedEvent_Filter>;
};
/** Account: A higher order entity created for any addresses which interact with Superfluid contracts. */
export type AccountTokenDowngradedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenDowngradedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenDowngradedEvent_Filter>;
};
/** Account: A higher order entity created for any addresses which interact with Superfluid contracts. */
export type AccountAccountTokenSnapshotsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AccountTokenSnapshot_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AccountTokenSnapshot_Filter>;
};
/** AccountTokenSnapshot: An aggregate entity which aggregates data between an `account`'s interaction with `token`. */
export type AccountTokenSnapshot = {
    __typename?: 'AccountTokenSnapshot';
    /** ID composed of: accountID-tokenID */
    id: Scalars['ID'];
    updatedAtTimestamp: Scalars['BigInt'];
    updatedAtBlockNumber: Scalars['BigInt'];
    /**
     * isLiquidationEstimateOptimistic, If `totalSubscriptionsWithUnits > 0`, it is true.
     * "Optimistic" can be thought of as conservative as it refers to the earliest time the user may be liquidated as they may receive ongoing distributions which aren't tracked by the subgraph.
     */
    isLiquidationEstimateOptimistic: Scalars['Boolean'];
    /** Optimistic liquidation estimation property. */
    maybeCriticalAtTimestamp?: Maybe<Scalars['BigInt']>;
    /** The count of currently open streams for an account, both incoming and outgoing. */
    totalNumberOfActiveStreams: Scalars['Int'];
    /** The count of active outgoing streams from this account. */
    activeOutgoingStreamCount: Scalars['Int'];
    /** The count of active incoming streams to this account. */
    activeIncomingStreamCount: Scalars['Int'];
    /** The count of closed streams by `account`, both incoming and outgoing. */
    totalNumberOfClosedStreams: Scalars['Int'];
    /** The count of closed outgoing streams by `account`. */
    inactiveOutgoingStreamCount: Scalars['Int'];
    /** The count of closed incoming streams by `account`. */
    inactiveIncomingStreamCount: Scalars['Int'];
    /** The current (as of updatedAt) number of subscriptions with units allocated to them tied to this `account`. */
    totalSubscriptionsWithUnits: Scalars['Int'];
    /** Counts all currently (as of updatedAt) approved subscriptions whether or not they have units. */
    totalApprovedSubscriptions: Scalars['Int'];
    /** Balance of `account` as of `updatedAtTimestamp`/`updatedAtBlock`. */
    balanceUntilUpdatedAt: Scalars['BigInt'];
    /** The total deposit this account has held by the CFA agreement for `account` active streams. */
    totalDeposit: Scalars['BigInt'];
    /** The total net flow rate of the `account` as of `updatedAtTimestamp`/`updatedAtBlock`. */
    totalNetFlowRate: Scalars['BigInt'];
    /** The total inflow rate (receive flowRate per second) of the `account`. */
    totalInflowRate: Scalars['BigInt'];
    /** The total outflow rate (send flowrate per second) of the `account`. */
    totalOutflowRate: Scalars['BigInt'];
    /** The total amount of `token` streamed into this `account` until the `updatedAtTimestamp`/`updatedAtBlock`. */
    totalAmountStreamedInUntilUpdatedAt: Scalars['BigInt'];
    /** The total amount of `token` streamed from this `account` until the `updatedAtTimestamp`/`updatedAtBlock`. */
    totalAmountStreamedOutUntilUpdatedAt: Scalars['BigInt'];
    /** The total amount of `token` streamed through this `account` until the `updatedAtTimestamp`/`updatedAtBlock`. */
    totalAmountStreamedUntilUpdatedAt: Scalars['BigInt'];
    /** The total amount of `token` this `account` has transferred. */
    totalAmountTransferredUntilUpdatedAt: Scalars['BigInt'];
    account: Account;
    token: Token;
    flowOperators: Array<FlowOperator>;
    accountTokenSnapshotLogs: Array<AccountTokenSnapshotLog>;
};
/** AccountTokenSnapshot: An aggregate entity which aggregates data between an `account`'s interaction with `token`. */
export type AccountTokenSnapshotFlowOperatorsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowOperator_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowOperator_Filter>;
};
/** AccountTokenSnapshot: An aggregate entity which aggregates data between an `account`'s interaction with `token`. */
export type AccountTokenSnapshotAccountTokenSnapshotLogsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AccountTokenSnapshotLog_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AccountTokenSnapshotLog_Filter>;
};
/** AccountTokenSnapshotLog: Historical entries of `AccountTokenSnapshot` updates. */
export type AccountTokenSnapshotLog = {
    __typename?: 'AccountTokenSnapshotLog';
    id: Scalars['ID'];
    timestamp: Scalars['BigInt'];
    blockNumber: Scalars['BigInt'];
    transactionHash: Scalars['Bytes'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    triggeredByEventName: Scalars['String'];
    /** Optimistic liquidation estimation property. */
    maybeCriticalAtTimestamp?: Maybe<Scalars['BigInt']>;
    /** The current (as of timestamp) number of open streams. */
    totalNumberOfActiveStreams: Scalars['Int'];
    /** The count of active outgoing streams from this account. */
    activeOutgoingStreamCount: Scalars['Int'];
    /** The count of active incoming streams to this account. */
    activeIncomingStreamCount: Scalars['Int'];
    /** The current (as of timestamp) count of closed streams. */
    totalNumberOfClosedStreams: Scalars['Int'];
    /** The count of closed outgoing streams by `account`. */
    inactiveOutgoingStreamCount: Scalars['Int'];
    /** The count of closed incoming streams by `account`. */
    inactiveIncomingStreamCount: Scalars['Int'];
    /** The current (as of timestamp) number of subscriptions with units allocated to them tied to this `account`. */
    totalSubscriptionsWithUnits: Scalars['Int'];
    /** Counts all currently (as of timestamp) approved subscriptions whether or not they have units. */
    totalApprovedSubscriptions: Scalars['Int'];
    /** Balance of `account` as of `timestamp`/`block`. */
    balance: Scalars['BigInt'];
    /** The total (as of timestamp) deposit this account has held by the CFA agreement for `account` active streams. */
    totalDeposit: Scalars['BigInt'];
    /**
     * The total (as of timestamp) net flow rate of the `account` as of `timestamp`/`block`.
     * This can be obtained by: `totalInflowRate - totalOutflowRate`
     */
    totalNetFlowRate: Scalars['BigInt'];
    /** The total (as of timestamp) inflow rate (receive flowRate per second) of the `account`. */
    totalInflowRate: Scalars['BigInt'];
    /** The total (as of timestamp) outflow rate (send flowrate per second) of the `account`. */
    totalOutflowRate: Scalars['BigInt'];
    /** The total (as of timestamp) amount of `token` streamed into this `account` until the `timestamp`/`block`. */
    totalAmountStreamedIn: Scalars['BigInt'];
    /** The total (as of timestamp) amount of `token` streamed from this `account` until the `timestamp`/`block`. */
    totalAmountStreamedOut: Scalars['BigInt'];
    /** The total (as of timestamp) net amount of `token` streamed through this `account` until the `timestamp`/`block`. */
    totalAmountStreamed: Scalars['BigInt'];
    /** The total (as of timestamp) amount of `token` this `account` has transferred out until the `timestamp`/`block`. */
    totalAmountTransferred: Scalars['BigInt'];
    account: Account;
    token: Token;
    accountTokenSnapshot: AccountTokenSnapshot;
};
export type AccountTokenSnapshotLog_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    triggeredByEventName?: Maybe<Scalars['String']>;
    triggeredByEventName_not?: Maybe<Scalars['String']>;
    triggeredByEventName_gt?: Maybe<Scalars['String']>;
    triggeredByEventName_lt?: Maybe<Scalars['String']>;
    triggeredByEventName_gte?: Maybe<Scalars['String']>;
    triggeredByEventName_lte?: Maybe<Scalars['String']>;
    triggeredByEventName_in?: Maybe<Array<Scalars['String']>>;
    triggeredByEventName_not_in?: Maybe<Array<Scalars['String']>>;
    triggeredByEventName_contains?: Maybe<Scalars['String']>;
    triggeredByEventName_contains_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_not_contains?: Maybe<Scalars['String']>;
    triggeredByEventName_not_contains_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_starts_with?: Maybe<Scalars['String']>;
    triggeredByEventName_starts_with_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_not_starts_with?: Maybe<Scalars['String']>;
    triggeredByEventName_not_starts_with_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_ends_with?: Maybe<Scalars['String']>;
    triggeredByEventName_ends_with_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_not_ends_with?: Maybe<Scalars['String']>;
    triggeredByEventName_not_ends_with_nocase?: Maybe<Scalars['String']>;
    maybeCriticalAtTimestamp?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    maybeCriticalAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalNumberOfActiveStreams?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_not?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_gt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_lt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_gte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_lte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfActiveStreams_not_in?: Maybe<Array<Scalars['Int']>>;
    activeOutgoingStreamCount?: Maybe<Scalars['Int']>;
    activeOutgoingStreamCount_not?: Maybe<Scalars['Int']>;
    activeOutgoingStreamCount_gt?: Maybe<Scalars['Int']>;
    activeOutgoingStreamCount_lt?: Maybe<Scalars['Int']>;
    activeOutgoingStreamCount_gte?: Maybe<Scalars['Int']>;
    activeOutgoingStreamCount_lte?: Maybe<Scalars['Int']>;
    activeOutgoingStreamCount_in?: Maybe<Array<Scalars['Int']>>;
    activeOutgoingStreamCount_not_in?: Maybe<Array<Scalars['Int']>>;
    activeIncomingStreamCount?: Maybe<Scalars['Int']>;
    activeIncomingStreamCount_not?: Maybe<Scalars['Int']>;
    activeIncomingStreamCount_gt?: Maybe<Scalars['Int']>;
    activeIncomingStreamCount_lt?: Maybe<Scalars['Int']>;
    activeIncomingStreamCount_gte?: Maybe<Scalars['Int']>;
    activeIncomingStreamCount_lte?: Maybe<Scalars['Int']>;
    activeIncomingStreamCount_in?: Maybe<Array<Scalars['Int']>>;
    activeIncomingStreamCount_not_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfClosedStreams?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_not?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_gt?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_lt?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_gte?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_lte?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfClosedStreams_not_in?: Maybe<Array<Scalars['Int']>>;
    inactiveOutgoingStreamCount?: Maybe<Scalars['Int']>;
    inactiveOutgoingStreamCount_not?: Maybe<Scalars['Int']>;
    inactiveOutgoingStreamCount_gt?: Maybe<Scalars['Int']>;
    inactiveOutgoingStreamCount_lt?: Maybe<Scalars['Int']>;
    inactiveOutgoingStreamCount_gte?: Maybe<Scalars['Int']>;
    inactiveOutgoingStreamCount_lte?: Maybe<Scalars['Int']>;
    inactiveOutgoingStreamCount_in?: Maybe<Array<Scalars['Int']>>;
    inactiveOutgoingStreamCount_not_in?: Maybe<Array<Scalars['Int']>>;
    inactiveIncomingStreamCount?: Maybe<Scalars['Int']>;
    inactiveIncomingStreamCount_not?: Maybe<Scalars['Int']>;
    inactiveIncomingStreamCount_gt?: Maybe<Scalars['Int']>;
    inactiveIncomingStreamCount_lt?: Maybe<Scalars['Int']>;
    inactiveIncomingStreamCount_gte?: Maybe<Scalars['Int']>;
    inactiveIncomingStreamCount_lte?: Maybe<Scalars['Int']>;
    inactiveIncomingStreamCount_in?: Maybe<Array<Scalars['Int']>>;
    inactiveIncomingStreamCount_not_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_not?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits_not_in?: Maybe<Array<Scalars['Int']>>;
    totalApprovedSubscriptions?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_not?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_gt?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_lt?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_gte?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_lte?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_in?: Maybe<Array<Scalars['Int']>>;
    totalApprovedSubscriptions_not_in?: Maybe<Array<Scalars['Int']>>;
    balance?: Maybe<Scalars['BigInt']>;
    balance_not?: Maybe<Scalars['BigInt']>;
    balance_gt?: Maybe<Scalars['BigInt']>;
    balance_lt?: Maybe<Scalars['BigInt']>;
    balance_gte?: Maybe<Scalars['BigInt']>;
    balance_lte?: Maybe<Scalars['BigInt']>;
    balance_in?: Maybe<Array<Scalars['BigInt']>>;
    balance_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalDeposit?: Maybe<Scalars['BigInt']>;
    totalDeposit_not?: Maybe<Scalars['BigInt']>;
    totalDeposit_gt?: Maybe<Scalars['BigInt']>;
    totalDeposit_lt?: Maybe<Scalars['BigInt']>;
    totalDeposit_gte?: Maybe<Scalars['BigInt']>;
    totalDeposit_lte?: Maybe<Scalars['BigInt']>;
    totalDeposit_in?: Maybe<Array<Scalars['BigInt']>>;
    totalDeposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalNetFlowRate?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_not?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_gt?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_lt?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_gte?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_lte?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalNetFlowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalInflowRate?: Maybe<Scalars['BigInt']>;
    totalInflowRate_not?: Maybe<Scalars['BigInt']>;
    totalInflowRate_gt?: Maybe<Scalars['BigInt']>;
    totalInflowRate_lt?: Maybe<Scalars['BigInt']>;
    totalInflowRate_gte?: Maybe<Scalars['BigInt']>;
    totalInflowRate_lte?: Maybe<Scalars['BigInt']>;
    totalInflowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalInflowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalOutflowRate?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_not?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_gt?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_lt?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_gte?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_lte?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalOutflowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedIn?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedIn_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedIn_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedIn_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedIn_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedIn_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedIn_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedIn_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedOut?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOut_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOut_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOut_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOut_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOut_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOut_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedOut_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamed?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountTransferred?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_not?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_gt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_lt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_gte?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_lte?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountTransferred_not_in?: Maybe<Array<Scalars['BigInt']>>;
    account?: Maybe<Scalars['String']>;
    account_not?: Maybe<Scalars['String']>;
    account_gt?: Maybe<Scalars['String']>;
    account_lt?: Maybe<Scalars['String']>;
    account_gte?: Maybe<Scalars['String']>;
    account_lte?: Maybe<Scalars['String']>;
    account_in?: Maybe<Array<Scalars['String']>>;
    account_not_in?: Maybe<Array<Scalars['String']>>;
    account_contains?: Maybe<Scalars['String']>;
    account_contains_nocase?: Maybe<Scalars['String']>;
    account_not_contains?: Maybe<Scalars['String']>;
    account_not_contains_nocase?: Maybe<Scalars['String']>;
    account_starts_with?: Maybe<Scalars['String']>;
    account_starts_with_nocase?: Maybe<Scalars['String']>;
    account_not_starts_with?: Maybe<Scalars['String']>;
    account_not_starts_with_nocase?: Maybe<Scalars['String']>;
    account_ends_with?: Maybe<Scalars['String']>;
    account_ends_with_nocase?: Maybe<Scalars['String']>;
    account_not_ends_with?: Maybe<Scalars['String']>;
    account_not_ends_with_nocase?: Maybe<Scalars['String']>;
    account_?: Maybe<Account_Filter>;
    token?: Maybe<Scalars['String']>;
    token_not?: Maybe<Scalars['String']>;
    token_gt?: Maybe<Scalars['String']>;
    token_lt?: Maybe<Scalars['String']>;
    token_gte?: Maybe<Scalars['String']>;
    token_lte?: Maybe<Scalars['String']>;
    token_in?: Maybe<Array<Scalars['String']>>;
    token_not_in?: Maybe<Array<Scalars['String']>>;
    token_contains?: Maybe<Scalars['String']>;
    token_contains_nocase?: Maybe<Scalars['String']>;
    token_not_contains?: Maybe<Scalars['String']>;
    token_not_contains_nocase?: Maybe<Scalars['String']>;
    token_starts_with?: Maybe<Scalars['String']>;
    token_starts_with_nocase?: Maybe<Scalars['String']>;
    token_not_starts_with?: Maybe<Scalars['String']>;
    token_not_starts_with_nocase?: Maybe<Scalars['String']>;
    token_ends_with?: Maybe<Scalars['String']>;
    token_ends_with_nocase?: Maybe<Scalars['String']>;
    token_not_ends_with?: Maybe<Scalars['String']>;
    token_not_ends_with_nocase?: Maybe<Scalars['String']>;
    token_?: Maybe<Token_Filter>;
    accountTokenSnapshot?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not?: Maybe<Scalars['String']>;
    accountTokenSnapshot_gt?: Maybe<Scalars['String']>;
    accountTokenSnapshot_lt?: Maybe<Scalars['String']>;
    accountTokenSnapshot_gte?: Maybe<Scalars['String']>;
    accountTokenSnapshot_lte?: Maybe<Scalars['String']>;
    accountTokenSnapshot_in?: Maybe<Array<Scalars['String']>>;
    accountTokenSnapshot_not_in?: Maybe<Array<Scalars['String']>>;
    accountTokenSnapshot_contains?: Maybe<Scalars['String']>;
    accountTokenSnapshot_contains_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_contains?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_contains_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_starts_with?: Maybe<Scalars['String']>;
    accountTokenSnapshot_starts_with_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_starts_with?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_starts_with_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_ends_with?: Maybe<Scalars['String']>;
    accountTokenSnapshot_ends_with_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_ends_with?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_ends_with_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_?: Maybe<AccountTokenSnapshot_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<AccountTokenSnapshotLog_Filter>>>;
    or?: Maybe<Array<Maybe<AccountTokenSnapshotLog_Filter>>>;
};
export declare enum AccountTokenSnapshotLog_OrderBy {
    Id = "id",
    Timestamp = "timestamp",
    BlockNumber = "blockNumber",
    TransactionHash = "transactionHash",
    LogIndex = "logIndex",
    Order = "order",
    TriggeredByEventName = "triggeredByEventName",
    MaybeCriticalAtTimestamp = "maybeCriticalAtTimestamp",
    TotalNumberOfActiveStreams = "totalNumberOfActiveStreams",
    ActiveOutgoingStreamCount = "activeOutgoingStreamCount",
    ActiveIncomingStreamCount = "activeIncomingStreamCount",
    TotalNumberOfClosedStreams = "totalNumberOfClosedStreams",
    InactiveOutgoingStreamCount = "inactiveOutgoingStreamCount",
    InactiveIncomingStreamCount = "inactiveIncomingStreamCount",
    TotalSubscriptionsWithUnits = "totalSubscriptionsWithUnits",
    TotalApprovedSubscriptions = "totalApprovedSubscriptions",
    Balance = "balance",
    TotalDeposit = "totalDeposit",
    TotalNetFlowRate = "totalNetFlowRate",
    TotalInflowRate = "totalInflowRate",
    TotalOutflowRate = "totalOutflowRate",
    TotalAmountStreamedIn = "totalAmountStreamedIn",
    TotalAmountStreamedOut = "totalAmountStreamedOut",
    TotalAmountStreamed = "totalAmountStreamed",
    TotalAmountTransferred = "totalAmountTransferred",
    Account = "account",
    Account__id = "account__id",
    Account__createdAtTimestamp = "account__createdAtTimestamp",
    Account__createdAtBlockNumber = "account__createdAtBlockNumber",
    Account__updatedAtTimestamp = "account__updatedAtTimestamp",
    Account__updatedAtBlockNumber = "account__updatedAtBlockNumber",
    Account__isSuperApp = "account__isSuperApp",
    Token = "token",
    Token__id = "token__id",
    Token__createdAtTimestamp = "token__createdAtTimestamp",
    Token__createdAtBlockNumber = "token__createdAtBlockNumber",
    Token__decimals = "token__decimals",
    Token__name = "token__name",
    Token__symbol = "token__symbol",
    Token__isSuperToken = "token__isSuperToken",
    Token__isNativeAssetSuperToken = "token__isNativeAssetSuperToken",
    Token__isListed = "token__isListed",
    Token__underlyingAddress = "token__underlyingAddress",
    AccountTokenSnapshot = "accountTokenSnapshot",
    AccountTokenSnapshot__id = "accountTokenSnapshot__id",
    AccountTokenSnapshot__updatedAtTimestamp = "accountTokenSnapshot__updatedAtTimestamp",
    AccountTokenSnapshot__updatedAtBlockNumber = "accountTokenSnapshot__updatedAtBlockNumber",
    AccountTokenSnapshot__isLiquidationEstimateOptimistic = "accountTokenSnapshot__isLiquidationEstimateOptimistic",
    AccountTokenSnapshot__maybeCriticalAtTimestamp = "accountTokenSnapshot__maybeCriticalAtTimestamp",
    AccountTokenSnapshot__totalNumberOfActiveStreams = "accountTokenSnapshot__totalNumberOfActiveStreams",
    AccountTokenSnapshot__activeOutgoingStreamCount = "accountTokenSnapshot__activeOutgoingStreamCount",
    AccountTokenSnapshot__activeIncomingStreamCount = "accountTokenSnapshot__activeIncomingStreamCount",
    AccountTokenSnapshot__totalNumberOfClosedStreams = "accountTokenSnapshot__totalNumberOfClosedStreams",
    AccountTokenSnapshot__inactiveOutgoingStreamCount = "accountTokenSnapshot__inactiveOutgoingStreamCount",
    AccountTokenSnapshot__inactiveIncomingStreamCount = "accountTokenSnapshot__inactiveIncomingStreamCount",
    AccountTokenSnapshot__totalSubscriptionsWithUnits = "accountTokenSnapshot__totalSubscriptionsWithUnits",
    AccountTokenSnapshot__totalApprovedSubscriptions = "accountTokenSnapshot__totalApprovedSubscriptions",
    AccountTokenSnapshot__balanceUntilUpdatedAt = "accountTokenSnapshot__balanceUntilUpdatedAt",
    AccountTokenSnapshot__totalDeposit = "accountTokenSnapshot__totalDeposit",
    AccountTokenSnapshot__totalNetFlowRate = "accountTokenSnapshot__totalNetFlowRate",
    AccountTokenSnapshot__totalInflowRate = "accountTokenSnapshot__totalInflowRate",
    AccountTokenSnapshot__totalOutflowRate = "accountTokenSnapshot__totalOutflowRate",
    AccountTokenSnapshot__totalAmountStreamedInUntilUpdatedAt = "accountTokenSnapshot__totalAmountStreamedInUntilUpdatedAt",
    AccountTokenSnapshot__totalAmountStreamedOutUntilUpdatedAt = "accountTokenSnapshot__totalAmountStreamedOutUntilUpdatedAt",
    AccountTokenSnapshot__totalAmountStreamedUntilUpdatedAt = "accountTokenSnapshot__totalAmountStreamedUntilUpdatedAt",
    AccountTokenSnapshot__totalAmountTransferredUntilUpdatedAt = "accountTokenSnapshot__totalAmountTransferredUntilUpdatedAt"
}
export type AccountTokenSnapshot_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    updatedAtTimestamp?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    isLiquidationEstimateOptimistic?: Maybe<Scalars['Boolean']>;
    isLiquidationEstimateOptimistic_not?: Maybe<Scalars['Boolean']>;
    isLiquidationEstimateOptimistic_in?: Maybe<Array<Scalars['Boolean']>>;
    isLiquidationEstimateOptimistic_not_in?: Maybe<Array<Scalars['Boolean']>>;
    maybeCriticalAtTimestamp?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    maybeCriticalAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalNumberOfActiveStreams?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_not?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_gt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_lt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_gte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_lte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfActiveStreams_not_in?: Maybe<Array<Scalars['Int']>>;
    activeOutgoingStreamCount?: Maybe<Scalars['Int']>;
    activeOutgoingStreamCount_not?: Maybe<Scalars['Int']>;
    activeOutgoingStreamCount_gt?: Maybe<Scalars['Int']>;
    activeOutgoingStreamCount_lt?: Maybe<Scalars['Int']>;
    activeOutgoingStreamCount_gte?: Maybe<Scalars['Int']>;
    activeOutgoingStreamCount_lte?: Maybe<Scalars['Int']>;
    activeOutgoingStreamCount_in?: Maybe<Array<Scalars['Int']>>;
    activeOutgoingStreamCount_not_in?: Maybe<Array<Scalars['Int']>>;
    activeIncomingStreamCount?: Maybe<Scalars['Int']>;
    activeIncomingStreamCount_not?: Maybe<Scalars['Int']>;
    activeIncomingStreamCount_gt?: Maybe<Scalars['Int']>;
    activeIncomingStreamCount_lt?: Maybe<Scalars['Int']>;
    activeIncomingStreamCount_gte?: Maybe<Scalars['Int']>;
    activeIncomingStreamCount_lte?: Maybe<Scalars['Int']>;
    activeIncomingStreamCount_in?: Maybe<Array<Scalars['Int']>>;
    activeIncomingStreamCount_not_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfClosedStreams?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_not?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_gt?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_lt?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_gte?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_lte?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfClosedStreams_not_in?: Maybe<Array<Scalars['Int']>>;
    inactiveOutgoingStreamCount?: Maybe<Scalars['Int']>;
    inactiveOutgoingStreamCount_not?: Maybe<Scalars['Int']>;
    inactiveOutgoingStreamCount_gt?: Maybe<Scalars['Int']>;
    inactiveOutgoingStreamCount_lt?: Maybe<Scalars['Int']>;
    inactiveOutgoingStreamCount_gte?: Maybe<Scalars['Int']>;
    inactiveOutgoingStreamCount_lte?: Maybe<Scalars['Int']>;
    inactiveOutgoingStreamCount_in?: Maybe<Array<Scalars['Int']>>;
    inactiveOutgoingStreamCount_not_in?: Maybe<Array<Scalars['Int']>>;
    inactiveIncomingStreamCount?: Maybe<Scalars['Int']>;
    inactiveIncomingStreamCount_not?: Maybe<Scalars['Int']>;
    inactiveIncomingStreamCount_gt?: Maybe<Scalars['Int']>;
    inactiveIncomingStreamCount_lt?: Maybe<Scalars['Int']>;
    inactiveIncomingStreamCount_gte?: Maybe<Scalars['Int']>;
    inactiveIncomingStreamCount_lte?: Maybe<Scalars['Int']>;
    inactiveIncomingStreamCount_in?: Maybe<Array<Scalars['Int']>>;
    inactiveIncomingStreamCount_not_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_not?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits_not_in?: Maybe<Array<Scalars['Int']>>;
    totalApprovedSubscriptions?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_not?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_gt?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_lt?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_gte?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_lte?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_in?: Maybe<Array<Scalars['Int']>>;
    totalApprovedSubscriptions_not_in?: Maybe<Array<Scalars['Int']>>;
    balanceUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    balanceUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    balanceUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    balanceUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    balanceUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    balanceUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    balanceUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    balanceUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalDeposit?: Maybe<Scalars['BigInt']>;
    totalDeposit_not?: Maybe<Scalars['BigInt']>;
    totalDeposit_gt?: Maybe<Scalars['BigInt']>;
    totalDeposit_lt?: Maybe<Scalars['BigInt']>;
    totalDeposit_gte?: Maybe<Scalars['BigInt']>;
    totalDeposit_lte?: Maybe<Scalars['BigInt']>;
    totalDeposit_in?: Maybe<Array<Scalars['BigInt']>>;
    totalDeposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalNetFlowRate?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_not?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_gt?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_lt?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_gte?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_lte?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalNetFlowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalInflowRate?: Maybe<Scalars['BigInt']>;
    totalInflowRate_not?: Maybe<Scalars['BigInt']>;
    totalInflowRate_gt?: Maybe<Scalars['BigInt']>;
    totalInflowRate_lt?: Maybe<Scalars['BigInt']>;
    totalInflowRate_gte?: Maybe<Scalars['BigInt']>;
    totalInflowRate_lte?: Maybe<Scalars['BigInt']>;
    totalInflowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalInflowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalOutflowRate?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_not?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_gt?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_lt?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_gte?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_lte?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalOutflowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedInUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedInUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedInUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedInUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedInUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedInUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedInUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedInUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedOutUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOutUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOutUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOutUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOutUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOutUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOutUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedOutUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountTransferredUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountTransferredUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    account?: Maybe<Scalars['String']>;
    account_not?: Maybe<Scalars['String']>;
    account_gt?: Maybe<Scalars['String']>;
    account_lt?: Maybe<Scalars['String']>;
    account_gte?: Maybe<Scalars['String']>;
    account_lte?: Maybe<Scalars['String']>;
    account_in?: Maybe<Array<Scalars['String']>>;
    account_not_in?: Maybe<Array<Scalars['String']>>;
    account_contains?: Maybe<Scalars['String']>;
    account_contains_nocase?: Maybe<Scalars['String']>;
    account_not_contains?: Maybe<Scalars['String']>;
    account_not_contains_nocase?: Maybe<Scalars['String']>;
    account_starts_with?: Maybe<Scalars['String']>;
    account_starts_with_nocase?: Maybe<Scalars['String']>;
    account_not_starts_with?: Maybe<Scalars['String']>;
    account_not_starts_with_nocase?: Maybe<Scalars['String']>;
    account_ends_with?: Maybe<Scalars['String']>;
    account_ends_with_nocase?: Maybe<Scalars['String']>;
    account_not_ends_with?: Maybe<Scalars['String']>;
    account_not_ends_with_nocase?: Maybe<Scalars['String']>;
    account_?: Maybe<Account_Filter>;
    token?: Maybe<Scalars['String']>;
    token_not?: Maybe<Scalars['String']>;
    token_gt?: Maybe<Scalars['String']>;
    token_lt?: Maybe<Scalars['String']>;
    token_gte?: Maybe<Scalars['String']>;
    token_lte?: Maybe<Scalars['String']>;
    token_in?: Maybe<Array<Scalars['String']>>;
    token_not_in?: Maybe<Array<Scalars['String']>>;
    token_contains?: Maybe<Scalars['String']>;
    token_contains_nocase?: Maybe<Scalars['String']>;
    token_not_contains?: Maybe<Scalars['String']>;
    token_not_contains_nocase?: Maybe<Scalars['String']>;
    token_starts_with?: Maybe<Scalars['String']>;
    token_starts_with_nocase?: Maybe<Scalars['String']>;
    token_not_starts_with?: Maybe<Scalars['String']>;
    token_not_starts_with_nocase?: Maybe<Scalars['String']>;
    token_ends_with?: Maybe<Scalars['String']>;
    token_ends_with_nocase?: Maybe<Scalars['String']>;
    token_not_ends_with?: Maybe<Scalars['String']>;
    token_not_ends_with_nocase?: Maybe<Scalars['String']>;
    token_?: Maybe<Token_Filter>;
    flowOperators_?: Maybe<FlowOperator_Filter>;
    accountTokenSnapshotLogs_?: Maybe<AccountTokenSnapshotLog_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<AccountTokenSnapshot_Filter>>>;
    or?: Maybe<Array<Maybe<AccountTokenSnapshot_Filter>>>;
};
export declare enum AccountTokenSnapshot_OrderBy {
    Id = "id",
    UpdatedAtTimestamp = "updatedAtTimestamp",
    UpdatedAtBlockNumber = "updatedAtBlockNumber",
    IsLiquidationEstimateOptimistic = "isLiquidationEstimateOptimistic",
    MaybeCriticalAtTimestamp = "maybeCriticalAtTimestamp",
    TotalNumberOfActiveStreams = "totalNumberOfActiveStreams",
    ActiveOutgoingStreamCount = "activeOutgoingStreamCount",
    ActiveIncomingStreamCount = "activeIncomingStreamCount",
    TotalNumberOfClosedStreams = "totalNumberOfClosedStreams",
    InactiveOutgoingStreamCount = "inactiveOutgoingStreamCount",
    InactiveIncomingStreamCount = "inactiveIncomingStreamCount",
    TotalSubscriptionsWithUnits = "totalSubscriptionsWithUnits",
    TotalApprovedSubscriptions = "totalApprovedSubscriptions",
    BalanceUntilUpdatedAt = "balanceUntilUpdatedAt",
    TotalDeposit = "totalDeposit",
    TotalNetFlowRate = "totalNetFlowRate",
    TotalInflowRate = "totalInflowRate",
    TotalOutflowRate = "totalOutflowRate",
    TotalAmountStreamedInUntilUpdatedAt = "totalAmountStreamedInUntilUpdatedAt",
    TotalAmountStreamedOutUntilUpdatedAt = "totalAmountStreamedOutUntilUpdatedAt",
    TotalAmountStreamedUntilUpdatedAt = "totalAmountStreamedUntilUpdatedAt",
    TotalAmountTransferredUntilUpdatedAt = "totalAmountTransferredUntilUpdatedAt",
    Account = "account",
    Account__id = "account__id",
    Account__createdAtTimestamp = "account__createdAtTimestamp",
    Account__createdAtBlockNumber = "account__createdAtBlockNumber",
    Account__updatedAtTimestamp = "account__updatedAtTimestamp",
    Account__updatedAtBlockNumber = "account__updatedAtBlockNumber",
    Account__isSuperApp = "account__isSuperApp",
    Token = "token",
    Token__id = "token__id",
    Token__createdAtTimestamp = "token__createdAtTimestamp",
    Token__createdAtBlockNumber = "token__createdAtBlockNumber",
    Token__decimals = "token__decimals",
    Token__name = "token__name",
    Token__symbol = "token__symbol",
    Token__isSuperToken = "token__isSuperToken",
    Token__isNativeAssetSuperToken = "token__isNativeAssetSuperToken",
    Token__isListed = "token__isListed",
    Token__underlyingAddress = "token__underlyingAddress",
    FlowOperators = "flowOperators",
    AccountTokenSnapshotLogs = "accountTokenSnapshotLogs"
}
export type Account_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    createdAtTimestamp?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    isSuperApp?: Maybe<Scalars['Boolean']>;
    isSuperApp_not?: Maybe<Scalars['Boolean']>;
    isSuperApp_in?: Maybe<Array<Scalars['Boolean']>>;
    isSuperApp_not_in?: Maybe<Array<Scalars['Boolean']>>;
    inflows_?: Maybe<Stream_Filter>;
    outflows_?: Maybe<Stream_Filter>;
    subscriptions_?: Maybe<IndexSubscription_Filter>;
    publishedIndexes_?: Maybe<Index_Filter>;
    sentTransferEvents_?: Maybe<TransferEvent_Filter>;
    receivedTransferEvents_?: Maybe<TransferEvent_Filter>;
    tokenUpgradedEvents_?: Maybe<TokenUpgradedEvent_Filter>;
    tokenDowngradedEvents_?: Maybe<TokenDowngradedEvent_Filter>;
    accountTokenSnapshots_?: Maybe<AccountTokenSnapshot_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<Account_Filter>>>;
    or?: Maybe<Array<Maybe<Account_Filter>>>;
};
export declare enum Account_OrderBy {
    Id = "id",
    CreatedAtTimestamp = "createdAtTimestamp",
    CreatedAtBlockNumber = "createdAtBlockNumber",
    UpdatedAtTimestamp = "updatedAtTimestamp",
    UpdatedAtBlockNumber = "updatedAtBlockNumber",
    IsSuperApp = "isSuperApp",
    Inflows = "inflows",
    Outflows = "outflows",
    Subscriptions = "subscriptions",
    PublishedIndexes = "publishedIndexes",
    SentTransferEvents = "sentTransferEvents",
    ReceivedTransferEvents = "receivedTransferEvents",
    TokenUpgradedEvents = "tokenUpgradedEvents",
    TokenDowngradedEvents = "tokenDowngradedEvents",
    AccountTokenSnapshots = "accountTokenSnapshots"
}
export type AgreementClassRegisteredEvent = Event & {
    __typename?: 'AgreementClassRegisteredEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    agreementType: Scalars['Bytes'];
    code: Scalars['Bytes'];
};
export type AgreementClassRegisteredEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    agreementType?: Maybe<Scalars['Bytes']>;
    agreementType_not?: Maybe<Scalars['Bytes']>;
    agreementType_gt?: Maybe<Scalars['Bytes']>;
    agreementType_lt?: Maybe<Scalars['Bytes']>;
    agreementType_gte?: Maybe<Scalars['Bytes']>;
    agreementType_lte?: Maybe<Scalars['Bytes']>;
    agreementType_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementType_not_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementType_contains?: Maybe<Scalars['Bytes']>;
    agreementType_not_contains?: Maybe<Scalars['Bytes']>;
    code?: Maybe<Scalars['Bytes']>;
    code_not?: Maybe<Scalars['Bytes']>;
    code_gt?: Maybe<Scalars['Bytes']>;
    code_lt?: Maybe<Scalars['Bytes']>;
    code_gte?: Maybe<Scalars['Bytes']>;
    code_lte?: Maybe<Scalars['Bytes']>;
    code_in?: Maybe<Array<Scalars['Bytes']>>;
    code_not_in?: Maybe<Array<Scalars['Bytes']>>;
    code_contains?: Maybe<Scalars['Bytes']>;
    code_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<AgreementClassRegisteredEvent_Filter>>>;
    or?: Maybe<Array<Maybe<AgreementClassRegisteredEvent_Filter>>>;
};
export declare enum AgreementClassRegisteredEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    AgreementType = "agreementType",
    Code = "code"
}
export type AgreementClassUpdatedEvent = Event & {
    __typename?: 'AgreementClassUpdatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    agreementType: Scalars['Bytes'];
    code: Scalars['Bytes'];
};
export type AgreementClassUpdatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    agreementType?: Maybe<Scalars['Bytes']>;
    agreementType_not?: Maybe<Scalars['Bytes']>;
    agreementType_gt?: Maybe<Scalars['Bytes']>;
    agreementType_lt?: Maybe<Scalars['Bytes']>;
    agreementType_gte?: Maybe<Scalars['Bytes']>;
    agreementType_lte?: Maybe<Scalars['Bytes']>;
    agreementType_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementType_not_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementType_contains?: Maybe<Scalars['Bytes']>;
    agreementType_not_contains?: Maybe<Scalars['Bytes']>;
    code?: Maybe<Scalars['Bytes']>;
    code_not?: Maybe<Scalars['Bytes']>;
    code_gt?: Maybe<Scalars['Bytes']>;
    code_lt?: Maybe<Scalars['Bytes']>;
    code_gte?: Maybe<Scalars['Bytes']>;
    code_lte?: Maybe<Scalars['Bytes']>;
    code_in?: Maybe<Array<Scalars['Bytes']>>;
    code_not_in?: Maybe<Array<Scalars['Bytes']>>;
    code_contains?: Maybe<Scalars['Bytes']>;
    code_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<AgreementClassUpdatedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<AgreementClassUpdatedEvent_Filter>>>;
};
export declare enum AgreementClassUpdatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    AgreementType = "agreementType",
    Code = "code"
}
/**
 * NOTE: This event was deprecated since the introduction of the 3Ps system.
 * Replaced by: `AgreementLiquidatedV2Event`
 * See: https://docs.superfluid.finance/superfluid/sentinels/liquidations-and-toga#patricians-plebs-and-pirates-3ps for more details on the 3Ps system.
 * See: https://github.com/superfluid-finance/protocol-monorepo/blob/dev/packages/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidToken.sol#L425 for more details on the events.
 */
export type AgreementLiquidatedByEvent = Event & {
    __typename?: 'AgreementLiquidatedByEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = liquidatorAccount (executor of liquidation)
     * addresses[2] = penaltyAccount (the sender of the flow/stream)
     * addresses[3] = bondAccount (the address receiving the reward - the reward account for the token, pre 3Ps)
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    liquidatorAccount: Scalars['Bytes'];
    agreementClass: Scalars['Bytes'];
    agreementId: Scalars['Bytes'];
    penaltyAccount: Scalars['Bytes'];
    bondAccount: Scalars['Bytes'];
    rewardAmount: Scalars['BigInt'];
    bailoutAmount: Scalars['BigInt'];
    /** The full deposit amount of the stream that was liquidated. */
    deposit: Scalars['BigInt'];
    /** The flow rate of the stream at the time of liquidation. */
    flowRateAtLiquidation: Scalars['BigInt'];
};
export type AgreementLiquidatedByEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    liquidatorAccount?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_not?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_gt?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_lt?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_gte?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_lte?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_in?: Maybe<Array<Scalars['Bytes']>>;
    liquidatorAccount_not_in?: Maybe<Array<Scalars['Bytes']>>;
    liquidatorAccount_contains?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_not_contains?: Maybe<Scalars['Bytes']>;
    agreementClass?: Maybe<Scalars['Bytes']>;
    agreementClass_not?: Maybe<Scalars['Bytes']>;
    agreementClass_gt?: Maybe<Scalars['Bytes']>;
    agreementClass_lt?: Maybe<Scalars['Bytes']>;
    agreementClass_gte?: Maybe<Scalars['Bytes']>;
    agreementClass_lte?: Maybe<Scalars['Bytes']>;
    agreementClass_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementClass_not_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementClass_contains?: Maybe<Scalars['Bytes']>;
    agreementClass_not_contains?: Maybe<Scalars['Bytes']>;
    agreementId?: Maybe<Scalars['Bytes']>;
    agreementId_not?: Maybe<Scalars['Bytes']>;
    agreementId_gt?: Maybe<Scalars['Bytes']>;
    agreementId_lt?: Maybe<Scalars['Bytes']>;
    agreementId_gte?: Maybe<Scalars['Bytes']>;
    agreementId_lte?: Maybe<Scalars['Bytes']>;
    agreementId_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementId_not_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementId_contains?: Maybe<Scalars['Bytes']>;
    agreementId_not_contains?: Maybe<Scalars['Bytes']>;
    penaltyAccount?: Maybe<Scalars['Bytes']>;
    penaltyAccount_not?: Maybe<Scalars['Bytes']>;
    penaltyAccount_gt?: Maybe<Scalars['Bytes']>;
    penaltyAccount_lt?: Maybe<Scalars['Bytes']>;
    penaltyAccount_gte?: Maybe<Scalars['Bytes']>;
    penaltyAccount_lte?: Maybe<Scalars['Bytes']>;
    penaltyAccount_in?: Maybe<Array<Scalars['Bytes']>>;
    penaltyAccount_not_in?: Maybe<Array<Scalars['Bytes']>>;
    penaltyAccount_contains?: Maybe<Scalars['Bytes']>;
    penaltyAccount_not_contains?: Maybe<Scalars['Bytes']>;
    bondAccount?: Maybe<Scalars['Bytes']>;
    bondAccount_not?: Maybe<Scalars['Bytes']>;
    bondAccount_gt?: Maybe<Scalars['Bytes']>;
    bondAccount_lt?: Maybe<Scalars['Bytes']>;
    bondAccount_gte?: Maybe<Scalars['Bytes']>;
    bondAccount_lte?: Maybe<Scalars['Bytes']>;
    bondAccount_in?: Maybe<Array<Scalars['Bytes']>>;
    bondAccount_not_in?: Maybe<Array<Scalars['Bytes']>>;
    bondAccount_contains?: Maybe<Scalars['Bytes']>;
    bondAccount_not_contains?: Maybe<Scalars['Bytes']>;
    rewardAmount?: Maybe<Scalars['BigInt']>;
    rewardAmount_not?: Maybe<Scalars['BigInt']>;
    rewardAmount_gt?: Maybe<Scalars['BigInt']>;
    rewardAmount_lt?: Maybe<Scalars['BigInt']>;
    rewardAmount_gte?: Maybe<Scalars['BigInt']>;
    rewardAmount_lte?: Maybe<Scalars['BigInt']>;
    rewardAmount_in?: Maybe<Array<Scalars['BigInt']>>;
    rewardAmount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    bailoutAmount?: Maybe<Scalars['BigInt']>;
    bailoutAmount_not?: Maybe<Scalars['BigInt']>;
    bailoutAmount_gt?: Maybe<Scalars['BigInt']>;
    bailoutAmount_lt?: Maybe<Scalars['BigInt']>;
    bailoutAmount_gte?: Maybe<Scalars['BigInt']>;
    bailoutAmount_lte?: Maybe<Scalars['BigInt']>;
    bailoutAmount_in?: Maybe<Array<Scalars['BigInt']>>;
    bailoutAmount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    deposit?: Maybe<Scalars['BigInt']>;
    deposit_not?: Maybe<Scalars['BigInt']>;
    deposit_gt?: Maybe<Scalars['BigInt']>;
    deposit_lt?: Maybe<Scalars['BigInt']>;
    deposit_gte?: Maybe<Scalars['BigInt']>;
    deposit_lte?: Maybe<Scalars['BigInt']>;
    deposit_in?: Maybe<Array<Scalars['BigInt']>>;
    deposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    flowRateAtLiquidation?: Maybe<Scalars['BigInt']>;
    flowRateAtLiquidation_not?: Maybe<Scalars['BigInt']>;
    flowRateAtLiquidation_gt?: Maybe<Scalars['BigInt']>;
    flowRateAtLiquidation_lt?: Maybe<Scalars['BigInt']>;
    flowRateAtLiquidation_gte?: Maybe<Scalars['BigInt']>;
    flowRateAtLiquidation_lte?: Maybe<Scalars['BigInt']>;
    flowRateAtLiquidation_in?: Maybe<Array<Scalars['BigInt']>>;
    flowRateAtLiquidation_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<AgreementLiquidatedByEvent_Filter>>>;
    or?: Maybe<Array<Maybe<AgreementLiquidatedByEvent_Filter>>>;
};
export declare enum AgreementLiquidatedByEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    LiquidatorAccount = "liquidatorAccount",
    AgreementClass = "agreementClass",
    AgreementId = "agreementId",
    PenaltyAccount = "penaltyAccount",
    BondAccount = "bondAccount",
    RewardAmount = "rewardAmount",
    BailoutAmount = "bailoutAmount",
    Deposit = "deposit",
    FlowRateAtLiquidation = "flowRateAtLiquidation"
}
export type AgreementLiquidatedV2Event = Event & {
    __typename?: 'AgreementLiquidatedV2Event';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `liquidatorAccount` (executor of liquidation)
     * addresses[2] = `targetAccount` (the sender of the flow/stream)
     * addresses[3] = `rewardAmountReceiver` (the address receiving the reward) addresses
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    agreementClass: Scalars['Bytes'];
    agreementId: Scalars['Bytes'];
    liquidatorAccount: Scalars['Bytes'];
    targetAccount: Scalars['Bytes'];
    rewardAmountReceiver: Scalars['Bytes'];
    rewardAmount: Scalars['BigInt'];
    targetAccountBalanceDelta: Scalars['BigInt'];
    version: Scalars['BigInt'];
    liquidationType: Scalars['Int'];
    /** The full deposit amount of the stream that was liquidated. */
    deposit: Scalars['BigInt'];
    /** The flow rate of the stream at the time of liquidation. */
    flowRateAtLiquidation: Scalars['BigInt'];
    /** TO BE DEPRECATED in v2 endpoint - use rewardAmountReceiver instead */
    rewardAccount: Scalars['Bytes'];
};
export type AgreementLiquidatedV2Event_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    agreementClass?: Maybe<Scalars['Bytes']>;
    agreementClass_not?: Maybe<Scalars['Bytes']>;
    agreementClass_gt?: Maybe<Scalars['Bytes']>;
    agreementClass_lt?: Maybe<Scalars['Bytes']>;
    agreementClass_gte?: Maybe<Scalars['Bytes']>;
    agreementClass_lte?: Maybe<Scalars['Bytes']>;
    agreementClass_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementClass_not_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementClass_contains?: Maybe<Scalars['Bytes']>;
    agreementClass_not_contains?: Maybe<Scalars['Bytes']>;
    agreementId?: Maybe<Scalars['Bytes']>;
    agreementId_not?: Maybe<Scalars['Bytes']>;
    agreementId_gt?: Maybe<Scalars['Bytes']>;
    agreementId_lt?: Maybe<Scalars['Bytes']>;
    agreementId_gte?: Maybe<Scalars['Bytes']>;
    agreementId_lte?: Maybe<Scalars['Bytes']>;
    agreementId_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementId_not_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementId_contains?: Maybe<Scalars['Bytes']>;
    agreementId_not_contains?: Maybe<Scalars['Bytes']>;
    liquidatorAccount?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_not?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_gt?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_lt?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_gte?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_lte?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_in?: Maybe<Array<Scalars['Bytes']>>;
    liquidatorAccount_not_in?: Maybe<Array<Scalars['Bytes']>>;
    liquidatorAccount_contains?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_not_contains?: Maybe<Scalars['Bytes']>;
    targetAccount?: Maybe<Scalars['Bytes']>;
    targetAccount_not?: Maybe<Scalars['Bytes']>;
    targetAccount_gt?: Maybe<Scalars['Bytes']>;
    targetAccount_lt?: Maybe<Scalars['Bytes']>;
    targetAccount_gte?: Maybe<Scalars['Bytes']>;
    targetAccount_lte?: Maybe<Scalars['Bytes']>;
    targetAccount_in?: Maybe<Array<Scalars['Bytes']>>;
    targetAccount_not_in?: Maybe<Array<Scalars['Bytes']>>;
    targetAccount_contains?: Maybe<Scalars['Bytes']>;
    targetAccount_not_contains?: Maybe<Scalars['Bytes']>;
    rewardAmountReceiver?: Maybe<Scalars['Bytes']>;
    rewardAmountReceiver_not?: Maybe<Scalars['Bytes']>;
    rewardAmountReceiver_gt?: Maybe<Scalars['Bytes']>;
    rewardAmountReceiver_lt?: Maybe<Scalars['Bytes']>;
    rewardAmountReceiver_gte?: Maybe<Scalars['Bytes']>;
    rewardAmountReceiver_lte?: Maybe<Scalars['Bytes']>;
    rewardAmountReceiver_in?: Maybe<Array<Scalars['Bytes']>>;
    rewardAmountReceiver_not_in?: Maybe<Array<Scalars['Bytes']>>;
    rewardAmountReceiver_contains?: Maybe<Scalars['Bytes']>;
    rewardAmountReceiver_not_contains?: Maybe<Scalars['Bytes']>;
    rewardAmount?: Maybe<Scalars['BigInt']>;
    rewardAmount_not?: Maybe<Scalars['BigInt']>;
    rewardAmount_gt?: Maybe<Scalars['BigInt']>;
    rewardAmount_lt?: Maybe<Scalars['BigInt']>;
    rewardAmount_gte?: Maybe<Scalars['BigInt']>;
    rewardAmount_lte?: Maybe<Scalars['BigInt']>;
    rewardAmount_in?: Maybe<Array<Scalars['BigInt']>>;
    rewardAmount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    targetAccountBalanceDelta?: Maybe<Scalars['BigInt']>;
    targetAccountBalanceDelta_not?: Maybe<Scalars['BigInt']>;
    targetAccountBalanceDelta_gt?: Maybe<Scalars['BigInt']>;
    targetAccountBalanceDelta_lt?: Maybe<Scalars['BigInt']>;
    targetAccountBalanceDelta_gte?: Maybe<Scalars['BigInt']>;
    targetAccountBalanceDelta_lte?: Maybe<Scalars['BigInt']>;
    targetAccountBalanceDelta_in?: Maybe<Array<Scalars['BigInt']>>;
    targetAccountBalanceDelta_not_in?: Maybe<Array<Scalars['BigInt']>>;
    version?: Maybe<Scalars['BigInt']>;
    version_not?: Maybe<Scalars['BigInt']>;
    version_gt?: Maybe<Scalars['BigInt']>;
    version_lt?: Maybe<Scalars['BigInt']>;
    version_gte?: Maybe<Scalars['BigInt']>;
    version_lte?: Maybe<Scalars['BigInt']>;
    version_in?: Maybe<Array<Scalars['BigInt']>>;
    version_not_in?: Maybe<Array<Scalars['BigInt']>>;
    liquidationType?: Maybe<Scalars['Int']>;
    liquidationType_not?: Maybe<Scalars['Int']>;
    liquidationType_gt?: Maybe<Scalars['Int']>;
    liquidationType_lt?: Maybe<Scalars['Int']>;
    liquidationType_gte?: Maybe<Scalars['Int']>;
    liquidationType_lte?: Maybe<Scalars['Int']>;
    liquidationType_in?: Maybe<Array<Scalars['Int']>>;
    liquidationType_not_in?: Maybe<Array<Scalars['Int']>>;
    deposit?: Maybe<Scalars['BigInt']>;
    deposit_not?: Maybe<Scalars['BigInt']>;
    deposit_gt?: Maybe<Scalars['BigInt']>;
    deposit_lt?: Maybe<Scalars['BigInt']>;
    deposit_gte?: Maybe<Scalars['BigInt']>;
    deposit_lte?: Maybe<Scalars['BigInt']>;
    deposit_in?: Maybe<Array<Scalars['BigInt']>>;
    deposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    flowRateAtLiquidation?: Maybe<Scalars['BigInt']>;
    flowRateAtLiquidation_not?: Maybe<Scalars['BigInt']>;
    flowRateAtLiquidation_gt?: Maybe<Scalars['BigInt']>;
    flowRateAtLiquidation_lt?: Maybe<Scalars['BigInt']>;
    flowRateAtLiquidation_gte?: Maybe<Scalars['BigInt']>;
    flowRateAtLiquidation_lte?: Maybe<Scalars['BigInt']>;
    flowRateAtLiquidation_in?: Maybe<Array<Scalars['BigInt']>>;
    flowRateAtLiquidation_not_in?: Maybe<Array<Scalars['BigInt']>>;
    rewardAccount?: Maybe<Scalars['Bytes']>;
    rewardAccount_not?: Maybe<Scalars['Bytes']>;
    rewardAccount_gt?: Maybe<Scalars['Bytes']>;
    rewardAccount_lt?: Maybe<Scalars['Bytes']>;
    rewardAccount_gte?: Maybe<Scalars['Bytes']>;
    rewardAccount_lte?: Maybe<Scalars['Bytes']>;
    rewardAccount_in?: Maybe<Array<Scalars['Bytes']>>;
    rewardAccount_not_in?: Maybe<Array<Scalars['Bytes']>>;
    rewardAccount_contains?: Maybe<Scalars['Bytes']>;
    rewardAccount_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<AgreementLiquidatedV2Event_Filter>>>;
    or?: Maybe<Array<Maybe<AgreementLiquidatedV2Event_Filter>>>;
};
export declare enum AgreementLiquidatedV2Event_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    AgreementClass = "agreementClass",
    AgreementId = "agreementId",
    LiquidatorAccount = "liquidatorAccount",
    TargetAccount = "targetAccount",
    RewardAmountReceiver = "rewardAmountReceiver",
    RewardAmount = "rewardAmount",
    TargetAccountBalanceDelta = "targetAccountBalanceDelta",
    Version = "version",
    LiquidationType = "liquidationType",
    Deposit = "deposit",
    FlowRateAtLiquidation = "flowRateAtLiquidation",
    RewardAccount = "rewardAccount"
}
export type AppRegisteredEvent = Event & {
    __typename?: 'AppRegisteredEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    app: Scalars['Bytes'];
};
export type AppRegisteredEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    app?: Maybe<Scalars['Bytes']>;
    app_not?: Maybe<Scalars['Bytes']>;
    app_gt?: Maybe<Scalars['Bytes']>;
    app_lt?: Maybe<Scalars['Bytes']>;
    app_gte?: Maybe<Scalars['Bytes']>;
    app_lte?: Maybe<Scalars['Bytes']>;
    app_in?: Maybe<Array<Scalars['Bytes']>>;
    app_not_in?: Maybe<Array<Scalars['Bytes']>>;
    app_contains?: Maybe<Scalars['Bytes']>;
    app_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<AppRegisteredEvent_Filter>>>;
    or?: Maybe<Array<Maybe<AppRegisteredEvent_Filter>>>;
};
export declare enum AppRegisteredEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    App = "app"
}
export type BlockChangedFilter = {
    number_gte: Scalars['Int'];
};
export type Block_Height = {
    hash?: Maybe<Scalars['Bytes']>;
    number?: Maybe<Scalars['Int']>;
    number_gte?: Maybe<Scalars['Int']>;
};
export type BondIncreasedEvent = Event & {
    __typename?: 'BondIncreasedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    /** The address of the `token` (supertoken). */
    token: Scalars['Bytes'];
    /** The additional amount added to the bond by the current Patrician In Charge (PIC). */
    additionalBond: Scalars['BigInt'];
};
export type BondIncreasedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    additionalBond?: Maybe<Scalars['BigInt']>;
    additionalBond_not?: Maybe<Scalars['BigInt']>;
    additionalBond_gt?: Maybe<Scalars['BigInt']>;
    additionalBond_lt?: Maybe<Scalars['BigInt']>;
    additionalBond_gte?: Maybe<Scalars['BigInt']>;
    additionalBond_lte?: Maybe<Scalars['BigInt']>;
    additionalBond_in?: Maybe<Array<Scalars['BigInt']>>;
    additionalBond_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<BondIncreasedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<BondIncreasedEvent_Filter>>>;
};
export declare enum BondIncreasedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    AdditionalBond = "additionalBond"
}
export type BurnedEvent = Event & {
    __typename?: 'BurnedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `from`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    operator: Scalars['Bytes'];
    from: Scalars['Bytes'];
    token: Scalars['Bytes'];
    amount: Scalars['BigInt'];
    data: Scalars['Bytes'];
    operatorData: Scalars['Bytes'];
};
export type BurnedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    operator?: Maybe<Scalars['Bytes']>;
    operator_not?: Maybe<Scalars['Bytes']>;
    operator_gt?: Maybe<Scalars['Bytes']>;
    operator_lt?: Maybe<Scalars['Bytes']>;
    operator_gte?: Maybe<Scalars['Bytes']>;
    operator_lte?: Maybe<Scalars['Bytes']>;
    operator_in?: Maybe<Array<Scalars['Bytes']>>;
    operator_not_in?: Maybe<Array<Scalars['Bytes']>>;
    operator_contains?: Maybe<Scalars['Bytes']>;
    operator_not_contains?: Maybe<Scalars['Bytes']>;
    from?: Maybe<Scalars['Bytes']>;
    from_not?: Maybe<Scalars['Bytes']>;
    from_gt?: Maybe<Scalars['Bytes']>;
    from_lt?: Maybe<Scalars['Bytes']>;
    from_gte?: Maybe<Scalars['Bytes']>;
    from_lte?: Maybe<Scalars['Bytes']>;
    from_in?: Maybe<Array<Scalars['Bytes']>>;
    from_not_in?: Maybe<Array<Scalars['Bytes']>>;
    from_contains?: Maybe<Scalars['Bytes']>;
    from_not_contains?: Maybe<Scalars['Bytes']>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    amount?: Maybe<Scalars['BigInt']>;
    amount_not?: Maybe<Scalars['BigInt']>;
    amount_gt?: Maybe<Scalars['BigInt']>;
    amount_lt?: Maybe<Scalars['BigInt']>;
    amount_gte?: Maybe<Scalars['BigInt']>;
    amount_lte?: Maybe<Scalars['BigInt']>;
    amount_in?: Maybe<Array<Scalars['BigInt']>>;
    amount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    data?: Maybe<Scalars['Bytes']>;
    data_not?: Maybe<Scalars['Bytes']>;
    data_gt?: Maybe<Scalars['Bytes']>;
    data_lt?: Maybe<Scalars['Bytes']>;
    data_gte?: Maybe<Scalars['Bytes']>;
    data_lte?: Maybe<Scalars['Bytes']>;
    data_in?: Maybe<Array<Scalars['Bytes']>>;
    data_not_in?: Maybe<Array<Scalars['Bytes']>>;
    data_contains?: Maybe<Scalars['Bytes']>;
    data_not_contains?: Maybe<Scalars['Bytes']>;
    operatorData?: Maybe<Scalars['Bytes']>;
    operatorData_not?: Maybe<Scalars['Bytes']>;
    operatorData_gt?: Maybe<Scalars['Bytes']>;
    operatorData_lt?: Maybe<Scalars['Bytes']>;
    operatorData_gte?: Maybe<Scalars['Bytes']>;
    operatorData_lte?: Maybe<Scalars['Bytes']>;
    operatorData_in?: Maybe<Array<Scalars['Bytes']>>;
    operatorData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    operatorData_contains?: Maybe<Scalars['Bytes']>;
    operatorData_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<BurnedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<BurnedEvent_Filter>>>;
};
export declare enum BurnedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Operator = "operator",
    From = "from",
    Token = "token",
    Amount = "amount",
    Data = "data",
    OperatorData = "operatorData"
}
export type CfAv1LiquidationPeriodChangedEvent = Event & {
    __typename?: 'CFAv1LiquidationPeriodChangedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** The address of the governance contract the event was emitted from. */
    governanceAddress: Scalars['Bytes'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    order: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    host: Scalars['Bytes'];
    superToken: Scalars['Bytes'];
    isKeySet: Scalars['Boolean'];
    liquidationPeriod: Scalars['BigInt'];
};
export type CfAv1LiquidationPeriodChangedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    governanceAddress?: Maybe<Scalars['Bytes']>;
    governanceAddress_not?: Maybe<Scalars['Bytes']>;
    governanceAddress_gt?: Maybe<Scalars['Bytes']>;
    governanceAddress_lt?: Maybe<Scalars['Bytes']>;
    governanceAddress_gte?: Maybe<Scalars['Bytes']>;
    governanceAddress_lte?: Maybe<Scalars['Bytes']>;
    governanceAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_contains?: Maybe<Scalars['Bytes']>;
    governanceAddress_not_contains?: Maybe<Scalars['Bytes']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    host?: Maybe<Scalars['Bytes']>;
    host_not?: Maybe<Scalars['Bytes']>;
    host_gt?: Maybe<Scalars['Bytes']>;
    host_lt?: Maybe<Scalars['Bytes']>;
    host_gte?: Maybe<Scalars['Bytes']>;
    host_lte?: Maybe<Scalars['Bytes']>;
    host_in?: Maybe<Array<Scalars['Bytes']>>;
    host_not_in?: Maybe<Array<Scalars['Bytes']>>;
    host_contains?: Maybe<Scalars['Bytes']>;
    host_not_contains?: Maybe<Scalars['Bytes']>;
    superToken?: Maybe<Scalars['Bytes']>;
    superToken_not?: Maybe<Scalars['Bytes']>;
    superToken_gt?: Maybe<Scalars['Bytes']>;
    superToken_lt?: Maybe<Scalars['Bytes']>;
    superToken_gte?: Maybe<Scalars['Bytes']>;
    superToken_lte?: Maybe<Scalars['Bytes']>;
    superToken_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_not_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_contains?: Maybe<Scalars['Bytes']>;
    superToken_not_contains?: Maybe<Scalars['Bytes']>;
    isKeySet?: Maybe<Scalars['Boolean']>;
    isKeySet_not?: Maybe<Scalars['Boolean']>;
    isKeySet_in?: Maybe<Array<Scalars['Boolean']>>;
    isKeySet_not_in?: Maybe<Array<Scalars['Boolean']>>;
    liquidationPeriod?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_not?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_gt?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_lt?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_gte?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_lte?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_in?: Maybe<Array<Scalars['BigInt']>>;
    liquidationPeriod_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<CfAv1LiquidationPeriodChangedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<CfAv1LiquidationPeriodChangedEvent_Filter>>>;
};
export declare enum CfAv1LiquidationPeriodChangedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    GovernanceAddress = "governanceAddress",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    Order = "order",
    LogIndex = "logIndex",
    Host = "host",
    SuperToken = "superToken",
    IsKeySet = "isKeySet",
    LiquidationPeriod = "liquidationPeriod"
}
export type ConfigChangedEvent = Event & {
    __typename?: 'ConfigChangedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** The address of the governance contract the event was emitted from. */
    governanceAddress: Scalars['Bytes'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    host: Scalars['Bytes'];
    superToken: Scalars['Bytes'];
    key: Scalars['Bytes'];
    isKeySet: Scalars['Boolean'];
    value: Scalars['BigInt'];
};
export type ConfigChangedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    governanceAddress?: Maybe<Scalars['Bytes']>;
    governanceAddress_not?: Maybe<Scalars['Bytes']>;
    governanceAddress_gt?: Maybe<Scalars['Bytes']>;
    governanceAddress_lt?: Maybe<Scalars['Bytes']>;
    governanceAddress_gte?: Maybe<Scalars['Bytes']>;
    governanceAddress_lte?: Maybe<Scalars['Bytes']>;
    governanceAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_contains?: Maybe<Scalars['Bytes']>;
    governanceAddress_not_contains?: Maybe<Scalars['Bytes']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    host?: Maybe<Scalars['Bytes']>;
    host_not?: Maybe<Scalars['Bytes']>;
    host_gt?: Maybe<Scalars['Bytes']>;
    host_lt?: Maybe<Scalars['Bytes']>;
    host_gte?: Maybe<Scalars['Bytes']>;
    host_lte?: Maybe<Scalars['Bytes']>;
    host_in?: Maybe<Array<Scalars['Bytes']>>;
    host_not_in?: Maybe<Array<Scalars['Bytes']>>;
    host_contains?: Maybe<Scalars['Bytes']>;
    host_not_contains?: Maybe<Scalars['Bytes']>;
    superToken?: Maybe<Scalars['Bytes']>;
    superToken_not?: Maybe<Scalars['Bytes']>;
    superToken_gt?: Maybe<Scalars['Bytes']>;
    superToken_lt?: Maybe<Scalars['Bytes']>;
    superToken_gte?: Maybe<Scalars['Bytes']>;
    superToken_lte?: Maybe<Scalars['Bytes']>;
    superToken_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_not_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_contains?: Maybe<Scalars['Bytes']>;
    superToken_not_contains?: Maybe<Scalars['Bytes']>;
    key?: Maybe<Scalars['Bytes']>;
    key_not?: Maybe<Scalars['Bytes']>;
    key_gt?: Maybe<Scalars['Bytes']>;
    key_lt?: Maybe<Scalars['Bytes']>;
    key_gte?: Maybe<Scalars['Bytes']>;
    key_lte?: Maybe<Scalars['Bytes']>;
    key_in?: Maybe<Array<Scalars['Bytes']>>;
    key_not_in?: Maybe<Array<Scalars['Bytes']>>;
    key_contains?: Maybe<Scalars['Bytes']>;
    key_not_contains?: Maybe<Scalars['Bytes']>;
    isKeySet?: Maybe<Scalars['Boolean']>;
    isKeySet_not?: Maybe<Scalars['Boolean']>;
    isKeySet_in?: Maybe<Array<Scalars['Boolean']>>;
    isKeySet_not_in?: Maybe<Array<Scalars['Boolean']>>;
    value?: Maybe<Scalars['BigInt']>;
    value_not?: Maybe<Scalars['BigInt']>;
    value_gt?: Maybe<Scalars['BigInt']>;
    value_lt?: Maybe<Scalars['BigInt']>;
    value_gte?: Maybe<Scalars['BigInt']>;
    value_lte?: Maybe<Scalars['BigInt']>;
    value_in?: Maybe<Array<Scalars['BigInt']>>;
    value_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<ConfigChangedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<ConfigChangedEvent_Filter>>>;
};
export declare enum ConfigChangedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    GovernanceAddress = "governanceAddress",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Host = "host",
    SuperToken = "superToken",
    Key = "key",
    IsKeySet = "isKeySet",
    Value = "value"
}
export type CustomSuperTokenCreatedEvent = Event & {
    __typename?: 'CustomSuperTokenCreatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
};
export type CustomSuperTokenCreatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<CustomSuperTokenCreatedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<CustomSuperTokenCreatedEvent_Filter>>>;
};
export declare enum CustomSuperTokenCreatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token"
}
/** Event: An interface which is shared by all event entities and contains basic transaction data. */
export type Event = {
    /** The id of the event entity. */
    id: Scalars['ID'];
    /** The block number which the event was logged in. */
    blockNumber: Scalars['BigInt'];
    /** The index of the event, e.g. first event emitted would have `logIndex` of 0. */
    logIndex: Scalars['BigInt'];
    /**
     * A number used internally to sort the order of transactions.
     * The formula: `blockNumber * ORDER_MULTIPLIER + logIndex`
     * where: ORDER_MULTIPLIER = 10000
     */
    order: Scalars['BigInt'];
    /** The name of the event - is a 1-to-1 match with the name in our smart contracts. */
    name: Scalars['String'];
    /**
     * Contains the addresses for accounts that were "impacted" by the event.
     * This typically involves accounts which experienced a state change as a result of the transaction which emitted this event.
     */
    addresses: Array<Scalars['Bytes']>;
    /** The block timestamp which the event was logged in. */
    timestamp: Scalars['BigInt'];
    /** The transaction hash of the transaction that the event was logged in. */
    transactionHash: Scalars['Bytes'];
    /** The gas price of the transaction that the event was logged in. */
    gasPrice: Scalars['BigInt'];
    /** The gas used for this transaction. */
    gasUsed: Scalars['BigInt'];
};
export type Event_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<Event_Filter>>>;
    or?: Maybe<Array<Maybe<Event_Filter>>>;
};
export declare enum Event_OrderBy {
    Id = "id",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Name = "name",
    Addresses = "addresses",
    Timestamp = "timestamp",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed"
}
export type ExitRateChangedEvent = Event & {
    __typename?: 'ExitRateChangedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    /** The address of the `token` (supertoken). */
    token: Scalars['Bytes'];
    /** The flowrate at which the bond is streamed back to the Patrician In Charge. */
    exitRate: Scalars['BigInt'];
};
export type ExitRateChangedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    exitRate?: Maybe<Scalars['BigInt']>;
    exitRate_not?: Maybe<Scalars['BigInt']>;
    exitRate_gt?: Maybe<Scalars['BigInt']>;
    exitRate_lt?: Maybe<Scalars['BigInt']>;
    exitRate_gte?: Maybe<Scalars['BigInt']>;
    exitRate_lte?: Maybe<Scalars['BigInt']>;
    exitRate_in?: Maybe<Array<Scalars['BigInt']>>;
    exitRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<ExitRateChangedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<ExitRateChangedEvent_Filter>>>;
};
export declare enum ExitRateChangedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    ExitRate = "exitRate"
}
/** FlowOperator: A higher order entity that of a flow operator for an `AccountTokenSnapshot`. */
export type FlowOperator = {
    __typename?: 'FlowOperator';
    /** ID composed of: flowOperator-token-sender */
    id: Scalars['ID'];
    createdAtTimestamp: Scalars['BigInt'];
    createdAtBlockNumber: Scalars['BigInt'];
    updatedAtTimestamp: Scalars['BigInt'];
    updatedAtBlockNumber: Scalars['BigInt'];
    /**
     * The permissions granted to the `flowOperator`.
     * Bitmask representation:
     * Delete | Update | Create
     * | D | U | C |
     * | 0 | 0 | 0 |
     */
    permissions: Scalars['Int'];
    /** The flow rate allowance granted to the `flowOperator` by the `sender`. This can be reset if the `sender` updates the `flowOperator` flow rate allowance. */
    flowRateAllowanceGranted: Scalars['BigInt'];
    /**
     * The remaining flow rate allowance the `flowOperator` has.
     * This will go down every time when the `flowOperator` uses the allowance, that is, if they increase flowRate for `sender` or create a new flow on behalf of `sender`.
     * It can only be reset if the `sender` updates the flow rate allowance.
     * NOTE: this value will NOT go down if max flow rate allowance is set.
     */
    flowRateAllowanceRemaining: Scalars['BigInt'];
    flowOperator: Scalars['Bytes'];
    sender: Account;
    token: Token;
    accountTokenSnapshot: AccountTokenSnapshot;
    flowOperatorUpdatedEvents: Array<FlowOperatorUpdatedEvent>;
};
/** FlowOperator: A higher order entity that of a flow operator for an `AccountTokenSnapshot`. */
export type FlowOperatorFlowOperatorUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowOperatorUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowOperatorUpdatedEvent_Filter>;
};
export type FlowOperatorUpdatedEvent = Event & {
    __typename?: 'FlowOperatorUpdatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = sender
     * addresses[2] = `flowOperator`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    /** The address of the `token` being streamed. */
    token: Scalars['Bytes'];
    sender: Scalars['Bytes'];
    /**
     * The permissions granted to the `flowOperator`.
     * Octo bitmask representation.
     */
    permissions: Scalars['Int'];
    flowRateAllowance: Scalars['BigInt'];
    flowOperator: FlowOperator;
};
export type FlowOperatorUpdatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    sender?: Maybe<Scalars['Bytes']>;
    sender_not?: Maybe<Scalars['Bytes']>;
    sender_gt?: Maybe<Scalars['Bytes']>;
    sender_lt?: Maybe<Scalars['Bytes']>;
    sender_gte?: Maybe<Scalars['Bytes']>;
    sender_lte?: Maybe<Scalars['Bytes']>;
    sender_in?: Maybe<Array<Scalars['Bytes']>>;
    sender_not_in?: Maybe<Array<Scalars['Bytes']>>;
    sender_contains?: Maybe<Scalars['Bytes']>;
    sender_not_contains?: Maybe<Scalars['Bytes']>;
    permissions?: Maybe<Scalars['Int']>;
    permissions_not?: Maybe<Scalars['Int']>;
    permissions_gt?: Maybe<Scalars['Int']>;
    permissions_lt?: Maybe<Scalars['Int']>;
    permissions_gte?: Maybe<Scalars['Int']>;
    permissions_lte?: Maybe<Scalars['Int']>;
    permissions_in?: Maybe<Array<Scalars['Int']>>;
    permissions_not_in?: Maybe<Array<Scalars['Int']>>;
    flowRateAllowance?: Maybe<Scalars['BigInt']>;
    flowRateAllowance_not?: Maybe<Scalars['BigInt']>;
    flowRateAllowance_gt?: Maybe<Scalars['BigInt']>;
    flowRateAllowance_lt?: Maybe<Scalars['BigInt']>;
    flowRateAllowance_gte?: Maybe<Scalars['BigInt']>;
    flowRateAllowance_lte?: Maybe<Scalars['BigInt']>;
    flowRateAllowance_in?: Maybe<Array<Scalars['BigInt']>>;
    flowRateAllowance_not_in?: Maybe<Array<Scalars['BigInt']>>;
    flowOperator?: Maybe<Scalars['String']>;
    flowOperator_not?: Maybe<Scalars['String']>;
    flowOperator_gt?: Maybe<Scalars['String']>;
    flowOperator_lt?: Maybe<Scalars['String']>;
    flowOperator_gte?: Maybe<Scalars['String']>;
    flowOperator_lte?: Maybe<Scalars['String']>;
    flowOperator_in?: Maybe<Array<Scalars['String']>>;
    flowOperator_not_in?: Maybe<Array<Scalars['String']>>;
    flowOperator_contains?: Maybe<Scalars['String']>;
    flowOperator_contains_nocase?: Maybe<Scalars['String']>;
    flowOperator_not_contains?: Maybe<Scalars['String']>;
    flowOperator_not_contains_nocase?: Maybe<Scalars['String']>;
    flowOperator_starts_with?: Maybe<Scalars['String']>;
    flowOperator_starts_with_nocase?: Maybe<Scalars['String']>;
    flowOperator_not_starts_with?: Maybe<Scalars['String']>;
    flowOperator_not_starts_with_nocase?: Maybe<Scalars['String']>;
    flowOperator_ends_with?: Maybe<Scalars['String']>;
    flowOperator_ends_with_nocase?: Maybe<Scalars['String']>;
    flowOperator_not_ends_with?: Maybe<Scalars['String']>;
    flowOperator_not_ends_with_nocase?: Maybe<Scalars['String']>;
    flowOperator_?: Maybe<FlowOperator_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<FlowOperatorUpdatedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<FlowOperatorUpdatedEvent_Filter>>>;
};
export declare enum FlowOperatorUpdatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Sender = "sender",
    Permissions = "permissions",
    FlowRateAllowance = "flowRateAllowance",
    FlowOperator = "flowOperator",
    FlowOperator__id = "flowOperator__id",
    FlowOperator__createdAtTimestamp = "flowOperator__createdAtTimestamp",
    FlowOperator__createdAtBlockNumber = "flowOperator__createdAtBlockNumber",
    FlowOperator__updatedAtTimestamp = "flowOperator__updatedAtTimestamp",
    FlowOperator__updatedAtBlockNumber = "flowOperator__updatedAtBlockNumber",
    FlowOperator__permissions = "flowOperator__permissions",
    FlowOperator__flowRateAllowanceGranted = "flowOperator__flowRateAllowanceGranted",
    FlowOperator__flowRateAllowanceRemaining = "flowOperator__flowRateAllowanceRemaining",
    FlowOperator__flowOperator = "flowOperator__flowOperator"
}
export type FlowOperator_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    createdAtTimestamp?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    permissions?: Maybe<Scalars['Int']>;
    permissions_not?: Maybe<Scalars['Int']>;
    permissions_gt?: Maybe<Scalars['Int']>;
    permissions_lt?: Maybe<Scalars['Int']>;
    permissions_gte?: Maybe<Scalars['Int']>;
    permissions_lte?: Maybe<Scalars['Int']>;
    permissions_in?: Maybe<Array<Scalars['Int']>>;
    permissions_not_in?: Maybe<Array<Scalars['Int']>>;
    flowRateAllowanceGranted?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceGranted_not?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceGranted_gt?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceGranted_lt?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceGranted_gte?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceGranted_lte?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceGranted_in?: Maybe<Array<Scalars['BigInt']>>;
    flowRateAllowanceGranted_not_in?: Maybe<Array<Scalars['BigInt']>>;
    flowRateAllowanceRemaining?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceRemaining_not?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceRemaining_gt?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceRemaining_lt?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceRemaining_gte?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceRemaining_lte?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceRemaining_in?: Maybe<Array<Scalars['BigInt']>>;
    flowRateAllowanceRemaining_not_in?: Maybe<Array<Scalars['BigInt']>>;
    flowOperator?: Maybe<Scalars['Bytes']>;
    flowOperator_not?: Maybe<Scalars['Bytes']>;
    flowOperator_gt?: Maybe<Scalars['Bytes']>;
    flowOperator_lt?: Maybe<Scalars['Bytes']>;
    flowOperator_gte?: Maybe<Scalars['Bytes']>;
    flowOperator_lte?: Maybe<Scalars['Bytes']>;
    flowOperator_in?: Maybe<Array<Scalars['Bytes']>>;
    flowOperator_not_in?: Maybe<Array<Scalars['Bytes']>>;
    flowOperator_contains?: Maybe<Scalars['Bytes']>;
    flowOperator_not_contains?: Maybe<Scalars['Bytes']>;
    sender?: Maybe<Scalars['String']>;
    sender_not?: Maybe<Scalars['String']>;
    sender_gt?: Maybe<Scalars['String']>;
    sender_lt?: Maybe<Scalars['String']>;
    sender_gte?: Maybe<Scalars['String']>;
    sender_lte?: Maybe<Scalars['String']>;
    sender_in?: Maybe<Array<Scalars['String']>>;
    sender_not_in?: Maybe<Array<Scalars['String']>>;
    sender_contains?: Maybe<Scalars['String']>;
    sender_contains_nocase?: Maybe<Scalars['String']>;
    sender_not_contains?: Maybe<Scalars['String']>;
    sender_not_contains_nocase?: Maybe<Scalars['String']>;
    sender_starts_with?: Maybe<Scalars['String']>;
    sender_starts_with_nocase?: Maybe<Scalars['String']>;
    sender_not_starts_with?: Maybe<Scalars['String']>;
    sender_not_starts_with_nocase?: Maybe<Scalars['String']>;
    sender_ends_with?: Maybe<Scalars['String']>;
    sender_ends_with_nocase?: Maybe<Scalars['String']>;
    sender_not_ends_with?: Maybe<Scalars['String']>;
    sender_not_ends_with_nocase?: Maybe<Scalars['String']>;
    sender_?: Maybe<Account_Filter>;
    token?: Maybe<Scalars['String']>;
    token_not?: Maybe<Scalars['String']>;
    token_gt?: Maybe<Scalars['String']>;
    token_lt?: Maybe<Scalars['String']>;
    token_gte?: Maybe<Scalars['String']>;
    token_lte?: Maybe<Scalars['String']>;
    token_in?: Maybe<Array<Scalars['String']>>;
    token_not_in?: Maybe<Array<Scalars['String']>>;
    token_contains?: Maybe<Scalars['String']>;
    token_contains_nocase?: Maybe<Scalars['String']>;
    token_not_contains?: Maybe<Scalars['String']>;
    token_not_contains_nocase?: Maybe<Scalars['String']>;
    token_starts_with?: Maybe<Scalars['String']>;
    token_starts_with_nocase?: Maybe<Scalars['String']>;
    token_not_starts_with?: Maybe<Scalars['String']>;
    token_not_starts_with_nocase?: Maybe<Scalars['String']>;
    token_ends_with?: Maybe<Scalars['String']>;
    token_ends_with_nocase?: Maybe<Scalars['String']>;
    token_not_ends_with?: Maybe<Scalars['String']>;
    token_not_ends_with_nocase?: Maybe<Scalars['String']>;
    token_?: Maybe<Token_Filter>;
    accountTokenSnapshot?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not?: Maybe<Scalars['String']>;
    accountTokenSnapshot_gt?: Maybe<Scalars['String']>;
    accountTokenSnapshot_lt?: Maybe<Scalars['String']>;
    accountTokenSnapshot_gte?: Maybe<Scalars['String']>;
    accountTokenSnapshot_lte?: Maybe<Scalars['String']>;
    accountTokenSnapshot_in?: Maybe<Array<Scalars['String']>>;
    accountTokenSnapshot_not_in?: Maybe<Array<Scalars['String']>>;
    accountTokenSnapshot_contains?: Maybe<Scalars['String']>;
    accountTokenSnapshot_contains_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_contains?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_contains_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_starts_with?: Maybe<Scalars['String']>;
    accountTokenSnapshot_starts_with_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_starts_with?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_starts_with_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_ends_with?: Maybe<Scalars['String']>;
    accountTokenSnapshot_ends_with_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_ends_with?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_ends_with_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_?: Maybe<AccountTokenSnapshot_Filter>;
    flowOperatorUpdatedEvents_?: Maybe<FlowOperatorUpdatedEvent_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<FlowOperator_Filter>>>;
    or?: Maybe<Array<Maybe<FlowOperator_Filter>>>;
};
export declare enum FlowOperator_OrderBy {
    Id = "id",
    CreatedAtTimestamp = "createdAtTimestamp",
    CreatedAtBlockNumber = "createdAtBlockNumber",
    UpdatedAtTimestamp = "updatedAtTimestamp",
    UpdatedAtBlockNumber = "updatedAtBlockNumber",
    Permissions = "permissions",
    FlowRateAllowanceGranted = "flowRateAllowanceGranted",
    FlowRateAllowanceRemaining = "flowRateAllowanceRemaining",
    FlowOperator = "flowOperator",
    Sender = "sender",
    Sender__id = "sender__id",
    Sender__createdAtTimestamp = "sender__createdAtTimestamp",
    Sender__createdAtBlockNumber = "sender__createdAtBlockNumber",
    Sender__updatedAtTimestamp = "sender__updatedAtTimestamp",
    Sender__updatedAtBlockNumber = "sender__updatedAtBlockNumber",
    Sender__isSuperApp = "sender__isSuperApp",
    Token = "token",
    Token__id = "token__id",
    Token__createdAtTimestamp = "token__createdAtTimestamp",
    Token__createdAtBlockNumber = "token__createdAtBlockNumber",
    Token__decimals = "token__decimals",
    Token__name = "token__name",
    Token__symbol = "token__symbol",
    Token__isSuperToken = "token__isSuperToken",
    Token__isNativeAssetSuperToken = "token__isNativeAssetSuperToken",
    Token__isListed = "token__isListed",
    Token__underlyingAddress = "token__underlyingAddress",
    AccountTokenSnapshot = "accountTokenSnapshot",
    AccountTokenSnapshot__id = "accountTokenSnapshot__id",
    AccountTokenSnapshot__updatedAtTimestamp = "accountTokenSnapshot__updatedAtTimestamp",
    AccountTokenSnapshot__updatedAtBlockNumber = "accountTokenSnapshot__updatedAtBlockNumber",
    AccountTokenSnapshot__isLiquidationEstimateOptimistic = "accountTokenSnapshot__isLiquidationEstimateOptimistic",
    AccountTokenSnapshot__maybeCriticalAtTimestamp = "accountTokenSnapshot__maybeCriticalAtTimestamp",
    AccountTokenSnapshot__totalNumberOfActiveStreams = "accountTokenSnapshot__totalNumberOfActiveStreams",
    AccountTokenSnapshot__activeOutgoingStreamCount = "accountTokenSnapshot__activeOutgoingStreamCount",
    AccountTokenSnapshot__activeIncomingStreamCount = "accountTokenSnapshot__activeIncomingStreamCount",
    AccountTokenSnapshot__totalNumberOfClosedStreams = "accountTokenSnapshot__totalNumberOfClosedStreams",
    AccountTokenSnapshot__inactiveOutgoingStreamCount = "accountTokenSnapshot__inactiveOutgoingStreamCount",
    AccountTokenSnapshot__inactiveIncomingStreamCount = "accountTokenSnapshot__inactiveIncomingStreamCount",
    AccountTokenSnapshot__totalSubscriptionsWithUnits = "accountTokenSnapshot__totalSubscriptionsWithUnits",
    AccountTokenSnapshot__totalApprovedSubscriptions = "accountTokenSnapshot__totalApprovedSubscriptions",
    AccountTokenSnapshot__balanceUntilUpdatedAt = "accountTokenSnapshot__balanceUntilUpdatedAt",
    AccountTokenSnapshot__totalDeposit = "accountTokenSnapshot__totalDeposit",
    AccountTokenSnapshot__totalNetFlowRate = "accountTokenSnapshot__totalNetFlowRate",
    AccountTokenSnapshot__totalInflowRate = "accountTokenSnapshot__totalInflowRate",
    AccountTokenSnapshot__totalOutflowRate = "accountTokenSnapshot__totalOutflowRate",
    AccountTokenSnapshot__totalAmountStreamedInUntilUpdatedAt = "accountTokenSnapshot__totalAmountStreamedInUntilUpdatedAt",
    AccountTokenSnapshot__totalAmountStreamedOutUntilUpdatedAt = "accountTokenSnapshot__totalAmountStreamedOutUntilUpdatedAt",
    AccountTokenSnapshot__totalAmountStreamedUntilUpdatedAt = "accountTokenSnapshot__totalAmountStreamedUntilUpdatedAt",
    AccountTokenSnapshot__totalAmountTransferredUntilUpdatedAt = "accountTokenSnapshot__totalAmountTransferredUntilUpdatedAt",
    FlowOperatorUpdatedEvents = "flowOperatorUpdatedEvents"
}
/**
 * FlowUpdated: An `Event` entity that is emitted
 * when a flow is created, updated, or deleted.
 */
export type FlowUpdatedEvent = Event & {
    __typename?: 'FlowUpdatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (supertoken)
     * addresses[1] = `sender`
     * addresses[2] = `receiver`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    /** The address of the `token` (supertoken) being streamed. */
    token: Scalars['Bytes'];
    /** The address of the flow sender. */
    sender: Scalars['Bytes'];
    /** The address of the flow receiver. */
    receiver: Scalars['Bytes'];
    /**
     * The address that is executing the flow update transaction.
     * This will be the zero address until the flowOperator feature is live.
     */
    flowOperator: Scalars['Bytes'];
    /** The flow rate per second. */
    flowRate: Scalars['BigInt'];
    /** The total (global/account level) flow rate of `sender` for `token` as of this event. */
    totalSenderFlowRate: Scalars['BigInt'];
    /** The total (global/account level) flow rate of `receiver` for `token` as of this event. */
    totalReceiverFlowRate: Scalars['BigInt'];
    /** The deposit amount put up for the creation of the flow. */
    deposit: Scalars['BigInt'];
    /** Arbitrary bytes (additional data) passed upon flow creation. */
    userData: Scalars['Bytes'];
    /** The previous flow rate, the absolute (positive) value. */
    oldFlowRate: Scalars['BigInt'];
    /**
     * The "type" of the `FlowUpdated` event.
     * 0 = create
     * 1 = update
     * 2 = terminate
     */
    type: Scalars['Int'];
    /**
     * The total amount streamed until the timestamp
     * for the Stream entity linked to this event.
     */
    totalAmountStreamedUntilTimestamp: Scalars['BigInt'];
    /** The stream entity which is being modified. */
    stream: Stream;
};
export type FlowUpdatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    sender?: Maybe<Scalars['Bytes']>;
    sender_not?: Maybe<Scalars['Bytes']>;
    sender_gt?: Maybe<Scalars['Bytes']>;
    sender_lt?: Maybe<Scalars['Bytes']>;
    sender_gte?: Maybe<Scalars['Bytes']>;
    sender_lte?: Maybe<Scalars['Bytes']>;
    sender_in?: Maybe<Array<Scalars['Bytes']>>;
    sender_not_in?: Maybe<Array<Scalars['Bytes']>>;
    sender_contains?: Maybe<Scalars['Bytes']>;
    sender_not_contains?: Maybe<Scalars['Bytes']>;
    receiver?: Maybe<Scalars['Bytes']>;
    receiver_not?: Maybe<Scalars['Bytes']>;
    receiver_gt?: Maybe<Scalars['Bytes']>;
    receiver_lt?: Maybe<Scalars['Bytes']>;
    receiver_gte?: Maybe<Scalars['Bytes']>;
    receiver_lte?: Maybe<Scalars['Bytes']>;
    receiver_in?: Maybe<Array<Scalars['Bytes']>>;
    receiver_not_in?: Maybe<Array<Scalars['Bytes']>>;
    receiver_contains?: Maybe<Scalars['Bytes']>;
    receiver_not_contains?: Maybe<Scalars['Bytes']>;
    flowOperator?: Maybe<Scalars['Bytes']>;
    flowOperator_not?: Maybe<Scalars['Bytes']>;
    flowOperator_gt?: Maybe<Scalars['Bytes']>;
    flowOperator_lt?: Maybe<Scalars['Bytes']>;
    flowOperator_gte?: Maybe<Scalars['Bytes']>;
    flowOperator_lte?: Maybe<Scalars['Bytes']>;
    flowOperator_in?: Maybe<Array<Scalars['Bytes']>>;
    flowOperator_not_in?: Maybe<Array<Scalars['Bytes']>>;
    flowOperator_contains?: Maybe<Scalars['Bytes']>;
    flowOperator_not_contains?: Maybe<Scalars['Bytes']>;
    flowRate?: Maybe<Scalars['BigInt']>;
    flowRate_not?: Maybe<Scalars['BigInt']>;
    flowRate_gt?: Maybe<Scalars['BigInt']>;
    flowRate_lt?: Maybe<Scalars['BigInt']>;
    flowRate_gte?: Maybe<Scalars['BigInt']>;
    flowRate_lte?: Maybe<Scalars['BigInt']>;
    flowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    flowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalSenderFlowRate?: Maybe<Scalars['BigInt']>;
    totalSenderFlowRate_not?: Maybe<Scalars['BigInt']>;
    totalSenderFlowRate_gt?: Maybe<Scalars['BigInt']>;
    totalSenderFlowRate_lt?: Maybe<Scalars['BigInt']>;
    totalSenderFlowRate_gte?: Maybe<Scalars['BigInt']>;
    totalSenderFlowRate_lte?: Maybe<Scalars['BigInt']>;
    totalSenderFlowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalSenderFlowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalReceiverFlowRate?: Maybe<Scalars['BigInt']>;
    totalReceiverFlowRate_not?: Maybe<Scalars['BigInt']>;
    totalReceiverFlowRate_gt?: Maybe<Scalars['BigInt']>;
    totalReceiverFlowRate_lt?: Maybe<Scalars['BigInt']>;
    totalReceiverFlowRate_gte?: Maybe<Scalars['BigInt']>;
    totalReceiverFlowRate_lte?: Maybe<Scalars['BigInt']>;
    totalReceiverFlowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalReceiverFlowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    deposit?: Maybe<Scalars['BigInt']>;
    deposit_not?: Maybe<Scalars['BigInt']>;
    deposit_gt?: Maybe<Scalars['BigInt']>;
    deposit_lt?: Maybe<Scalars['BigInt']>;
    deposit_gte?: Maybe<Scalars['BigInt']>;
    deposit_lte?: Maybe<Scalars['BigInt']>;
    deposit_in?: Maybe<Array<Scalars['BigInt']>>;
    deposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_gt?: Maybe<Scalars['Bytes']>;
    userData_lt?: Maybe<Scalars['Bytes']>;
    userData_gte?: Maybe<Scalars['Bytes']>;
    userData_lte?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    oldFlowRate?: Maybe<Scalars['BigInt']>;
    oldFlowRate_not?: Maybe<Scalars['BigInt']>;
    oldFlowRate_gt?: Maybe<Scalars['BigInt']>;
    oldFlowRate_lt?: Maybe<Scalars['BigInt']>;
    oldFlowRate_gte?: Maybe<Scalars['BigInt']>;
    oldFlowRate_lte?: Maybe<Scalars['BigInt']>;
    oldFlowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    oldFlowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    type?: Maybe<Scalars['Int']>;
    type_not?: Maybe<Scalars['Int']>;
    type_gt?: Maybe<Scalars['Int']>;
    type_lt?: Maybe<Scalars['Int']>;
    type_gte?: Maybe<Scalars['Int']>;
    type_lte?: Maybe<Scalars['Int']>;
    type_in?: Maybe<Array<Scalars['Int']>>;
    type_not_in?: Maybe<Array<Scalars['Int']>>;
    totalAmountStreamedUntilTimestamp?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilTimestamp_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilTimestamp_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilTimestamp_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilTimestamp_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilTimestamp_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedUntilTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    stream?: Maybe<Scalars['String']>;
    stream_not?: Maybe<Scalars['String']>;
    stream_gt?: Maybe<Scalars['String']>;
    stream_lt?: Maybe<Scalars['String']>;
    stream_gte?: Maybe<Scalars['String']>;
    stream_lte?: Maybe<Scalars['String']>;
    stream_in?: Maybe<Array<Scalars['String']>>;
    stream_not_in?: Maybe<Array<Scalars['String']>>;
    stream_contains?: Maybe<Scalars['String']>;
    stream_contains_nocase?: Maybe<Scalars['String']>;
    stream_not_contains?: Maybe<Scalars['String']>;
    stream_not_contains_nocase?: Maybe<Scalars['String']>;
    stream_starts_with?: Maybe<Scalars['String']>;
    stream_starts_with_nocase?: Maybe<Scalars['String']>;
    stream_not_starts_with?: Maybe<Scalars['String']>;
    stream_not_starts_with_nocase?: Maybe<Scalars['String']>;
    stream_ends_with?: Maybe<Scalars['String']>;
    stream_ends_with_nocase?: Maybe<Scalars['String']>;
    stream_not_ends_with?: Maybe<Scalars['String']>;
    stream_not_ends_with_nocase?: Maybe<Scalars['String']>;
    stream_?: Maybe<Stream_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<FlowUpdatedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<FlowUpdatedEvent_Filter>>>;
};
export declare enum FlowUpdatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Sender = "sender",
    Receiver = "receiver",
    FlowOperator = "flowOperator",
    FlowRate = "flowRate",
    TotalSenderFlowRate = "totalSenderFlowRate",
    TotalReceiverFlowRate = "totalReceiverFlowRate",
    Deposit = "deposit",
    UserData = "userData",
    OldFlowRate = "oldFlowRate",
    Type = "type",
    TotalAmountStreamedUntilTimestamp = "totalAmountStreamedUntilTimestamp",
    Stream = "stream",
    Stream__id = "stream__id",
    Stream__createdAtTimestamp = "stream__createdAtTimestamp",
    Stream__createdAtBlockNumber = "stream__createdAtBlockNumber",
    Stream__updatedAtTimestamp = "stream__updatedAtTimestamp",
    Stream__updatedAtBlockNumber = "stream__updatedAtBlockNumber",
    Stream__currentFlowRate = "stream__currentFlowRate",
    Stream__deposit = "stream__deposit",
    Stream__streamedUntilUpdatedAt = "stream__streamedUntilUpdatedAt",
    Stream__userData = "stream__userData"
}
export type GovernanceReplacedEvent = Event & {
    __typename?: 'GovernanceReplacedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    oldGovernance: Scalars['Bytes'];
    newGovernance: Scalars['Bytes'];
};
export type GovernanceReplacedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    oldGovernance?: Maybe<Scalars['Bytes']>;
    oldGovernance_not?: Maybe<Scalars['Bytes']>;
    oldGovernance_gt?: Maybe<Scalars['Bytes']>;
    oldGovernance_lt?: Maybe<Scalars['Bytes']>;
    oldGovernance_gte?: Maybe<Scalars['Bytes']>;
    oldGovernance_lte?: Maybe<Scalars['Bytes']>;
    oldGovernance_in?: Maybe<Array<Scalars['Bytes']>>;
    oldGovernance_not_in?: Maybe<Array<Scalars['Bytes']>>;
    oldGovernance_contains?: Maybe<Scalars['Bytes']>;
    oldGovernance_not_contains?: Maybe<Scalars['Bytes']>;
    newGovernance?: Maybe<Scalars['Bytes']>;
    newGovernance_not?: Maybe<Scalars['Bytes']>;
    newGovernance_gt?: Maybe<Scalars['Bytes']>;
    newGovernance_lt?: Maybe<Scalars['Bytes']>;
    newGovernance_gte?: Maybe<Scalars['Bytes']>;
    newGovernance_lte?: Maybe<Scalars['Bytes']>;
    newGovernance_in?: Maybe<Array<Scalars['Bytes']>>;
    newGovernance_not_in?: Maybe<Array<Scalars['Bytes']>>;
    newGovernance_contains?: Maybe<Scalars['Bytes']>;
    newGovernance_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<GovernanceReplacedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<GovernanceReplacedEvent_Filter>>>;
};
export declare enum GovernanceReplacedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Addresses = "addresses",
    OldGovernance = "oldGovernance",
    NewGovernance = "newGovernance"
}
/** Index: An Index higher order entity. */
export type Index = {
    __typename?: 'Index';
    /** ID composed of: publisherAddress-tokenAddress-indexId */
    id: Scalars['ID'];
    createdAtTimestamp: Scalars['BigInt'];
    createdAtBlockNumber: Scalars['BigInt'];
    updatedAtTimestamp: Scalars['BigInt'];
    updatedAtBlockNumber: Scalars['BigInt'];
    /**
     * NOTE: indexId is not the same as the id of the `Index` entity.
     * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
     */
    indexId: Scalars['BigInt'];
    indexValue: Scalars['BigInt'];
    /** The number of subscriptions which have units allocated to them on the `Index`. */
    totalSubscriptionsWithUnits: Scalars['Int'];
    /**
     * The number of units allocated by the `Index` that are pending.
     * This refers to the current (as of updatedAt) `totalUnitsPending`-not all that has ever been pending.
     */
    totalUnitsPending: Scalars['BigInt'];
    /**
     * The number of units allocated by the `Index` that are approved.
     * This refers to the current (as of updatedAt) `totalUnitsApproved`-not all that has ever been approved.
     */
    totalUnitsApproved: Scalars['BigInt'];
    /** The sum of `totalUnitsPending` and `totalUnitsApproved`. */
    totalUnits: Scalars['BigInt'];
    /** The total amount distributed from this `Index`. */
    totalAmountDistributedUntilUpdatedAt: Scalars['BigInt'];
    token: Token;
    publisher: Account;
    /**
     * The subscriptions of the index, it will include approved, unapproved
     * and deleted subscriptions.
     */
    subscriptions: Array<IndexSubscription>;
    /** IndexCreated event, there will only be one. */
    indexCreatedEvent: IndexCreatedEvent;
    indexDistributionClaimedEvents: Array<IndexDistributionClaimedEvent>;
    indexUpdatedEvents: Array<IndexUpdatedEvent>;
    indexSubscribedEvents: Array<IndexSubscribedEvent>;
    indexUnitsUpdatedEvents: Array<IndexUnitsUpdatedEvent>;
    indexUnsubscribedEvents: Array<IndexUnsubscribedEvent>;
};
/** Index: An Index higher order entity. */
export type IndexSubscriptionsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexSubscription_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexSubscription_Filter>;
};
/** Index: An Index higher order entity. */
export type IndexIndexDistributionClaimedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexDistributionClaimedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexDistributionClaimedEvent_Filter>;
};
/** Index: An Index higher order entity. */
export type IndexIndexUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUpdatedEvent_Filter>;
};
/** Index: An Index higher order entity. */
export type IndexIndexSubscribedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexSubscribedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexSubscribedEvent_Filter>;
};
/** Index: An Index higher order entity. */
export type IndexIndexUnitsUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUnitsUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUnitsUpdatedEvent_Filter>;
};
/** Index: An Index higher order entity. */
export type IndexIndexUnsubscribedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUnsubscribedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUnsubscribedEvent_Filter>;
};
export type IndexCreatedEvent = Event & {
    __typename?: 'IndexCreatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `publisher`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    /** The creator of the `index`. */
    publisher: Scalars['Bytes'];
    /** An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`. */
    indexId: Scalars['BigInt'];
    userData: Scalars['Bytes'];
    index: Index;
};
export type IndexCreatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_gt?: Maybe<Scalars['Bytes']>;
    publisher_lt?: Maybe<Scalars['Bytes']>;
    publisher_gte?: Maybe<Scalars['Bytes']>;
    publisher_lte?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_gt?: Maybe<Scalars['Bytes']>;
    userData_lt?: Maybe<Scalars['Bytes']>;
    userData_gte?: Maybe<Scalars['Bytes']>;
    userData_lte?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    index?: Maybe<Scalars['String']>;
    index_not?: Maybe<Scalars['String']>;
    index_gt?: Maybe<Scalars['String']>;
    index_lt?: Maybe<Scalars['String']>;
    index_gte?: Maybe<Scalars['String']>;
    index_lte?: Maybe<Scalars['String']>;
    index_in?: Maybe<Array<Scalars['String']>>;
    index_not_in?: Maybe<Array<Scalars['String']>>;
    index_contains?: Maybe<Scalars['String']>;
    index_contains_nocase?: Maybe<Scalars['String']>;
    index_not_contains?: Maybe<Scalars['String']>;
    index_not_contains_nocase?: Maybe<Scalars['String']>;
    index_starts_with?: Maybe<Scalars['String']>;
    index_starts_with_nocase?: Maybe<Scalars['String']>;
    index_not_starts_with?: Maybe<Scalars['String']>;
    index_not_starts_with_nocase?: Maybe<Scalars['String']>;
    index_ends_with?: Maybe<Scalars['String']>;
    index_ends_with_nocase?: Maybe<Scalars['String']>;
    index_not_ends_with?: Maybe<Scalars['String']>;
    index_not_ends_with_nocase?: Maybe<Scalars['String']>;
    index_?: Maybe<Index_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<IndexCreatedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<IndexCreatedEvent_Filter>>>;
};
export declare enum IndexCreatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Publisher = "publisher",
    IndexId = "indexId",
    UserData = "userData",
    Index = "index",
    Index__id = "index__id",
    Index__createdAtTimestamp = "index__createdAtTimestamp",
    Index__createdAtBlockNumber = "index__createdAtBlockNumber",
    Index__updatedAtTimestamp = "index__updatedAtTimestamp",
    Index__updatedAtBlockNumber = "index__updatedAtBlockNumber",
    Index__indexId = "index__indexId",
    Index__indexValue = "index__indexValue",
    Index__totalSubscriptionsWithUnits = "index__totalSubscriptionsWithUnits",
    Index__totalUnitsPending = "index__totalUnitsPending",
    Index__totalUnitsApproved = "index__totalUnitsApproved",
    Index__totalUnits = "index__totalUnits",
    Index__totalAmountDistributedUntilUpdatedAt = "index__totalAmountDistributedUntilUpdatedAt"
}
export type IndexDistributionClaimedEvent = Event & {
    __typename?: 'IndexDistributionClaimedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `publisher`
     * addresses[2] = `subscriber`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    /** The creator of the `index`. */
    publisher: Scalars['Bytes'];
    /** An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`. */
    indexId: Scalars['BigInt'];
    /**
     * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
     * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
     */
    subscriber: Scalars['Bytes'];
    amount: Scalars['BigInt'];
    index: Index;
};
export type IndexDistributionClaimedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_gt?: Maybe<Scalars['Bytes']>;
    publisher_lt?: Maybe<Scalars['Bytes']>;
    publisher_gte?: Maybe<Scalars['Bytes']>;
    publisher_lte?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    subscriber?: Maybe<Scalars['Bytes']>;
    subscriber_not?: Maybe<Scalars['Bytes']>;
    subscriber_gt?: Maybe<Scalars['Bytes']>;
    subscriber_lt?: Maybe<Scalars['Bytes']>;
    subscriber_gte?: Maybe<Scalars['Bytes']>;
    subscriber_lte?: Maybe<Scalars['Bytes']>;
    subscriber_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_not_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_contains?: Maybe<Scalars['Bytes']>;
    subscriber_not_contains?: Maybe<Scalars['Bytes']>;
    amount?: Maybe<Scalars['BigInt']>;
    amount_not?: Maybe<Scalars['BigInt']>;
    amount_gt?: Maybe<Scalars['BigInt']>;
    amount_lt?: Maybe<Scalars['BigInt']>;
    amount_gte?: Maybe<Scalars['BigInt']>;
    amount_lte?: Maybe<Scalars['BigInt']>;
    amount_in?: Maybe<Array<Scalars['BigInt']>>;
    amount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    index?: Maybe<Scalars['String']>;
    index_not?: Maybe<Scalars['String']>;
    index_gt?: Maybe<Scalars['String']>;
    index_lt?: Maybe<Scalars['String']>;
    index_gte?: Maybe<Scalars['String']>;
    index_lte?: Maybe<Scalars['String']>;
    index_in?: Maybe<Array<Scalars['String']>>;
    index_not_in?: Maybe<Array<Scalars['String']>>;
    index_contains?: Maybe<Scalars['String']>;
    index_contains_nocase?: Maybe<Scalars['String']>;
    index_not_contains?: Maybe<Scalars['String']>;
    index_not_contains_nocase?: Maybe<Scalars['String']>;
    index_starts_with?: Maybe<Scalars['String']>;
    index_starts_with_nocase?: Maybe<Scalars['String']>;
    index_not_starts_with?: Maybe<Scalars['String']>;
    index_not_starts_with_nocase?: Maybe<Scalars['String']>;
    index_ends_with?: Maybe<Scalars['String']>;
    index_ends_with_nocase?: Maybe<Scalars['String']>;
    index_not_ends_with?: Maybe<Scalars['String']>;
    index_not_ends_with_nocase?: Maybe<Scalars['String']>;
    index_?: Maybe<Index_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<IndexDistributionClaimedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<IndexDistributionClaimedEvent_Filter>>>;
};
export declare enum IndexDistributionClaimedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Publisher = "publisher",
    IndexId = "indexId",
    Subscriber = "subscriber",
    Amount = "amount",
    Index = "index",
    Index__id = "index__id",
    Index__createdAtTimestamp = "index__createdAtTimestamp",
    Index__createdAtBlockNumber = "index__createdAtBlockNumber",
    Index__updatedAtTimestamp = "index__updatedAtTimestamp",
    Index__updatedAtBlockNumber = "index__updatedAtBlockNumber",
    Index__indexId = "index__indexId",
    Index__indexValue = "index__indexValue",
    Index__totalSubscriptionsWithUnits = "index__totalSubscriptionsWithUnits",
    Index__totalUnitsPending = "index__totalUnitsPending",
    Index__totalUnitsApproved = "index__totalUnitsApproved",
    Index__totalUnits = "index__totalUnits",
    Index__totalAmountDistributedUntilUpdatedAt = "index__totalAmountDistributedUntilUpdatedAt"
}
export type IndexSubscribedEvent = Event & {
    __typename?: 'IndexSubscribedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `publisher`
     * addresses[2] = `subscriber`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    /** The creator of the `index`. */
    publisher: Scalars['Bytes'];
    /** An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`. */
    indexId: Scalars['BigInt'];
    /**
     * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
     * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
     */
    subscriber: Scalars['Bytes'];
    userData: Scalars['Bytes'];
    index: Index;
};
export type IndexSubscribedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_gt?: Maybe<Scalars['Bytes']>;
    publisher_lt?: Maybe<Scalars['Bytes']>;
    publisher_gte?: Maybe<Scalars['Bytes']>;
    publisher_lte?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    subscriber?: Maybe<Scalars['Bytes']>;
    subscriber_not?: Maybe<Scalars['Bytes']>;
    subscriber_gt?: Maybe<Scalars['Bytes']>;
    subscriber_lt?: Maybe<Scalars['Bytes']>;
    subscriber_gte?: Maybe<Scalars['Bytes']>;
    subscriber_lte?: Maybe<Scalars['Bytes']>;
    subscriber_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_not_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_contains?: Maybe<Scalars['Bytes']>;
    subscriber_not_contains?: Maybe<Scalars['Bytes']>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_gt?: Maybe<Scalars['Bytes']>;
    userData_lt?: Maybe<Scalars['Bytes']>;
    userData_gte?: Maybe<Scalars['Bytes']>;
    userData_lte?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    index?: Maybe<Scalars['String']>;
    index_not?: Maybe<Scalars['String']>;
    index_gt?: Maybe<Scalars['String']>;
    index_lt?: Maybe<Scalars['String']>;
    index_gte?: Maybe<Scalars['String']>;
    index_lte?: Maybe<Scalars['String']>;
    index_in?: Maybe<Array<Scalars['String']>>;
    index_not_in?: Maybe<Array<Scalars['String']>>;
    index_contains?: Maybe<Scalars['String']>;
    index_contains_nocase?: Maybe<Scalars['String']>;
    index_not_contains?: Maybe<Scalars['String']>;
    index_not_contains_nocase?: Maybe<Scalars['String']>;
    index_starts_with?: Maybe<Scalars['String']>;
    index_starts_with_nocase?: Maybe<Scalars['String']>;
    index_not_starts_with?: Maybe<Scalars['String']>;
    index_not_starts_with_nocase?: Maybe<Scalars['String']>;
    index_ends_with?: Maybe<Scalars['String']>;
    index_ends_with_nocase?: Maybe<Scalars['String']>;
    index_not_ends_with?: Maybe<Scalars['String']>;
    index_not_ends_with_nocase?: Maybe<Scalars['String']>;
    index_?: Maybe<Index_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<IndexSubscribedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<IndexSubscribedEvent_Filter>>>;
};
export declare enum IndexSubscribedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Publisher = "publisher",
    IndexId = "indexId",
    Subscriber = "subscriber",
    UserData = "userData",
    Index = "index",
    Index__id = "index__id",
    Index__createdAtTimestamp = "index__createdAtTimestamp",
    Index__createdAtBlockNumber = "index__createdAtBlockNumber",
    Index__updatedAtTimestamp = "index__updatedAtTimestamp",
    Index__updatedAtBlockNumber = "index__updatedAtBlockNumber",
    Index__indexId = "index__indexId",
    Index__indexValue = "index__indexValue",
    Index__totalSubscriptionsWithUnits = "index__totalSubscriptionsWithUnits",
    Index__totalUnitsPending = "index__totalUnitsPending",
    Index__totalUnitsApproved = "index__totalUnitsApproved",
    Index__totalUnits = "index__totalUnits",
    Index__totalAmountDistributedUntilUpdatedAt = "index__totalAmountDistributedUntilUpdatedAt"
}
/** IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular `Index`. */
export type IndexSubscription = {
    __typename?: 'IndexSubscription';
    /** ID composed of: subscriberAddress-publisherAddress-tokenAddress-IndexId */
    id: Scalars['ID'];
    createdAtTimestamp: Scalars['BigInt'];
    createdAtBlockNumber: Scalars['BigInt'];
    updatedAtTimestamp: Scalars['BigInt'];
    updatedAtBlockNumber: Scalars['BigInt'];
    subscriber: Account;
    /**
     * A boolean indicating whether the `IndexSubscription` is approved.
     * Approved subscriptions don't require `subscriber` to claim tokens that are distributed from the publisher.
     */
    approved: Scalars['Boolean'];
    /** If `units` is `0`, it indicates that the subscription is "deleted" and `subscriber` is no longer subscribed to `index`. */
    units: Scalars['BigInt'];
    /**
     * The total amount of tokens you've received via IDA until
     * `updatedAtTimestamp`/`updatedAtBlock`.
     */
    totalAmountReceivedUntilUpdatedAt: Scalars['BigInt'];
    /**
     * The previous index value - used to calculate `totalAmountReceivedUntilUpdatedAt` field as of the `index.updatedAtTimestamp`.
     * The formula to get this value is:
     * `IndexSubscription.totalAmountReceivedUntilUpdatedAt + ((index.newIndexValue - indexSubscription.indexValueUntilUpdatedAt) * indexSubscription.units)`.
     */
    indexValueUntilUpdatedAt: Scalars['BigInt'];
    index: Index;
    /** IndexSubscription approved events on the subscription. */
    subscriptionApprovedEvents: Array<SubscriptionApprovedEvent>;
    subscriptionDistributionClaimedEvents: Array<SubscriptionDistributionClaimedEvent>;
    subscriptionRevokedEvents: Array<SubscriptionRevokedEvent>;
    subscriptionUnitsUpdatedEvents: Array<SubscriptionUnitsUpdatedEvent>;
};
/** IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular `Index`. */
export type IndexSubscriptionSubscriptionApprovedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionApprovedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionApprovedEvent_Filter>;
};
/** IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular `Index`. */
export type IndexSubscriptionSubscriptionDistributionClaimedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionDistributionClaimedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionDistributionClaimedEvent_Filter>;
};
/** IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular `Index`. */
export type IndexSubscriptionSubscriptionRevokedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionRevokedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionRevokedEvent_Filter>;
};
/** IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular `Index`. */
export type IndexSubscriptionSubscriptionUnitsUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionUnitsUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionUnitsUpdatedEvent_Filter>;
};
export type IndexSubscription_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    createdAtTimestamp?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    subscriber?: Maybe<Scalars['String']>;
    subscriber_not?: Maybe<Scalars['String']>;
    subscriber_gt?: Maybe<Scalars['String']>;
    subscriber_lt?: Maybe<Scalars['String']>;
    subscriber_gte?: Maybe<Scalars['String']>;
    subscriber_lte?: Maybe<Scalars['String']>;
    subscriber_in?: Maybe<Array<Scalars['String']>>;
    subscriber_not_in?: Maybe<Array<Scalars['String']>>;
    subscriber_contains?: Maybe<Scalars['String']>;
    subscriber_contains_nocase?: Maybe<Scalars['String']>;
    subscriber_not_contains?: Maybe<Scalars['String']>;
    subscriber_not_contains_nocase?: Maybe<Scalars['String']>;
    subscriber_starts_with?: Maybe<Scalars['String']>;
    subscriber_starts_with_nocase?: Maybe<Scalars['String']>;
    subscriber_not_starts_with?: Maybe<Scalars['String']>;
    subscriber_not_starts_with_nocase?: Maybe<Scalars['String']>;
    subscriber_ends_with?: Maybe<Scalars['String']>;
    subscriber_ends_with_nocase?: Maybe<Scalars['String']>;
    subscriber_not_ends_with?: Maybe<Scalars['String']>;
    subscriber_not_ends_with_nocase?: Maybe<Scalars['String']>;
    subscriber_?: Maybe<Account_Filter>;
    approved?: Maybe<Scalars['Boolean']>;
    approved_not?: Maybe<Scalars['Boolean']>;
    approved_in?: Maybe<Array<Scalars['Boolean']>>;
    approved_not_in?: Maybe<Array<Scalars['Boolean']>>;
    units?: Maybe<Scalars['BigInt']>;
    units_not?: Maybe<Scalars['BigInt']>;
    units_gt?: Maybe<Scalars['BigInt']>;
    units_lt?: Maybe<Scalars['BigInt']>;
    units_gte?: Maybe<Scalars['BigInt']>;
    units_lte?: Maybe<Scalars['BigInt']>;
    units_in?: Maybe<Array<Scalars['BigInt']>>;
    units_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountReceivedUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountReceivedUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountReceivedUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountReceivedUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountReceivedUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountReceivedUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountReceivedUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountReceivedUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    indexValueUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    indexValueUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    indexValueUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    indexValueUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    indexValueUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    indexValueUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    indexValueUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    indexValueUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    index?: Maybe<Scalars['String']>;
    index_not?: Maybe<Scalars['String']>;
    index_gt?: Maybe<Scalars['String']>;
    index_lt?: Maybe<Scalars['String']>;
    index_gte?: Maybe<Scalars['String']>;
    index_lte?: Maybe<Scalars['String']>;
    index_in?: Maybe<Array<Scalars['String']>>;
    index_not_in?: Maybe<Array<Scalars['String']>>;
    index_contains?: Maybe<Scalars['String']>;
    index_contains_nocase?: Maybe<Scalars['String']>;
    index_not_contains?: Maybe<Scalars['String']>;
    index_not_contains_nocase?: Maybe<Scalars['String']>;
    index_starts_with?: Maybe<Scalars['String']>;
    index_starts_with_nocase?: Maybe<Scalars['String']>;
    index_not_starts_with?: Maybe<Scalars['String']>;
    index_not_starts_with_nocase?: Maybe<Scalars['String']>;
    index_ends_with?: Maybe<Scalars['String']>;
    index_ends_with_nocase?: Maybe<Scalars['String']>;
    index_not_ends_with?: Maybe<Scalars['String']>;
    index_not_ends_with_nocase?: Maybe<Scalars['String']>;
    index_?: Maybe<Index_Filter>;
    subscriptionApprovedEvents_?: Maybe<SubscriptionApprovedEvent_Filter>;
    subscriptionDistributionClaimedEvents_?: Maybe<SubscriptionDistributionClaimedEvent_Filter>;
    subscriptionRevokedEvents_?: Maybe<SubscriptionRevokedEvent_Filter>;
    subscriptionUnitsUpdatedEvents_?: Maybe<SubscriptionUnitsUpdatedEvent_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<IndexSubscription_Filter>>>;
    or?: Maybe<Array<Maybe<IndexSubscription_Filter>>>;
};
export declare enum IndexSubscription_OrderBy {
    Id = "id",
    CreatedAtTimestamp = "createdAtTimestamp",
    CreatedAtBlockNumber = "createdAtBlockNumber",
    UpdatedAtTimestamp = "updatedAtTimestamp",
    UpdatedAtBlockNumber = "updatedAtBlockNumber",
    Subscriber = "subscriber",
    Subscriber__id = "subscriber__id",
    Subscriber__createdAtTimestamp = "subscriber__createdAtTimestamp",
    Subscriber__createdAtBlockNumber = "subscriber__createdAtBlockNumber",
    Subscriber__updatedAtTimestamp = "subscriber__updatedAtTimestamp",
    Subscriber__updatedAtBlockNumber = "subscriber__updatedAtBlockNumber",
    Subscriber__isSuperApp = "subscriber__isSuperApp",
    Approved = "approved",
    Units = "units",
    TotalAmountReceivedUntilUpdatedAt = "totalAmountReceivedUntilUpdatedAt",
    IndexValueUntilUpdatedAt = "indexValueUntilUpdatedAt",
    Index = "index",
    Index__id = "index__id",
    Index__createdAtTimestamp = "index__createdAtTimestamp",
    Index__createdAtBlockNumber = "index__createdAtBlockNumber",
    Index__updatedAtTimestamp = "index__updatedAtTimestamp",
    Index__updatedAtBlockNumber = "index__updatedAtBlockNumber",
    Index__indexId = "index__indexId",
    Index__indexValue = "index__indexValue",
    Index__totalSubscriptionsWithUnits = "index__totalSubscriptionsWithUnits",
    Index__totalUnitsPending = "index__totalUnitsPending",
    Index__totalUnitsApproved = "index__totalUnitsApproved",
    Index__totalUnits = "index__totalUnits",
    Index__totalAmountDistributedUntilUpdatedAt = "index__totalAmountDistributedUntilUpdatedAt",
    SubscriptionApprovedEvents = "subscriptionApprovedEvents",
    SubscriptionDistributionClaimedEvents = "subscriptionDistributionClaimedEvents",
    SubscriptionRevokedEvents = "subscriptionRevokedEvents",
    SubscriptionUnitsUpdatedEvents = "subscriptionUnitsUpdatedEvents"
}
export type IndexUnitsUpdatedEvent = Event & {
    __typename?: 'IndexUnitsUpdatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `publisher`
     * addresses[2] = `subscriber`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    /** The creator of the `index`. */
    publisher: Scalars['Bytes'];
    /** An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`. */
    indexId: Scalars['BigInt'];
    /**
     * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
     * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
     */
    subscriber: Scalars['Bytes'];
    units: Scalars['BigInt'];
    userData: Scalars['Bytes'];
    oldUnits: Scalars['BigInt'];
    index: Index;
};
export type IndexUnitsUpdatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_gt?: Maybe<Scalars['Bytes']>;
    publisher_lt?: Maybe<Scalars['Bytes']>;
    publisher_gte?: Maybe<Scalars['Bytes']>;
    publisher_lte?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    subscriber?: Maybe<Scalars['Bytes']>;
    subscriber_not?: Maybe<Scalars['Bytes']>;
    subscriber_gt?: Maybe<Scalars['Bytes']>;
    subscriber_lt?: Maybe<Scalars['Bytes']>;
    subscriber_gte?: Maybe<Scalars['Bytes']>;
    subscriber_lte?: Maybe<Scalars['Bytes']>;
    subscriber_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_not_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_contains?: Maybe<Scalars['Bytes']>;
    subscriber_not_contains?: Maybe<Scalars['Bytes']>;
    units?: Maybe<Scalars['BigInt']>;
    units_not?: Maybe<Scalars['BigInt']>;
    units_gt?: Maybe<Scalars['BigInt']>;
    units_lt?: Maybe<Scalars['BigInt']>;
    units_gte?: Maybe<Scalars['BigInt']>;
    units_lte?: Maybe<Scalars['BigInt']>;
    units_in?: Maybe<Array<Scalars['BigInt']>>;
    units_not_in?: Maybe<Array<Scalars['BigInt']>>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_gt?: Maybe<Scalars['Bytes']>;
    userData_lt?: Maybe<Scalars['Bytes']>;
    userData_gte?: Maybe<Scalars['Bytes']>;
    userData_lte?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    oldUnits?: Maybe<Scalars['BigInt']>;
    oldUnits_not?: Maybe<Scalars['BigInt']>;
    oldUnits_gt?: Maybe<Scalars['BigInt']>;
    oldUnits_lt?: Maybe<Scalars['BigInt']>;
    oldUnits_gte?: Maybe<Scalars['BigInt']>;
    oldUnits_lte?: Maybe<Scalars['BigInt']>;
    oldUnits_in?: Maybe<Array<Scalars['BigInt']>>;
    oldUnits_not_in?: Maybe<Array<Scalars['BigInt']>>;
    index?: Maybe<Scalars['String']>;
    index_not?: Maybe<Scalars['String']>;
    index_gt?: Maybe<Scalars['String']>;
    index_lt?: Maybe<Scalars['String']>;
    index_gte?: Maybe<Scalars['String']>;
    index_lte?: Maybe<Scalars['String']>;
    index_in?: Maybe<Array<Scalars['String']>>;
    index_not_in?: Maybe<Array<Scalars['String']>>;
    index_contains?: Maybe<Scalars['String']>;
    index_contains_nocase?: Maybe<Scalars['String']>;
    index_not_contains?: Maybe<Scalars['String']>;
    index_not_contains_nocase?: Maybe<Scalars['String']>;
    index_starts_with?: Maybe<Scalars['String']>;
    index_starts_with_nocase?: Maybe<Scalars['String']>;
    index_not_starts_with?: Maybe<Scalars['String']>;
    index_not_starts_with_nocase?: Maybe<Scalars['String']>;
    index_ends_with?: Maybe<Scalars['String']>;
    index_ends_with_nocase?: Maybe<Scalars['String']>;
    index_not_ends_with?: Maybe<Scalars['String']>;
    index_not_ends_with_nocase?: Maybe<Scalars['String']>;
    index_?: Maybe<Index_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<IndexUnitsUpdatedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<IndexUnitsUpdatedEvent_Filter>>>;
};
export declare enum IndexUnitsUpdatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Publisher = "publisher",
    IndexId = "indexId",
    Subscriber = "subscriber",
    Units = "units",
    UserData = "userData",
    OldUnits = "oldUnits",
    Index = "index",
    Index__id = "index__id",
    Index__createdAtTimestamp = "index__createdAtTimestamp",
    Index__createdAtBlockNumber = "index__createdAtBlockNumber",
    Index__updatedAtTimestamp = "index__updatedAtTimestamp",
    Index__updatedAtBlockNumber = "index__updatedAtBlockNumber",
    Index__indexId = "index__indexId",
    Index__indexValue = "index__indexValue",
    Index__totalSubscriptionsWithUnits = "index__totalSubscriptionsWithUnits",
    Index__totalUnitsPending = "index__totalUnitsPending",
    Index__totalUnitsApproved = "index__totalUnitsApproved",
    Index__totalUnits = "index__totalUnits",
    Index__totalAmountDistributedUntilUpdatedAt = "index__totalAmountDistributedUntilUpdatedAt"
}
export type IndexUnsubscribedEvent = Event & {
    __typename?: 'IndexUnsubscribedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `publisher`
     * addresses[2] = `subscriber`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    /** The creator of the `index`. */
    publisher: Scalars['Bytes'];
    /** An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`. */
    indexId: Scalars['BigInt'];
    /**
     * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
     * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
     */
    subscriber: Scalars['Bytes'];
    userData: Scalars['Bytes'];
    index: Index;
};
export type IndexUnsubscribedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_gt?: Maybe<Scalars['Bytes']>;
    publisher_lt?: Maybe<Scalars['Bytes']>;
    publisher_gte?: Maybe<Scalars['Bytes']>;
    publisher_lte?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    subscriber?: Maybe<Scalars['Bytes']>;
    subscriber_not?: Maybe<Scalars['Bytes']>;
    subscriber_gt?: Maybe<Scalars['Bytes']>;
    subscriber_lt?: Maybe<Scalars['Bytes']>;
    subscriber_gte?: Maybe<Scalars['Bytes']>;
    subscriber_lte?: Maybe<Scalars['Bytes']>;
    subscriber_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_not_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_contains?: Maybe<Scalars['Bytes']>;
    subscriber_not_contains?: Maybe<Scalars['Bytes']>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_gt?: Maybe<Scalars['Bytes']>;
    userData_lt?: Maybe<Scalars['Bytes']>;
    userData_gte?: Maybe<Scalars['Bytes']>;
    userData_lte?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    index?: Maybe<Scalars['String']>;
    index_not?: Maybe<Scalars['String']>;
    index_gt?: Maybe<Scalars['String']>;
    index_lt?: Maybe<Scalars['String']>;
    index_gte?: Maybe<Scalars['String']>;
    index_lte?: Maybe<Scalars['String']>;
    index_in?: Maybe<Array<Scalars['String']>>;
    index_not_in?: Maybe<Array<Scalars['String']>>;
    index_contains?: Maybe<Scalars['String']>;
    index_contains_nocase?: Maybe<Scalars['String']>;
    index_not_contains?: Maybe<Scalars['String']>;
    index_not_contains_nocase?: Maybe<Scalars['String']>;
    index_starts_with?: Maybe<Scalars['String']>;
    index_starts_with_nocase?: Maybe<Scalars['String']>;
    index_not_starts_with?: Maybe<Scalars['String']>;
    index_not_starts_with_nocase?: Maybe<Scalars['String']>;
    index_ends_with?: Maybe<Scalars['String']>;
    index_ends_with_nocase?: Maybe<Scalars['String']>;
    index_not_ends_with?: Maybe<Scalars['String']>;
    index_not_ends_with_nocase?: Maybe<Scalars['String']>;
    index_?: Maybe<Index_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<IndexUnsubscribedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<IndexUnsubscribedEvent_Filter>>>;
};
export declare enum IndexUnsubscribedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Publisher = "publisher",
    IndexId = "indexId",
    Subscriber = "subscriber",
    UserData = "userData",
    Index = "index",
    Index__id = "index__id",
    Index__createdAtTimestamp = "index__createdAtTimestamp",
    Index__createdAtBlockNumber = "index__createdAtBlockNumber",
    Index__updatedAtTimestamp = "index__updatedAtTimestamp",
    Index__updatedAtBlockNumber = "index__updatedAtBlockNumber",
    Index__indexId = "index__indexId",
    Index__indexValue = "index__indexValue",
    Index__totalSubscriptionsWithUnits = "index__totalSubscriptionsWithUnits",
    Index__totalUnitsPending = "index__totalUnitsPending",
    Index__totalUnitsApproved = "index__totalUnitsApproved",
    Index__totalUnits = "index__totalUnits",
    Index__totalAmountDistributedUntilUpdatedAt = "index__totalAmountDistributedUntilUpdatedAt"
}
export type IndexUpdatedEvent = Event & {
    __typename?: 'IndexUpdatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `publisher`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    /** The creator of the `index`. */
    publisher: Scalars['Bytes'];
    /** An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`. */
    indexId: Scalars['BigInt'];
    oldIndexValue: Scalars['BigInt'];
    newIndexValue: Scalars['BigInt'];
    totalUnitsPending: Scalars['BigInt'];
    totalUnitsApproved: Scalars['BigInt'];
    userData: Scalars['Bytes'];
    index: Index;
};
export type IndexUpdatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_gt?: Maybe<Scalars['Bytes']>;
    publisher_lt?: Maybe<Scalars['Bytes']>;
    publisher_gte?: Maybe<Scalars['Bytes']>;
    publisher_lte?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    oldIndexValue?: Maybe<Scalars['BigInt']>;
    oldIndexValue_not?: Maybe<Scalars['BigInt']>;
    oldIndexValue_gt?: Maybe<Scalars['BigInt']>;
    oldIndexValue_lt?: Maybe<Scalars['BigInt']>;
    oldIndexValue_gte?: Maybe<Scalars['BigInt']>;
    oldIndexValue_lte?: Maybe<Scalars['BigInt']>;
    oldIndexValue_in?: Maybe<Array<Scalars['BigInt']>>;
    oldIndexValue_not_in?: Maybe<Array<Scalars['BigInt']>>;
    newIndexValue?: Maybe<Scalars['BigInt']>;
    newIndexValue_not?: Maybe<Scalars['BigInt']>;
    newIndexValue_gt?: Maybe<Scalars['BigInt']>;
    newIndexValue_lt?: Maybe<Scalars['BigInt']>;
    newIndexValue_gte?: Maybe<Scalars['BigInt']>;
    newIndexValue_lte?: Maybe<Scalars['BigInt']>;
    newIndexValue_in?: Maybe<Array<Scalars['BigInt']>>;
    newIndexValue_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnitsPending?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_not?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_gt?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_lt?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_gte?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_lte?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnitsPending_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnitsApproved?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_not?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_gt?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_lt?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_gte?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_lte?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnitsApproved_not_in?: Maybe<Array<Scalars['BigInt']>>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_gt?: Maybe<Scalars['Bytes']>;
    userData_lt?: Maybe<Scalars['Bytes']>;
    userData_gte?: Maybe<Scalars['Bytes']>;
    userData_lte?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    index?: Maybe<Scalars['String']>;
    index_not?: Maybe<Scalars['String']>;
    index_gt?: Maybe<Scalars['String']>;
    index_lt?: Maybe<Scalars['String']>;
    index_gte?: Maybe<Scalars['String']>;
    index_lte?: Maybe<Scalars['String']>;
    index_in?: Maybe<Array<Scalars['String']>>;
    index_not_in?: Maybe<Array<Scalars['String']>>;
    index_contains?: Maybe<Scalars['String']>;
    index_contains_nocase?: Maybe<Scalars['String']>;
    index_not_contains?: Maybe<Scalars['String']>;
    index_not_contains_nocase?: Maybe<Scalars['String']>;
    index_starts_with?: Maybe<Scalars['String']>;
    index_starts_with_nocase?: Maybe<Scalars['String']>;
    index_not_starts_with?: Maybe<Scalars['String']>;
    index_not_starts_with_nocase?: Maybe<Scalars['String']>;
    index_ends_with?: Maybe<Scalars['String']>;
    index_ends_with_nocase?: Maybe<Scalars['String']>;
    index_not_ends_with?: Maybe<Scalars['String']>;
    index_not_ends_with_nocase?: Maybe<Scalars['String']>;
    index_?: Maybe<Index_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<IndexUpdatedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<IndexUpdatedEvent_Filter>>>;
};
export declare enum IndexUpdatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Publisher = "publisher",
    IndexId = "indexId",
    OldIndexValue = "oldIndexValue",
    NewIndexValue = "newIndexValue",
    TotalUnitsPending = "totalUnitsPending",
    TotalUnitsApproved = "totalUnitsApproved",
    UserData = "userData",
    Index = "index",
    Index__id = "index__id",
    Index__createdAtTimestamp = "index__createdAtTimestamp",
    Index__createdAtBlockNumber = "index__createdAtBlockNumber",
    Index__updatedAtTimestamp = "index__updatedAtTimestamp",
    Index__updatedAtBlockNumber = "index__updatedAtBlockNumber",
    Index__indexId = "index__indexId",
    Index__indexValue = "index__indexValue",
    Index__totalSubscriptionsWithUnits = "index__totalSubscriptionsWithUnits",
    Index__totalUnitsPending = "index__totalUnitsPending",
    Index__totalUnitsApproved = "index__totalUnitsApproved",
    Index__totalUnits = "index__totalUnits",
    Index__totalAmountDistributedUntilUpdatedAt = "index__totalAmountDistributedUntilUpdatedAt"
}
export type Index_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    createdAtTimestamp?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    indexValue?: Maybe<Scalars['BigInt']>;
    indexValue_not?: Maybe<Scalars['BigInt']>;
    indexValue_gt?: Maybe<Scalars['BigInt']>;
    indexValue_lt?: Maybe<Scalars['BigInt']>;
    indexValue_gte?: Maybe<Scalars['BigInt']>;
    indexValue_lte?: Maybe<Scalars['BigInt']>;
    indexValue_in?: Maybe<Array<Scalars['BigInt']>>;
    indexValue_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalSubscriptionsWithUnits?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_not?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits_not_in?: Maybe<Array<Scalars['Int']>>;
    totalUnitsPending?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_not?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_gt?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_lt?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_gte?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_lte?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnitsPending_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnitsApproved?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_not?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_gt?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_lt?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_gte?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_lte?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnitsApproved_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnits?: Maybe<Scalars['BigInt']>;
    totalUnits_not?: Maybe<Scalars['BigInt']>;
    totalUnits_gt?: Maybe<Scalars['BigInt']>;
    totalUnits_lt?: Maybe<Scalars['BigInt']>;
    totalUnits_gte?: Maybe<Scalars['BigInt']>;
    totalUnits_lte?: Maybe<Scalars['BigInt']>;
    totalUnits_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnits_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountDistributedUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountDistributedUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['String']>;
    token_not?: Maybe<Scalars['String']>;
    token_gt?: Maybe<Scalars['String']>;
    token_lt?: Maybe<Scalars['String']>;
    token_gte?: Maybe<Scalars['String']>;
    token_lte?: Maybe<Scalars['String']>;
    token_in?: Maybe<Array<Scalars['String']>>;
    token_not_in?: Maybe<Array<Scalars['String']>>;
    token_contains?: Maybe<Scalars['String']>;
    token_contains_nocase?: Maybe<Scalars['String']>;
    token_not_contains?: Maybe<Scalars['String']>;
    token_not_contains_nocase?: Maybe<Scalars['String']>;
    token_starts_with?: Maybe<Scalars['String']>;
    token_starts_with_nocase?: Maybe<Scalars['String']>;
    token_not_starts_with?: Maybe<Scalars['String']>;
    token_not_starts_with_nocase?: Maybe<Scalars['String']>;
    token_ends_with?: Maybe<Scalars['String']>;
    token_ends_with_nocase?: Maybe<Scalars['String']>;
    token_not_ends_with?: Maybe<Scalars['String']>;
    token_not_ends_with_nocase?: Maybe<Scalars['String']>;
    token_?: Maybe<Token_Filter>;
    publisher?: Maybe<Scalars['String']>;
    publisher_not?: Maybe<Scalars['String']>;
    publisher_gt?: Maybe<Scalars['String']>;
    publisher_lt?: Maybe<Scalars['String']>;
    publisher_gte?: Maybe<Scalars['String']>;
    publisher_lte?: Maybe<Scalars['String']>;
    publisher_in?: Maybe<Array<Scalars['String']>>;
    publisher_not_in?: Maybe<Array<Scalars['String']>>;
    publisher_contains?: Maybe<Scalars['String']>;
    publisher_contains_nocase?: Maybe<Scalars['String']>;
    publisher_not_contains?: Maybe<Scalars['String']>;
    publisher_not_contains_nocase?: Maybe<Scalars['String']>;
    publisher_starts_with?: Maybe<Scalars['String']>;
    publisher_starts_with_nocase?: Maybe<Scalars['String']>;
    publisher_not_starts_with?: Maybe<Scalars['String']>;
    publisher_not_starts_with_nocase?: Maybe<Scalars['String']>;
    publisher_ends_with?: Maybe<Scalars['String']>;
    publisher_ends_with_nocase?: Maybe<Scalars['String']>;
    publisher_not_ends_with?: Maybe<Scalars['String']>;
    publisher_not_ends_with_nocase?: Maybe<Scalars['String']>;
    publisher_?: Maybe<Account_Filter>;
    subscriptions_?: Maybe<IndexSubscription_Filter>;
    indexCreatedEvent?: Maybe<Scalars['String']>;
    indexCreatedEvent_not?: Maybe<Scalars['String']>;
    indexCreatedEvent_gt?: Maybe<Scalars['String']>;
    indexCreatedEvent_lt?: Maybe<Scalars['String']>;
    indexCreatedEvent_gte?: Maybe<Scalars['String']>;
    indexCreatedEvent_lte?: Maybe<Scalars['String']>;
    indexCreatedEvent_in?: Maybe<Array<Scalars['String']>>;
    indexCreatedEvent_not_in?: Maybe<Array<Scalars['String']>>;
    indexCreatedEvent_contains?: Maybe<Scalars['String']>;
    indexCreatedEvent_contains_nocase?: Maybe<Scalars['String']>;
    indexCreatedEvent_not_contains?: Maybe<Scalars['String']>;
    indexCreatedEvent_not_contains_nocase?: Maybe<Scalars['String']>;
    indexCreatedEvent_starts_with?: Maybe<Scalars['String']>;
    indexCreatedEvent_starts_with_nocase?: Maybe<Scalars['String']>;
    indexCreatedEvent_not_starts_with?: Maybe<Scalars['String']>;
    indexCreatedEvent_not_starts_with_nocase?: Maybe<Scalars['String']>;
    indexCreatedEvent_ends_with?: Maybe<Scalars['String']>;
    indexCreatedEvent_ends_with_nocase?: Maybe<Scalars['String']>;
    indexCreatedEvent_not_ends_with?: Maybe<Scalars['String']>;
    indexCreatedEvent_not_ends_with_nocase?: Maybe<Scalars['String']>;
    indexCreatedEvent_?: Maybe<IndexCreatedEvent_Filter>;
    indexDistributionClaimedEvents_?: Maybe<IndexDistributionClaimedEvent_Filter>;
    indexUpdatedEvents_?: Maybe<IndexUpdatedEvent_Filter>;
    indexSubscribedEvents_?: Maybe<IndexSubscribedEvent_Filter>;
    indexUnitsUpdatedEvents_?: Maybe<IndexUnitsUpdatedEvent_Filter>;
    indexUnsubscribedEvents_?: Maybe<IndexUnsubscribedEvent_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<Index_Filter>>>;
    or?: Maybe<Array<Maybe<Index_Filter>>>;
};
export declare enum Index_OrderBy {
    Id = "id",
    CreatedAtTimestamp = "createdAtTimestamp",
    CreatedAtBlockNumber = "createdAtBlockNumber",
    UpdatedAtTimestamp = "updatedAtTimestamp",
    UpdatedAtBlockNumber = "updatedAtBlockNumber",
    IndexId = "indexId",
    IndexValue = "indexValue",
    TotalSubscriptionsWithUnits = "totalSubscriptionsWithUnits",
    TotalUnitsPending = "totalUnitsPending",
    TotalUnitsApproved = "totalUnitsApproved",
    TotalUnits = "totalUnits",
    TotalAmountDistributedUntilUpdatedAt = "totalAmountDistributedUntilUpdatedAt",
    Token = "token",
    Token__id = "token__id",
    Token__createdAtTimestamp = "token__createdAtTimestamp",
    Token__createdAtBlockNumber = "token__createdAtBlockNumber",
    Token__decimals = "token__decimals",
    Token__name = "token__name",
    Token__symbol = "token__symbol",
    Token__isSuperToken = "token__isSuperToken",
    Token__isNativeAssetSuperToken = "token__isNativeAssetSuperToken",
    Token__isListed = "token__isListed",
    Token__underlyingAddress = "token__underlyingAddress",
    Publisher = "publisher",
    Publisher__id = "publisher__id",
    Publisher__createdAtTimestamp = "publisher__createdAtTimestamp",
    Publisher__createdAtBlockNumber = "publisher__createdAtBlockNumber",
    Publisher__updatedAtTimestamp = "publisher__updatedAtTimestamp",
    Publisher__updatedAtBlockNumber = "publisher__updatedAtBlockNumber",
    Publisher__isSuperApp = "publisher__isSuperApp",
    Subscriptions = "subscriptions",
    IndexCreatedEvent = "indexCreatedEvent",
    IndexCreatedEvent__id = "indexCreatedEvent__id",
    IndexCreatedEvent__transactionHash = "indexCreatedEvent__transactionHash",
    IndexCreatedEvent__gasPrice = "indexCreatedEvent__gasPrice",
    IndexCreatedEvent__gasUsed = "indexCreatedEvent__gasUsed",
    IndexCreatedEvent__timestamp = "indexCreatedEvent__timestamp",
    IndexCreatedEvent__name = "indexCreatedEvent__name",
    IndexCreatedEvent__blockNumber = "indexCreatedEvent__blockNumber",
    IndexCreatedEvent__logIndex = "indexCreatedEvent__logIndex",
    IndexCreatedEvent__order = "indexCreatedEvent__order",
    IndexCreatedEvent__token = "indexCreatedEvent__token",
    IndexCreatedEvent__publisher = "indexCreatedEvent__publisher",
    IndexCreatedEvent__indexId = "indexCreatedEvent__indexId",
    IndexCreatedEvent__userData = "indexCreatedEvent__userData",
    IndexDistributionClaimedEvents = "indexDistributionClaimedEvents",
    IndexUpdatedEvents = "indexUpdatedEvents",
    IndexSubscribedEvents = "indexSubscribedEvents",
    IndexUnitsUpdatedEvents = "indexUnitsUpdatedEvents",
    IndexUnsubscribedEvents = "indexUnsubscribedEvents"
}
export type JailEvent = Event & {
    __typename?: 'JailEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    app: Scalars['Bytes'];
    reason: Scalars['BigInt'];
};
export type JailEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    app?: Maybe<Scalars['Bytes']>;
    app_not?: Maybe<Scalars['Bytes']>;
    app_gt?: Maybe<Scalars['Bytes']>;
    app_lt?: Maybe<Scalars['Bytes']>;
    app_gte?: Maybe<Scalars['Bytes']>;
    app_lte?: Maybe<Scalars['Bytes']>;
    app_in?: Maybe<Array<Scalars['Bytes']>>;
    app_not_in?: Maybe<Array<Scalars['Bytes']>>;
    app_contains?: Maybe<Scalars['Bytes']>;
    app_not_contains?: Maybe<Scalars['Bytes']>;
    reason?: Maybe<Scalars['BigInt']>;
    reason_not?: Maybe<Scalars['BigInt']>;
    reason_gt?: Maybe<Scalars['BigInt']>;
    reason_lt?: Maybe<Scalars['BigInt']>;
    reason_gte?: Maybe<Scalars['BigInt']>;
    reason_lte?: Maybe<Scalars['BigInt']>;
    reason_in?: Maybe<Array<Scalars['BigInt']>>;
    reason_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<JailEvent_Filter>>>;
    or?: Maybe<Array<Maybe<JailEvent_Filter>>>;
};
export declare enum JailEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    App = "app",
    Reason = "reason"
}
export type MintedEvent = Event & {
    __typename?: 'MintedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `operator`
     * addresses[2] = `to`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    operator: Scalars['Bytes'];
    to: Scalars['Bytes'];
    amount: Scalars['BigInt'];
    data: Scalars['Bytes'];
    token: Scalars['Bytes'];
    operatorData: Scalars['Bytes'];
};
export type MintedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    operator?: Maybe<Scalars['Bytes']>;
    operator_not?: Maybe<Scalars['Bytes']>;
    operator_gt?: Maybe<Scalars['Bytes']>;
    operator_lt?: Maybe<Scalars['Bytes']>;
    operator_gte?: Maybe<Scalars['Bytes']>;
    operator_lte?: Maybe<Scalars['Bytes']>;
    operator_in?: Maybe<Array<Scalars['Bytes']>>;
    operator_not_in?: Maybe<Array<Scalars['Bytes']>>;
    operator_contains?: Maybe<Scalars['Bytes']>;
    operator_not_contains?: Maybe<Scalars['Bytes']>;
    to?: Maybe<Scalars['Bytes']>;
    to_not?: Maybe<Scalars['Bytes']>;
    to_gt?: Maybe<Scalars['Bytes']>;
    to_lt?: Maybe<Scalars['Bytes']>;
    to_gte?: Maybe<Scalars['Bytes']>;
    to_lte?: Maybe<Scalars['Bytes']>;
    to_in?: Maybe<Array<Scalars['Bytes']>>;
    to_not_in?: Maybe<Array<Scalars['Bytes']>>;
    to_contains?: Maybe<Scalars['Bytes']>;
    to_not_contains?: Maybe<Scalars['Bytes']>;
    amount?: Maybe<Scalars['BigInt']>;
    amount_not?: Maybe<Scalars['BigInt']>;
    amount_gt?: Maybe<Scalars['BigInt']>;
    amount_lt?: Maybe<Scalars['BigInt']>;
    amount_gte?: Maybe<Scalars['BigInt']>;
    amount_lte?: Maybe<Scalars['BigInt']>;
    amount_in?: Maybe<Array<Scalars['BigInt']>>;
    amount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    data?: Maybe<Scalars['Bytes']>;
    data_not?: Maybe<Scalars['Bytes']>;
    data_gt?: Maybe<Scalars['Bytes']>;
    data_lt?: Maybe<Scalars['Bytes']>;
    data_gte?: Maybe<Scalars['Bytes']>;
    data_lte?: Maybe<Scalars['Bytes']>;
    data_in?: Maybe<Array<Scalars['Bytes']>>;
    data_not_in?: Maybe<Array<Scalars['Bytes']>>;
    data_contains?: Maybe<Scalars['Bytes']>;
    data_not_contains?: Maybe<Scalars['Bytes']>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    operatorData?: Maybe<Scalars['Bytes']>;
    operatorData_not?: Maybe<Scalars['Bytes']>;
    operatorData_gt?: Maybe<Scalars['Bytes']>;
    operatorData_lt?: Maybe<Scalars['Bytes']>;
    operatorData_gte?: Maybe<Scalars['Bytes']>;
    operatorData_lte?: Maybe<Scalars['Bytes']>;
    operatorData_in?: Maybe<Array<Scalars['Bytes']>>;
    operatorData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    operatorData_contains?: Maybe<Scalars['Bytes']>;
    operatorData_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<MintedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<MintedEvent_Filter>>>;
};
export declare enum MintedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Operator = "operator",
    To = "to",
    Amount = "amount",
    Data = "data",
    Token = "token",
    OperatorData = "operatorData"
}
export type NewPicEvent = Event & {
    __typename?: 'NewPICEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `pic` (new Patrician In Charge)
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    /** The address of the `token` (supertoken) the PIC is posting a bond for. */
    token: Scalars['Bytes'];
    /** The address of the new Patrician In Charge (PIC). */
    pic: Scalars['Bytes'];
    /** The bond the new PIC staked in order to claim the position. */
    bond: Scalars['BigInt'];
    /** The flowrate at which the bond is streamed back to the PIC. */
    exitRate: Scalars['BigInt'];
};
export type NewPicEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    pic?: Maybe<Scalars['Bytes']>;
    pic_not?: Maybe<Scalars['Bytes']>;
    pic_gt?: Maybe<Scalars['Bytes']>;
    pic_lt?: Maybe<Scalars['Bytes']>;
    pic_gte?: Maybe<Scalars['Bytes']>;
    pic_lte?: Maybe<Scalars['Bytes']>;
    pic_in?: Maybe<Array<Scalars['Bytes']>>;
    pic_not_in?: Maybe<Array<Scalars['Bytes']>>;
    pic_contains?: Maybe<Scalars['Bytes']>;
    pic_not_contains?: Maybe<Scalars['Bytes']>;
    bond?: Maybe<Scalars['BigInt']>;
    bond_not?: Maybe<Scalars['BigInt']>;
    bond_gt?: Maybe<Scalars['BigInt']>;
    bond_lt?: Maybe<Scalars['BigInt']>;
    bond_gte?: Maybe<Scalars['BigInt']>;
    bond_lte?: Maybe<Scalars['BigInt']>;
    bond_in?: Maybe<Array<Scalars['BigInt']>>;
    bond_not_in?: Maybe<Array<Scalars['BigInt']>>;
    exitRate?: Maybe<Scalars['BigInt']>;
    exitRate_not?: Maybe<Scalars['BigInt']>;
    exitRate_gt?: Maybe<Scalars['BigInt']>;
    exitRate_lt?: Maybe<Scalars['BigInt']>;
    exitRate_gte?: Maybe<Scalars['BigInt']>;
    exitRate_lte?: Maybe<Scalars['BigInt']>;
    exitRate_in?: Maybe<Array<Scalars['BigInt']>>;
    exitRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<NewPicEvent_Filter>>>;
    or?: Maybe<Array<Maybe<NewPicEvent_Filter>>>;
};
export declare enum NewPicEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Pic = "pic",
    Bond = "bond",
    ExitRate = "exitRate"
}
/** Defines the order direction, either ascending or descending */
export declare enum OrderDirection {
    Asc = "asc",
    Desc = "desc"
}
export type PppConfigurationChangedEvent = Event & {
    __typename?: 'PPPConfigurationChangedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** The address of the governance contract the event was emitted from. */
    governanceAddress: Scalars['Bytes'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    host: Scalars['Bytes'];
    superToken: Scalars['Bytes'];
    isKeySet: Scalars['Boolean'];
    liquidationPeriod: Scalars['BigInt'];
    patricianPeriod: Scalars['BigInt'];
};
export type PppConfigurationChangedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    governanceAddress?: Maybe<Scalars['Bytes']>;
    governanceAddress_not?: Maybe<Scalars['Bytes']>;
    governanceAddress_gt?: Maybe<Scalars['Bytes']>;
    governanceAddress_lt?: Maybe<Scalars['Bytes']>;
    governanceAddress_gte?: Maybe<Scalars['Bytes']>;
    governanceAddress_lte?: Maybe<Scalars['Bytes']>;
    governanceAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_contains?: Maybe<Scalars['Bytes']>;
    governanceAddress_not_contains?: Maybe<Scalars['Bytes']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    host?: Maybe<Scalars['Bytes']>;
    host_not?: Maybe<Scalars['Bytes']>;
    host_gt?: Maybe<Scalars['Bytes']>;
    host_lt?: Maybe<Scalars['Bytes']>;
    host_gte?: Maybe<Scalars['Bytes']>;
    host_lte?: Maybe<Scalars['Bytes']>;
    host_in?: Maybe<Array<Scalars['Bytes']>>;
    host_not_in?: Maybe<Array<Scalars['Bytes']>>;
    host_contains?: Maybe<Scalars['Bytes']>;
    host_not_contains?: Maybe<Scalars['Bytes']>;
    superToken?: Maybe<Scalars['Bytes']>;
    superToken_not?: Maybe<Scalars['Bytes']>;
    superToken_gt?: Maybe<Scalars['Bytes']>;
    superToken_lt?: Maybe<Scalars['Bytes']>;
    superToken_gte?: Maybe<Scalars['Bytes']>;
    superToken_lte?: Maybe<Scalars['Bytes']>;
    superToken_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_not_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_contains?: Maybe<Scalars['Bytes']>;
    superToken_not_contains?: Maybe<Scalars['Bytes']>;
    isKeySet?: Maybe<Scalars['Boolean']>;
    isKeySet_not?: Maybe<Scalars['Boolean']>;
    isKeySet_in?: Maybe<Array<Scalars['Boolean']>>;
    isKeySet_not_in?: Maybe<Array<Scalars['Boolean']>>;
    liquidationPeriod?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_not?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_gt?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_lt?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_gte?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_lte?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_in?: Maybe<Array<Scalars['BigInt']>>;
    liquidationPeriod_not_in?: Maybe<Array<Scalars['BigInt']>>;
    patricianPeriod?: Maybe<Scalars['BigInt']>;
    patricianPeriod_not?: Maybe<Scalars['BigInt']>;
    patricianPeriod_gt?: Maybe<Scalars['BigInt']>;
    patricianPeriod_lt?: Maybe<Scalars['BigInt']>;
    patricianPeriod_gte?: Maybe<Scalars['BigInt']>;
    patricianPeriod_lte?: Maybe<Scalars['BigInt']>;
    patricianPeriod_in?: Maybe<Array<Scalars['BigInt']>>;
    patricianPeriod_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<PppConfigurationChangedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<PppConfigurationChangedEvent_Filter>>>;
};
export declare enum PppConfigurationChangedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    GovernanceAddress = "governanceAddress",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Host = "host",
    SuperToken = "superToken",
    IsKeySet = "isKeySet",
    LiquidationPeriod = "liquidationPeriod",
    PatricianPeriod = "patricianPeriod"
}
export type Query = {
    __typename?: 'Query';
    flowUpdatedEvent?: Maybe<FlowUpdatedEvent>;
    flowUpdatedEvents: Array<FlowUpdatedEvent>;
    flowOperatorUpdatedEvent?: Maybe<FlowOperatorUpdatedEvent>;
    flowOperatorUpdatedEvents: Array<FlowOperatorUpdatedEvent>;
    indexCreatedEvent?: Maybe<IndexCreatedEvent>;
    indexCreatedEvents: Array<IndexCreatedEvent>;
    indexDistributionClaimedEvent?: Maybe<IndexDistributionClaimedEvent>;
    indexDistributionClaimedEvents: Array<IndexDistributionClaimedEvent>;
    indexUpdatedEvent?: Maybe<IndexUpdatedEvent>;
    indexUpdatedEvents: Array<IndexUpdatedEvent>;
    indexSubscribedEvent?: Maybe<IndexSubscribedEvent>;
    indexSubscribedEvents: Array<IndexSubscribedEvent>;
    indexUnitsUpdatedEvent?: Maybe<IndexUnitsUpdatedEvent>;
    indexUnitsUpdatedEvents: Array<IndexUnitsUpdatedEvent>;
    indexUnsubscribedEvent?: Maybe<IndexUnsubscribedEvent>;
    indexUnsubscribedEvents: Array<IndexUnsubscribedEvent>;
    subscriptionApprovedEvent?: Maybe<SubscriptionApprovedEvent>;
    subscriptionApprovedEvents: Array<SubscriptionApprovedEvent>;
    subscriptionDistributionClaimedEvent?: Maybe<SubscriptionDistributionClaimedEvent>;
    subscriptionDistributionClaimedEvents: Array<SubscriptionDistributionClaimedEvent>;
    subscriptionRevokedEvent?: Maybe<SubscriptionRevokedEvent>;
    subscriptionRevokedEvents: Array<SubscriptionRevokedEvent>;
    subscriptionUnitsUpdatedEvent?: Maybe<SubscriptionUnitsUpdatedEvent>;
    subscriptionUnitsUpdatedEvents: Array<SubscriptionUnitsUpdatedEvent>;
    agreementClassRegisteredEvent?: Maybe<AgreementClassRegisteredEvent>;
    agreementClassRegisteredEvents: Array<AgreementClassRegisteredEvent>;
    agreementClassUpdatedEvent?: Maybe<AgreementClassUpdatedEvent>;
    agreementClassUpdatedEvents: Array<AgreementClassUpdatedEvent>;
    appRegisteredEvent?: Maybe<AppRegisteredEvent>;
    appRegisteredEvents: Array<AppRegisteredEvent>;
    governanceReplacedEvent?: Maybe<GovernanceReplacedEvent>;
    governanceReplacedEvents: Array<GovernanceReplacedEvent>;
    jailEvent?: Maybe<JailEvent>;
    jailEvents: Array<JailEvent>;
    superTokenFactoryUpdatedEvent?: Maybe<SuperTokenFactoryUpdatedEvent>;
    superTokenFactoryUpdatedEvents: Array<SuperTokenFactoryUpdatedEvent>;
    superTokenLogicUpdatedEvent?: Maybe<SuperTokenLogicUpdatedEvent>;
    superTokenLogicUpdatedEvents: Array<SuperTokenLogicUpdatedEvent>;
    roleAdminChangedEvent?: Maybe<RoleAdminChangedEvent>;
    roleAdminChangedEvents: Array<RoleAdminChangedEvent>;
    roleGrantedEvent?: Maybe<RoleGrantedEvent>;
    roleGrantedEvents: Array<RoleGrantedEvent>;
    roleRevokedEvent?: Maybe<RoleRevokedEvent>;
    roleRevokedEvents: Array<RoleRevokedEvent>;
    setEvent?: Maybe<SetEvent>;
    setEvents: Array<SetEvent>;
    cfav1LiquidationPeriodChangedEvent?: Maybe<CfAv1LiquidationPeriodChangedEvent>;
    cfav1LiquidationPeriodChangedEvents: Array<CfAv1LiquidationPeriodChangedEvent>;
    configChangedEvent?: Maybe<ConfigChangedEvent>;
    configChangedEvents: Array<ConfigChangedEvent>;
    rewardAddressChangedEvent?: Maybe<RewardAddressChangedEvent>;
    rewardAddressChangedEvents: Array<RewardAddressChangedEvent>;
    pppconfigurationChangedEvent?: Maybe<PppConfigurationChangedEvent>;
    pppconfigurationChangedEvents: Array<PppConfigurationChangedEvent>;
    superTokenMinimumDepositChangedEvent?: Maybe<SuperTokenMinimumDepositChangedEvent>;
    superTokenMinimumDepositChangedEvents: Array<SuperTokenMinimumDepositChangedEvent>;
    trustedForwarderChangedEvent?: Maybe<TrustedForwarderChangedEvent>;
    trustedForwarderChangedEvents: Array<TrustedForwarderChangedEvent>;
    agreementLiquidatedByEvent?: Maybe<AgreementLiquidatedByEvent>;
    agreementLiquidatedByEvents: Array<AgreementLiquidatedByEvent>;
    agreementLiquidatedV2Event?: Maybe<AgreementLiquidatedV2Event>;
    agreementLiquidatedV2Events: Array<AgreementLiquidatedV2Event>;
    burnedEvent?: Maybe<BurnedEvent>;
    burnedEvents: Array<BurnedEvent>;
    mintedEvent?: Maybe<MintedEvent>;
    mintedEvents: Array<MintedEvent>;
    sentEvent?: Maybe<SentEvent>;
    sentEvents: Array<SentEvent>;
    transferEvent?: Maybe<TransferEvent>;
    transferEvents: Array<TransferEvent>;
    tokenDowngradedEvent?: Maybe<TokenDowngradedEvent>;
    tokenDowngradedEvents: Array<TokenDowngradedEvent>;
    tokenUpgradedEvent?: Maybe<TokenUpgradedEvent>;
    tokenUpgradedEvents: Array<TokenUpgradedEvent>;
    customSuperTokenCreatedEvent?: Maybe<CustomSuperTokenCreatedEvent>;
    customSuperTokenCreatedEvents: Array<CustomSuperTokenCreatedEvent>;
    superTokenCreatedEvent?: Maybe<SuperTokenCreatedEvent>;
    superTokenCreatedEvents: Array<SuperTokenCreatedEvent>;
    superTokenLogicCreatedEvent?: Maybe<SuperTokenLogicCreatedEvent>;
    superTokenLogicCreatedEvents: Array<SuperTokenLogicCreatedEvent>;
    newPICEvent?: Maybe<NewPicEvent>;
    newPICEvents: Array<NewPicEvent>;
    exitRateChangedEvent?: Maybe<ExitRateChangedEvent>;
    exitRateChangedEvents: Array<ExitRateChangedEvent>;
    bondIncreasedEvent?: Maybe<BondIncreasedEvent>;
    bondIncreasedEvents: Array<BondIncreasedEvent>;
    account?: Maybe<Account>;
    accounts: Array<Account>;
    index?: Maybe<Index>;
    indexes: Array<Index>;
    indexSubscription?: Maybe<IndexSubscription>;
    indexSubscriptions: Array<IndexSubscription>;
    stream?: Maybe<Stream>;
    streams: Array<Stream>;
    flowOperator?: Maybe<FlowOperator>;
    flowOperators: Array<FlowOperator>;
    streamPeriod?: Maybe<StreamPeriod>;
    streamPeriods: Array<StreamPeriod>;
    tokenGovernanceConfig?: Maybe<TokenGovernanceConfig>;
    tokenGovernanceConfigs: Array<TokenGovernanceConfig>;
    streamRevision?: Maybe<StreamRevision>;
    streamRevisions: Array<StreamRevision>;
    token?: Maybe<Token>;
    tokens: Array<Token>;
    resolverEntry?: Maybe<ResolverEntry>;
    resolverEntries: Array<ResolverEntry>;
    accountTokenSnapshot?: Maybe<AccountTokenSnapshot>;
    accountTokenSnapshots: Array<AccountTokenSnapshot>;
    accountTokenSnapshotLog?: Maybe<AccountTokenSnapshotLog>;
    accountTokenSnapshotLogs: Array<AccountTokenSnapshotLog>;
    tokenStatistic?: Maybe<TokenStatistic>;
    tokenStatistics: Array<TokenStatistic>;
    tokenStatisticLog?: Maybe<TokenStatisticLog>;
    tokenStatisticLogs: Array<TokenStatisticLog>;
    sfmeta?: Maybe<SfMeta>;
    sfmetas: Array<SfMeta>;
    event?: Maybe<Event>;
    events: Array<Event>;
    /** Access to subgraph metadata */
    _meta?: Maybe<_Meta_>;
};
export type QueryFlowUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryFlowUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryFlowOperatorUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryFlowOperatorUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowOperatorUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowOperatorUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryIndexCreatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryIndexCreatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexCreatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexCreatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryIndexDistributionClaimedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryIndexDistributionClaimedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexDistributionClaimedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexDistributionClaimedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryIndexUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryIndexUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryIndexSubscribedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryIndexSubscribedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexSubscribedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexSubscribedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryIndexUnitsUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryIndexUnitsUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUnitsUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUnitsUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryIndexUnsubscribedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryIndexUnsubscribedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUnsubscribedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUnsubscribedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySubscriptionApprovedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySubscriptionApprovedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionApprovedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionApprovedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySubscriptionDistributionClaimedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySubscriptionDistributionClaimedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionDistributionClaimedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionDistributionClaimedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySubscriptionRevokedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySubscriptionRevokedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionRevokedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionRevokedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySubscriptionUnitsUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySubscriptionUnitsUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionUnitsUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionUnitsUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryAgreementClassRegisteredEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryAgreementClassRegisteredEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AgreementClassRegisteredEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AgreementClassRegisteredEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryAgreementClassUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryAgreementClassUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AgreementClassUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AgreementClassUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryAppRegisteredEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryAppRegisteredEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AppRegisteredEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AppRegisteredEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryGovernanceReplacedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryGovernanceReplacedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<GovernanceReplacedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<GovernanceReplacedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryJailEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryJailEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<JailEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<JailEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySuperTokenFactoryUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySuperTokenFactoryUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenFactoryUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenFactoryUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySuperTokenLogicUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySuperTokenLogicUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenLogicUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenLogicUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryRoleAdminChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryRoleAdminChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RoleAdminChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RoleAdminChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryRoleGrantedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryRoleGrantedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RoleGrantedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RoleGrantedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryRoleRevokedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryRoleRevokedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RoleRevokedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RoleRevokedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySetEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySetEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SetEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SetEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryCfav1LiquidationPeriodChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryCfav1LiquidationPeriodChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<CfAv1LiquidationPeriodChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<CfAv1LiquidationPeriodChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryConfigChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryConfigChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<ConfigChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<ConfigChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryRewardAddressChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryRewardAddressChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RewardAddressChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RewardAddressChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryPppconfigurationChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryPppconfigurationChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<PppConfigurationChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<PppConfigurationChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySuperTokenMinimumDepositChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySuperTokenMinimumDepositChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenMinimumDepositChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenMinimumDepositChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryTrustedForwarderChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryTrustedForwarderChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TrustedForwarderChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TrustedForwarderChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryAgreementLiquidatedByEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryAgreementLiquidatedByEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AgreementLiquidatedByEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AgreementLiquidatedByEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryAgreementLiquidatedV2EventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryAgreementLiquidatedV2EventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AgreementLiquidatedV2Event_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AgreementLiquidatedV2Event_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryBurnedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryBurnedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<BurnedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<BurnedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryMintedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryMintedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<MintedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<MintedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySentEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySentEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SentEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SentEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryTransferEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryTransferEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TransferEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TransferEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryTokenDowngradedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryTokenDowngradedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenDowngradedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenDowngradedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryTokenUpgradedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryTokenUpgradedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenUpgradedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenUpgradedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryCustomSuperTokenCreatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryCustomSuperTokenCreatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<CustomSuperTokenCreatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<CustomSuperTokenCreatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySuperTokenCreatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySuperTokenCreatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenCreatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenCreatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySuperTokenLogicCreatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySuperTokenLogicCreatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenLogicCreatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenLogicCreatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryNewPicEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryNewPicEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<NewPicEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<NewPicEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryExitRateChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryExitRateChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<ExitRateChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<ExitRateChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryBondIncreasedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryBondIncreasedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<BondIncreasedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<BondIncreasedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryAccountArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryAccountsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Account_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Account_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryIndexArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryIndexesArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Index_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Index_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryIndexSubscriptionArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryIndexSubscriptionsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexSubscription_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexSubscription_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryStreamArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryStreamsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Stream_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Stream_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryFlowOperatorArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryFlowOperatorsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowOperator_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowOperator_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryStreamPeriodArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryStreamPeriodsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<StreamPeriod_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<StreamPeriod_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryTokenGovernanceConfigArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryTokenGovernanceConfigsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenGovernanceConfig_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenGovernanceConfig_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryStreamRevisionArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryStreamRevisionsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<StreamRevision_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<StreamRevision_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryTokenArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryTokensArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Token_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Token_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryResolverEntryArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryResolverEntriesArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<ResolverEntry_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<ResolverEntry_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryAccountTokenSnapshotArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryAccountTokenSnapshotsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AccountTokenSnapshot_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AccountTokenSnapshot_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryAccountTokenSnapshotLogArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryAccountTokenSnapshotLogsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AccountTokenSnapshotLog_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AccountTokenSnapshotLog_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryTokenStatisticArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryTokenStatisticsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenStatistic_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenStatistic_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryTokenStatisticLogArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryTokenStatisticLogsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenStatisticLog_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenStatisticLog_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySfmetaArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QuerySfmetasArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SfMeta_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SfMeta_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type QueryEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Event_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Event_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type Query_MetaArgs = {
    block?: Maybe<Block_Height>;
};
export type ResolverEntry = {
    __typename?: 'ResolverEntry';
    /** ID: the keccak256 hash of the set name */
    id: Scalars['ID'];
    createdAtTimestamp: Scalars['BigInt'];
    createdAtBlockNumber: Scalars['BigInt'];
    updatedAtTimestamp: Scalars['BigInt'];
    updatedAtBlockNumber: Scalars['BigInt'];
    targetAddress: Scalars['Bytes'];
    isToken: Scalars['Boolean'];
    isListed: Scalars['Boolean'];
    setEvents: Array<SetEvent>;
};
export type ResolverEntrySetEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SetEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SetEvent_Filter>;
};
export type ResolverEntry_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    createdAtTimestamp?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    targetAddress?: Maybe<Scalars['Bytes']>;
    targetAddress_not?: Maybe<Scalars['Bytes']>;
    targetAddress_gt?: Maybe<Scalars['Bytes']>;
    targetAddress_lt?: Maybe<Scalars['Bytes']>;
    targetAddress_gte?: Maybe<Scalars['Bytes']>;
    targetAddress_lte?: Maybe<Scalars['Bytes']>;
    targetAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    targetAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    targetAddress_contains?: Maybe<Scalars['Bytes']>;
    targetAddress_not_contains?: Maybe<Scalars['Bytes']>;
    isToken?: Maybe<Scalars['Boolean']>;
    isToken_not?: Maybe<Scalars['Boolean']>;
    isToken_in?: Maybe<Array<Scalars['Boolean']>>;
    isToken_not_in?: Maybe<Array<Scalars['Boolean']>>;
    isListed?: Maybe<Scalars['Boolean']>;
    isListed_not?: Maybe<Scalars['Boolean']>;
    isListed_in?: Maybe<Array<Scalars['Boolean']>>;
    isListed_not_in?: Maybe<Array<Scalars['Boolean']>>;
    setEvents_?: Maybe<SetEvent_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<ResolverEntry_Filter>>>;
    or?: Maybe<Array<Maybe<ResolverEntry_Filter>>>;
};
export declare enum ResolverEntry_OrderBy {
    Id = "id",
    CreatedAtTimestamp = "createdAtTimestamp",
    CreatedAtBlockNumber = "createdAtBlockNumber",
    UpdatedAtTimestamp = "updatedAtTimestamp",
    UpdatedAtBlockNumber = "updatedAtBlockNumber",
    TargetAddress = "targetAddress",
    IsToken = "isToken",
    IsListed = "isListed",
    SetEvents = "setEvents"
}
export type RewardAddressChangedEvent = Event & {
    __typename?: 'RewardAddressChangedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** The address of the governance contract the event was emitted from. */
    governanceAddress: Scalars['Bytes'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    host: Scalars['Bytes'];
    superToken: Scalars['Bytes'];
    isKeySet: Scalars['Boolean'];
    rewardAddress: Scalars['Bytes'];
};
export type RewardAddressChangedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    governanceAddress?: Maybe<Scalars['Bytes']>;
    governanceAddress_not?: Maybe<Scalars['Bytes']>;
    governanceAddress_gt?: Maybe<Scalars['Bytes']>;
    governanceAddress_lt?: Maybe<Scalars['Bytes']>;
    governanceAddress_gte?: Maybe<Scalars['Bytes']>;
    governanceAddress_lte?: Maybe<Scalars['Bytes']>;
    governanceAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_contains?: Maybe<Scalars['Bytes']>;
    governanceAddress_not_contains?: Maybe<Scalars['Bytes']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    host?: Maybe<Scalars['Bytes']>;
    host_not?: Maybe<Scalars['Bytes']>;
    host_gt?: Maybe<Scalars['Bytes']>;
    host_lt?: Maybe<Scalars['Bytes']>;
    host_gte?: Maybe<Scalars['Bytes']>;
    host_lte?: Maybe<Scalars['Bytes']>;
    host_in?: Maybe<Array<Scalars['Bytes']>>;
    host_not_in?: Maybe<Array<Scalars['Bytes']>>;
    host_contains?: Maybe<Scalars['Bytes']>;
    host_not_contains?: Maybe<Scalars['Bytes']>;
    superToken?: Maybe<Scalars['Bytes']>;
    superToken_not?: Maybe<Scalars['Bytes']>;
    superToken_gt?: Maybe<Scalars['Bytes']>;
    superToken_lt?: Maybe<Scalars['Bytes']>;
    superToken_gte?: Maybe<Scalars['Bytes']>;
    superToken_lte?: Maybe<Scalars['Bytes']>;
    superToken_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_not_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_contains?: Maybe<Scalars['Bytes']>;
    superToken_not_contains?: Maybe<Scalars['Bytes']>;
    isKeySet?: Maybe<Scalars['Boolean']>;
    isKeySet_not?: Maybe<Scalars['Boolean']>;
    isKeySet_in?: Maybe<Array<Scalars['Boolean']>>;
    isKeySet_not_in?: Maybe<Array<Scalars['Boolean']>>;
    rewardAddress?: Maybe<Scalars['Bytes']>;
    rewardAddress_not?: Maybe<Scalars['Bytes']>;
    rewardAddress_gt?: Maybe<Scalars['Bytes']>;
    rewardAddress_lt?: Maybe<Scalars['Bytes']>;
    rewardAddress_gte?: Maybe<Scalars['Bytes']>;
    rewardAddress_lte?: Maybe<Scalars['Bytes']>;
    rewardAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    rewardAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    rewardAddress_contains?: Maybe<Scalars['Bytes']>;
    rewardAddress_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<RewardAddressChangedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<RewardAddressChangedEvent_Filter>>>;
};
export declare enum RewardAddressChangedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    GovernanceAddress = "governanceAddress",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Host = "host",
    SuperToken = "superToken",
    IsKeySet = "isKeySet",
    RewardAddress = "rewardAddress"
}
export type RoleAdminChangedEvent = Event & {
    __typename?: 'RoleAdminChangedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    role: Scalars['Bytes'];
    previousAdminRole: Scalars['Bytes'];
    newAdminRole: Scalars['Bytes'];
};
export type RoleAdminChangedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    role?: Maybe<Scalars['Bytes']>;
    role_not?: Maybe<Scalars['Bytes']>;
    role_gt?: Maybe<Scalars['Bytes']>;
    role_lt?: Maybe<Scalars['Bytes']>;
    role_gte?: Maybe<Scalars['Bytes']>;
    role_lte?: Maybe<Scalars['Bytes']>;
    role_in?: Maybe<Array<Scalars['Bytes']>>;
    role_not_in?: Maybe<Array<Scalars['Bytes']>>;
    role_contains?: Maybe<Scalars['Bytes']>;
    role_not_contains?: Maybe<Scalars['Bytes']>;
    previousAdminRole?: Maybe<Scalars['Bytes']>;
    previousAdminRole_not?: Maybe<Scalars['Bytes']>;
    previousAdminRole_gt?: Maybe<Scalars['Bytes']>;
    previousAdminRole_lt?: Maybe<Scalars['Bytes']>;
    previousAdminRole_gte?: Maybe<Scalars['Bytes']>;
    previousAdminRole_lte?: Maybe<Scalars['Bytes']>;
    previousAdminRole_in?: Maybe<Array<Scalars['Bytes']>>;
    previousAdminRole_not_in?: Maybe<Array<Scalars['Bytes']>>;
    previousAdminRole_contains?: Maybe<Scalars['Bytes']>;
    previousAdminRole_not_contains?: Maybe<Scalars['Bytes']>;
    newAdminRole?: Maybe<Scalars['Bytes']>;
    newAdminRole_not?: Maybe<Scalars['Bytes']>;
    newAdminRole_gt?: Maybe<Scalars['Bytes']>;
    newAdminRole_lt?: Maybe<Scalars['Bytes']>;
    newAdminRole_gte?: Maybe<Scalars['Bytes']>;
    newAdminRole_lte?: Maybe<Scalars['Bytes']>;
    newAdminRole_in?: Maybe<Array<Scalars['Bytes']>>;
    newAdminRole_not_in?: Maybe<Array<Scalars['Bytes']>>;
    newAdminRole_contains?: Maybe<Scalars['Bytes']>;
    newAdminRole_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<RoleAdminChangedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<RoleAdminChangedEvent_Filter>>>;
};
export declare enum RoleAdminChangedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Role = "role",
    PreviousAdminRole = "previousAdminRole",
    NewAdminRole = "newAdminRole"
}
export type RoleGrantedEvent = Event & {
    __typename?: 'RoleGrantedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    role: Scalars['Bytes'];
    account: Scalars['Bytes'];
    sender: Scalars['Bytes'];
};
export type RoleGrantedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    role?: Maybe<Scalars['Bytes']>;
    role_not?: Maybe<Scalars['Bytes']>;
    role_gt?: Maybe<Scalars['Bytes']>;
    role_lt?: Maybe<Scalars['Bytes']>;
    role_gte?: Maybe<Scalars['Bytes']>;
    role_lte?: Maybe<Scalars['Bytes']>;
    role_in?: Maybe<Array<Scalars['Bytes']>>;
    role_not_in?: Maybe<Array<Scalars['Bytes']>>;
    role_contains?: Maybe<Scalars['Bytes']>;
    role_not_contains?: Maybe<Scalars['Bytes']>;
    account?: Maybe<Scalars['Bytes']>;
    account_not?: Maybe<Scalars['Bytes']>;
    account_gt?: Maybe<Scalars['Bytes']>;
    account_lt?: Maybe<Scalars['Bytes']>;
    account_gte?: Maybe<Scalars['Bytes']>;
    account_lte?: Maybe<Scalars['Bytes']>;
    account_in?: Maybe<Array<Scalars['Bytes']>>;
    account_not_in?: Maybe<Array<Scalars['Bytes']>>;
    account_contains?: Maybe<Scalars['Bytes']>;
    account_not_contains?: Maybe<Scalars['Bytes']>;
    sender?: Maybe<Scalars['Bytes']>;
    sender_not?: Maybe<Scalars['Bytes']>;
    sender_gt?: Maybe<Scalars['Bytes']>;
    sender_lt?: Maybe<Scalars['Bytes']>;
    sender_gte?: Maybe<Scalars['Bytes']>;
    sender_lte?: Maybe<Scalars['Bytes']>;
    sender_in?: Maybe<Array<Scalars['Bytes']>>;
    sender_not_in?: Maybe<Array<Scalars['Bytes']>>;
    sender_contains?: Maybe<Scalars['Bytes']>;
    sender_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<RoleGrantedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<RoleGrantedEvent_Filter>>>;
};
export declare enum RoleGrantedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Role = "role",
    Account = "account",
    Sender = "sender"
}
export type RoleRevokedEvent = Event & {
    __typename?: 'RoleRevokedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    role: Scalars['Bytes'];
    account: Scalars['Bytes'];
    sender: Scalars['Bytes'];
};
export type RoleRevokedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    role?: Maybe<Scalars['Bytes']>;
    role_not?: Maybe<Scalars['Bytes']>;
    role_gt?: Maybe<Scalars['Bytes']>;
    role_lt?: Maybe<Scalars['Bytes']>;
    role_gte?: Maybe<Scalars['Bytes']>;
    role_lte?: Maybe<Scalars['Bytes']>;
    role_in?: Maybe<Array<Scalars['Bytes']>>;
    role_not_in?: Maybe<Array<Scalars['Bytes']>>;
    role_contains?: Maybe<Scalars['Bytes']>;
    role_not_contains?: Maybe<Scalars['Bytes']>;
    account?: Maybe<Scalars['Bytes']>;
    account_not?: Maybe<Scalars['Bytes']>;
    account_gt?: Maybe<Scalars['Bytes']>;
    account_lt?: Maybe<Scalars['Bytes']>;
    account_gte?: Maybe<Scalars['Bytes']>;
    account_lte?: Maybe<Scalars['Bytes']>;
    account_in?: Maybe<Array<Scalars['Bytes']>>;
    account_not_in?: Maybe<Array<Scalars['Bytes']>>;
    account_contains?: Maybe<Scalars['Bytes']>;
    account_not_contains?: Maybe<Scalars['Bytes']>;
    sender?: Maybe<Scalars['Bytes']>;
    sender_not?: Maybe<Scalars['Bytes']>;
    sender_gt?: Maybe<Scalars['Bytes']>;
    sender_lt?: Maybe<Scalars['Bytes']>;
    sender_gte?: Maybe<Scalars['Bytes']>;
    sender_lte?: Maybe<Scalars['Bytes']>;
    sender_in?: Maybe<Array<Scalars['Bytes']>>;
    sender_not_in?: Maybe<Array<Scalars['Bytes']>>;
    sender_contains?: Maybe<Scalars['Bytes']>;
    sender_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<RoleRevokedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<RoleRevokedEvent_Filter>>>;
};
export declare enum RoleRevokedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Role = "role",
    Account = "account",
    Sender = "sender"
}
export type SfMeta = {
    __typename?: 'SFMeta';
    /** The id is the commit hash. */
    id: Scalars['ID'];
    timestamp: Scalars['BigInt'];
    blockNumber: Scalars['BigInt'];
    /** Whether the branch is feature/dev/v1. */
    configuration: Scalars['String'];
    /** The branch the current deployment is coming from. */
    branch: Scalars['String'];
};
export type SfMeta_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    configuration?: Maybe<Scalars['String']>;
    configuration_not?: Maybe<Scalars['String']>;
    configuration_gt?: Maybe<Scalars['String']>;
    configuration_lt?: Maybe<Scalars['String']>;
    configuration_gte?: Maybe<Scalars['String']>;
    configuration_lte?: Maybe<Scalars['String']>;
    configuration_in?: Maybe<Array<Scalars['String']>>;
    configuration_not_in?: Maybe<Array<Scalars['String']>>;
    configuration_contains?: Maybe<Scalars['String']>;
    configuration_contains_nocase?: Maybe<Scalars['String']>;
    configuration_not_contains?: Maybe<Scalars['String']>;
    configuration_not_contains_nocase?: Maybe<Scalars['String']>;
    configuration_starts_with?: Maybe<Scalars['String']>;
    configuration_starts_with_nocase?: Maybe<Scalars['String']>;
    configuration_not_starts_with?: Maybe<Scalars['String']>;
    configuration_not_starts_with_nocase?: Maybe<Scalars['String']>;
    configuration_ends_with?: Maybe<Scalars['String']>;
    configuration_ends_with_nocase?: Maybe<Scalars['String']>;
    configuration_not_ends_with?: Maybe<Scalars['String']>;
    configuration_not_ends_with_nocase?: Maybe<Scalars['String']>;
    branch?: Maybe<Scalars['String']>;
    branch_not?: Maybe<Scalars['String']>;
    branch_gt?: Maybe<Scalars['String']>;
    branch_lt?: Maybe<Scalars['String']>;
    branch_gte?: Maybe<Scalars['String']>;
    branch_lte?: Maybe<Scalars['String']>;
    branch_in?: Maybe<Array<Scalars['String']>>;
    branch_not_in?: Maybe<Array<Scalars['String']>>;
    branch_contains?: Maybe<Scalars['String']>;
    branch_contains_nocase?: Maybe<Scalars['String']>;
    branch_not_contains?: Maybe<Scalars['String']>;
    branch_not_contains_nocase?: Maybe<Scalars['String']>;
    branch_starts_with?: Maybe<Scalars['String']>;
    branch_starts_with_nocase?: Maybe<Scalars['String']>;
    branch_not_starts_with?: Maybe<Scalars['String']>;
    branch_not_starts_with_nocase?: Maybe<Scalars['String']>;
    branch_ends_with?: Maybe<Scalars['String']>;
    branch_ends_with_nocase?: Maybe<Scalars['String']>;
    branch_not_ends_with?: Maybe<Scalars['String']>;
    branch_not_ends_with_nocase?: Maybe<Scalars['String']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<SfMeta_Filter>>>;
    or?: Maybe<Array<Maybe<SfMeta_Filter>>>;
};
export declare enum SfMeta_OrderBy {
    Id = "id",
    Timestamp = "timestamp",
    BlockNumber = "blockNumber",
    Configuration = "configuration",
    Branch = "branch"
}
export type SentEvent = Event & {
    __typename?: 'SentEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `operator`
     * addresses[2] = `from`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    operator: Scalars['Bytes'];
    from: Scalars['Bytes'];
    to: Scalars['Bytes'];
    token: Scalars['Bytes'];
    amount: Scalars['BigInt'];
    data: Scalars['Bytes'];
    operatorData: Scalars['Bytes'];
};
export type SentEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    operator?: Maybe<Scalars['Bytes']>;
    operator_not?: Maybe<Scalars['Bytes']>;
    operator_gt?: Maybe<Scalars['Bytes']>;
    operator_lt?: Maybe<Scalars['Bytes']>;
    operator_gte?: Maybe<Scalars['Bytes']>;
    operator_lte?: Maybe<Scalars['Bytes']>;
    operator_in?: Maybe<Array<Scalars['Bytes']>>;
    operator_not_in?: Maybe<Array<Scalars['Bytes']>>;
    operator_contains?: Maybe<Scalars['Bytes']>;
    operator_not_contains?: Maybe<Scalars['Bytes']>;
    from?: Maybe<Scalars['Bytes']>;
    from_not?: Maybe<Scalars['Bytes']>;
    from_gt?: Maybe<Scalars['Bytes']>;
    from_lt?: Maybe<Scalars['Bytes']>;
    from_gte?: Maybe<Scalars['Bytes']>;
    from_lte?: Maybe<Scalars['Bytes']>;
    from_in?: Maybe<Array<Scalars['Bytes']>>;
    from_not_in?: Maybe<Array<Scalars['Bytes']>>;
    from_contains?: Maybe<Scalars['Bytes']>;
    from_not_contains?: Maybe<Scalars['Bytes']>;
    to?: Maybe<Scalars['Bytes']>;
    to_not?: Maybe<Scalars['Bytes']>;
    to_gt?: Maybe<Scalars['Bytes']>;
    to_lt?: Maybe<Scalars['Bytes']>;
    to_gte?: Maybe<Scalars['Bytes']>;
    to_lte?: Maybe<Scalars['Bytes']>;
    to_in?: Maybe<Array<Scalars['Bytes']>>;
    to_not_in?: Maybe<Array<Scalars['Bytes']>>;
    to_contains?: Maybe<Scalars['Bytes']>;
    to_not_contains?: Maybe<Scalars['Bytes']>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    amount?: Maybe<Scalars['BigInt']>;
    amount_not?: Maybe<Scalars['BigInt']>;
    amount_gt?: Maybe<Scalars['BigInt']>;
    amount_lt?: Maybe<Scalars['BigInt']>;
    amount_gte?: Maybe<Scalars['BigInt']>;
    amount_lte?: Maybe<Scalars['BigInt']>;
    amount_in?: Maybe<Array<Scalars['BigInt']>>;
    amount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    data?: Maybe<Scalars['Bytes']>;
    data_not?: Maybe<Scalars['Bytes']>;
    data_gt?: Maybe<Scalars['Bytes']>;
    data_lt?: Maybe<Scalars['Bytes']>;
    data_gte?: Maybe<Scalars['Bytes']>;
    data_lte?: Maybe<Scalars['Bytes']>;
    data_in?: Maybe<Array<Scalars['Bytes']>>;
    data_not_in?: Maybe<Array<Scalars['Bytes']>>;
    data_contains?: Maybe<Scalars['Bytes']>;
    data_not_contains?: Maybe<Scalars['Bytes']>;
    operatorData?: Maybe<Scalars['Bytes']>;
    operatorData_not?: Maybe<Scalars['Bytes']>;
    operatorData_gt?: Maybe<Scalars['Bytes']>;
    operatorData_lt?: Maybe<Scalars['Bytes']>;
    operatorData_gte?: Maybe<Scalars['Bytes']>;
    operatorData_lte?: Maybe<Scalars['Bytes']>;
    operatorData_in?: Maybe<Array<Scalars['Bytes']>>;
    operatorData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    operatorData_contains?: Maybe<Scalars['Bytes']>;
    operatorData_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<SentEvent_Filter>>>;
    or?: Maybe<Array<Maybe<SentEvent_Filter>>>;
};
export declare enum SentEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Operator = "operator",
    From = "from",
    To = "to",
    Token = "token",
    Amount = "amount",
    Data = "data",
    OperatorData = "operatorData"
}
export type SetEvent = Event & {
    __typename?: 'SetEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    /**
     * Because the name property is indexed, the
     * returned value will be a keccak256 hash
     * of the string.
     */
    hashedName: Scalars['Bytes'];
    target: Scalars['Bytes'];
    resolverEntry: ResolverEntry;
};
export type SetEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    hashedName?: Maybe<Scalars['Bytes']>;
    hashedName_not?: Maybe<Scalars['Bytes']>;
    hashedName_gt?: Maybe<Scalars['Bytes']>;
    hashedName_lt?: Maybe<Scalars['Bytes']>;
    hashedName_gte?: Maybe<Scalars['Bytes']>;
    hashedName_lte?: Maybe<Scalars['Bytes']>;
    hashedName_in?: Maybe<Array<Scalars['Bytes']>>;
    hashedName_not_in?: Maybe<Array<Scalars['Bytes']>>;
    hashedName_contains?: Maybe<Scalars['Bytes']>;
    hashedName_not_contains?: Maybe<Scalars['Bytes']>;
    target?: Maybe<Scalars['Bytes']>;
    target_not?: Maybe<Scalars['Bytes']>;
    target_gt?: Maybe<Scalars['Bytes']>;
    target_lt?: Maybe<Scalars['Bytes']>;
    target_gte?: Maybe<Scalars['Bytes']>;
    target_lte?: Maybe<Scalars['Bytes']>;
    target_in?: Maybe<Array<Scalars['Bytes']>>;
    target_not_in?: Maybe<Array<Scalars['Bytes']>>;
    target_contains?: Maybe<Scalars['Bytes']>;
    target_not_contains?: Maybe<Scalars['Bytes']>;
    resolverEntry?: Maybe<Scalars['String']>;
    resolverEntry_not?: Maybe<Scalars['String']>;
    resolverEntry_gt?: Maybe<Scalars['String']>;
    resolverEntry_lt?: Maybe<Scalars['String']>;
    resolverEntry_gte?: Maybe<Scalars['String']>;
    resolverEntry_lte?: Maybe<Scalars['String']>;
    resolverEntry_in?: Maybe<Array<Scalars['String']>>;
    resolverEntry_not_in?: Maybe<Array<Scalars['String']>>;
    resolverEntry_contains?: Maybe<Scalars['String']>;
    resolverEntry_contains_nocase?: Maybe<Scalars['String']>;
    resolverEntry_not_contains?: Maybe<Scalars['String']>;
    resolverEntry_not_contains_nocase?: Maybe<Scalars['String']>;
    resolverEntry_starts_with?: Maybe<Scalars['String']>;
    resolverEntry_starts_with_nocase?: Maybe<Scalars['String']>;
    resolverEntry_not_starts_with?: Maybe<Scalars['String']>;
    resolverEntry_not_starts_with_nocase?: Maybe<Scalars['String']>;
    resolverEntry_ends_with?: Maybe<Scalars['String']>;
    resolverEntry_ends_with_nocase?: Maybe<Scalars['String']>;
    resolverEntry_not_ends_with?: Maybe<Scalars['String']>;
    resolverEntry_not_ends_with_nocase?: Maybe<Scalars['String']>;
    resolverEntry_?: Maybe<ResolverEntry_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<SetEvent_Filter>>>;
    or?: Maybe<Array<Maybe<SetEvent_Filter>>>;
};
export declare enum SetEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    HashedName = "hashedName",
    Target = "target",
    ResolverEntry = "resolverEntry",
    ResolverEntry__id = "resolverEntry__id",
    ResolverEntry__createdAtTimestamp = "resolverEntry__createdAtTimestamp",
    ResolverEntry__createdAtBlockNumber = "resolverEntry__createdAtBlockNumber",
    ResolverEntry__updatedAtTimestamp = "resolverEntry__updatedAtTimestamp",
    ResolverEntry__updatedAtBlockNumber = "resolverEntry__updatedAtBlockNumber",
    ResolverEntry__targetAddress = "resolverEntry__targetAddress",
    ResolverEntry__isToken = "resolverEntry__isToken",
    ResolverEntry__isListed = "resolverEntry__isListed"
}
/**
 * Stream: A higher order entity that represents the lifetime of a stream between a `sender` and a `receiver`.
 * A account can start a stream, update the flow rate, but when they close it, it is considered "dead".
 * The next stream you create with the same `sender` and `receiver` will create a new stream entity.
 * Therefore, multiple stream entities can be created between the same `sender` and `receiver`.
 */
export type Stream = {
    __typename?: 'Stream';
    /** ID composed of: senderAddress-receiverAddress-tokenAddress-revisionIndex */
    id: Scalars['ID'];
    createdAtTimestamp: Scalars['BigInt'];
    createdAtBlockNumber: Scalars['BigInt'];
    updatedAtTimestamp: Scalars['BigInt'];
    updatedAtBlockNumber: Scalars['BigInt'];
    currentFlowRate: Scalars['BigInt'];
    deposit: Scalars['BigInt'];
    /**
     * The amount streamed until `updatedAtTimestamp`/`updatedAtBlock`.
     * The formula to get the current streamed amount is:
     * `streamedUntilUpdatedAt + ((currentTime in seconds) - updatedAtTimestamp) * currentFlowRate`.
     */
    streamedUntilUpdatedAt: Scalars['BigInt'];
    token: Token;
    sender: Account;
    receiver: Account;
    /**
     * The `userData` stored on the Stream is the last `userData` that was set in a `FlowUpdatedEvent`,
     * for this particular stream. To see the historical `userData` for this stream, you can query the `flowUpdatedEvents` field.
     */
    userData: Scalars['Bytes'];
    flowUpdatedEvents: Array<FlowUpdatedEvent>;
    streamPeriods: Array<StreamPeriod>;
};
/**
 * Stream: A higher order entity that represents the lifetime of a stream between a `sender` and a `receiver`.
 * A account can start a stream, update the flow rate, but when they close it, it is considered "dead".
 * The next stream you create with the same `sender` and `receiver` will create a new stream entity.
 * Therefore, multiple stream entities can be created between the same `sender` and `receiver`.
 */
export type StreamFlowUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowUpdatedEvent_Filter>;
};
/**
 * Stream: A higher order entity that represents the lifetime of a stream between a `sender` and a `receiver`.
 * A account can start a stream, update the flow rate, but when they close it, it is considered "dead".
 * The next stream you create with the same `sender` and `receiver` will create a new stream entity.
 * Therefore, multiple stream entities can be created between the same `sender` and `receiver`.
 */
export type StreamStreamPeriodsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<StreamPeriod_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<StreamPeriod_Filter>;
};
/** StreamPeriod: A higher order entity that represents a period of time in a Stream with a constant flowRate. */
export type StreamPeriod = {
    __typename?: 'StreamPeriod';
    /** ID composed of: streamId - periodRevisionIndex */
    id: Scalars['ID'];
    stream: Stream;
    sender: Account;
    receiver: Account;
    token: Token;
    flowRate: Scalars['BigInt'];
    deposit: Scalars['BigInt'];
    startedAtTimestamp: Scalars['BigInt'];
    startedAtBlockNumber: Scalars['BigInt'];
    startedAtEvent: FlowUpdatedEvent;
    /** Following values are null until the StreamPeriod is terminated */
    stoppedAtTimestamp?: Maybe<Scalars['BigInt']>;
    stoppedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    stoppedAtEvent?: Maybe<FlowUpdatedEvent>;
    totalAmountStreamed?: Maybe<Scalars['BigInt']>;
};
export type StreamPeriod_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    stream?: Maybe<Scalars['String']>;
    stream_not?: Maybe<Scalars['String']>;
    stream_gt?: Maybe<Scalars['String']>;
    stream_lt?: Maybe<Scalars['String']>;
    stream_gte?: Maybe<Scalars['String']>;
    stream_lte?: Maybe<Scalars['String']>;
    stream_in?: Maybe<Array<Scalars['String']>>;
    stream_not_in?: Maybe<Array<Scalars['String']>>;
    stream_contains?: Maybe<Scalars['String']>;
    stream_contains_nocase?: Maybe<Scalars['String']>;
    stream_not_contains?: Maybe<Scalars['String']>;
    stream_not_contains_nocase?: Maybe<Scalars['String']>;
    stream_starts_with?: Maybe<Scalars['String']>;
    stream_starts_with_nocase?: Maybe<Scalars['String']>;
    stream_not_starts_with?: Maybe<Scalars['String']>;
    stream_not_starts_with_nocase?: Maybe<Scalars['String']>;
    stream_ends_with?: Maybe<Scalars['String']>;
    stream_ends_with_nocase?: Maybe<Scalars['String']>;
    stream_not_ends_with?: Maybe<Scalars['String']>;
    stream_not_ends_with_nocase?: Maybe<Scalars['String']>;
    stream_?: Maybe<Stream_Filter>;
    sender?: Maybe<Scalars['String']>;
    sender_not?: Maybe<Scalars['String']>;
    sender_gt?: Maybe<Scalars['String']>;
    sender_lt?: Maybe<Scalars['String']>;
    sender_gte?: Maybe<Scalars['String']>;
    sender_lte?: Maybe<Scalars['String']>;
    sender_in?: Maybe<Array<Scalars['String']>>;
    sender_not_in?: Maybe<Array<Scalars['String']>>;
    sender_contains?: Maybe<Scalars['String']>;
    sender_contains_nocase?: Maybe<Scalars['String']>;
    sender_not_contains?: Maybe<Scalars['String']>;
    sender_not_contains_nocase?: Maybe<Scalars['String']>;
    sender_starts_with?: Maybe<Scalars['String']>;
    sender_starts_with_nocase?: Maybe<Scalars['String']>;
    sender_not_starts_with?: Maybe<Scalars['String']>;
    sender_not_starts_with_nocase?: Maybe<Scalars['String']>;
    sender_ends_with?: Maybe<Scalars['String']>;
    sender_ends_with_nocase?: Maybe<Scalars['String']>;
    sender_not_ends_with?: Maybe<Scalars['String']>;
    sender_not_ends_with_nocase?: Maybe<Scalars['String']>;
    sender_?: Maybe<Account_Filter>;
    receiver?: Maybe<Scalars['String']>;
    receiver_not?: Maybe<Scalars['String']>;
    receiver_gt?: Maybe<Scalars['String']>;
    receiver_lt?: Maybe<Scalars['String']>;
    receiver_gte?: Maybe<Scalars['String']>;
    receiver_lte?: Maybe<Scalars['String']>;
    receiver_in?: Maybe<Array<Scalars['String']>>;
    receiver_not_in?: Maybe<Array<Scalars['String']>>;
    receiver_contains?: Maybe<Scalars['String']>;
    receiver_contains_nocase?: Maybe<Scalars['String']>;
    receiver_not_contains?: Maybe<Scalars['String']>;
    receiver_not_contains_nocase?: Maybe<Scalars['String']>;
    receiver_starts_with?: Maybe<Scalars['String']>;
    receiver_starts_with_nocase?: Maybe<Scalars['String']>;
    receiver_not_starts_with?: Maybe<Scalars['String']>;
    receiver_not_starts_with_nocase?: Maybe<Scalars['String']>;
    receiver_ends_with?: Maybe<Scalars['String']>;
    receiver_ends_with_nocase?: Maybe<Scalars['String']>;
    receiver_not_ends_with?: Maybe<Scalars['String']>;
    receiver_not_ends_with_nocase?: Maybe<Scalars['String']>;
    receiver_?: Maybe<Account_Filter>;
    token?: Maybe<Scalars['String']>;
    token_not?: Maybe<Scalars['String']>;
    token_gt?: Maybe<Scalars['String']>;
    token_lt?: Maybe<Scalars['String']>;
    token_gte?: Maybe<Scalars['String']>;
    token_lte?: Maybe<Scalars['String']>;
    token_in?: Maybe<Array<Scalars['String']>>;
    token_not_in?: Maybe<Array<Scalars['String']>>;
    token_contains?: Maybe<Scalars['String']>;
    token_contains_nocase?: Maybe<Scalars['String']>;
    token_not_contains?: Maybe<Scalars['String']>;
    token_not_contains_nocase?: Maybe<Scalars['String']>;
    token_starts_with?: Maybe<Scalars['String']>;
    token_starts_with_nocase?: Maybe<Scalars['String']>;
    token_not_starts_with?: Maybe<Scalars['String']>;
    token_not_starts_with_nocase?: Maybe<Scalars['String']>;
    token_ends_with?: Maybe<Scalars['String']>;
    token_ends_with_nocase?: Maybe<Scalars['String']>;
    token_not_ends_with?: Maybe<Scalars['String']>;
    token_not_ends_with_nocase?: Maybe<Scalars['String']>;
    token_?: Maybe<Token_Filter>;
    flowRate?: Maybe<Scalars['BigInt']>;
    flowRate_not?: Maybe<Scalars['BigInt']>;
    flowRate_gt?: Maybe<Scalars['BigInt']>;
    flowRate_lt?: Maybe<Scalars['BigInt']>;
    flowRate_gte?: Maybe<Scalars['BigInt']>;
    flowRate_lte?: Maybe<Scalars['BigInt']>;
    flowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    flowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    deposit?: Maybe<Scalars['BigInt']>;
    deposit_not?: Maybe<Scalars['BigInt']>;
    deposit_gt?: Maybe<Scalars['BigInt']>;
    deposit_lt?: Maybe<Scalars['BigInt']>;
    deposit_gte?: Maybe<Scalars['BigInt']>;
    deposit_lte?: Maybe<Scalars['BigInt']>;
    deposit_in?: Maybe<Array<Scalars['BigInt']>>;
    deposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    startedAtTimestamp?: Maybe<Scalars['BigInt']>;
    startedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    startedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    startedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    startedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    startedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    startedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    startedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    startedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    startedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    startedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    startedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    startedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    startedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    startedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    startedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    startedAtEvent?: Maybe<Scalars['String']>;
    startedAtEvent_not?: Maybe<Scalars['String']>;
    startedAtEvent_gt?: Maybe<Scalars['String']>;
    startedAtEvent_lt?: Maybe<Scalars['String']>;
    startedAtEvent_gte?: Maybe<Scalars['String']>;
    startedAtEvent_lte?: Maybe<Scalars['String']>;
    startedAtEvent_in?: Maybe<Array<Scalars['String']>>;
    startedAtEvent_not_in?: Maybe<Array<Scalars['String']>>;
    startedAtEvent_contains?: Maybe<Scalars['String']>;
    startedAtEvent_contains_nocase?: Maybe<Scalars['String']>;
    startedAtEvent_not_contains?: Maybe<Scalars['String']>;
    startedAtEvent_not_contains_nocase?: Maybe<Scalars['String']>;
    startedAtEvent_starts_with?: Maybe<Scalars['String']>;
    startedAtEvent_starts_with_nocase?: Maybe<Scalars['String']>;
    startedAtEvent_not_starts_with?: Maybe<Scalars['String']>;
    startedAtEvent_not_starts_with_nocase?: Maybe<Scalars['String']>;
    startedAtEvent_ends_with?: Maybe<Scalars['String']>;
    startedAtEvent_ends_with_nocase?: Maybe<Scalars['String']>;
    startedAtEvent_not_ends_with?: Maybe<Scalars['String']>;
    startedAtEvent_not_ends_with_nocase?: Maybe<Scalars['String']>;
    startedAtEvent_?: Maybe<FlowUpdatedEvent_Filter>;
    stoppedAtTimestamp?: Maybe<Scalars['BigInt']>;
    stoppedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    stoppedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    stoppedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    stoppedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    stoppedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    stoppedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    stoppedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    stoppedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    stoppedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    stoppedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    stoppedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    stoppedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    stoppedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    stoppedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    stoppedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    stoppedAtEvent?: Maybe<Scalars['String']>;
    stoppedAtEvent_not?: Maybe<Scalars['String']>;
    stoppedAtEvent_gt?: Maybe<Scalars['String']>;
    stoppedAtEvent_lt?: Maybe<Scalars['String']>;
    stoppedAtEvent_gte?: Maybe<Scalars['String']>;
    stoppedAtEvent_lte?: Maybe<Scalars['String']>;
    stoppedAtEvent_in?: Maybe<Array<Scalars['String']>>;
    stoppedAtEvent_not_in?: Maybe<Array<Scalars['String']>>;
    stoppedAtEvent_contains?: Maybe<Scalars['String']>;
    stoppedAtEvent_contains_nocase?: Maybe<Scalars['String']>;
    stoppedAtEvent_not_contains?: Maybe<Scalars['String']>;
    stoppedAtEvent_not_contains_nocase?: Maybe<Scalars['String']>;
    stoppedAtEvent_starts_with?: Maybe<Scalars['String']>;
    stoppedAtEvent_starts_with_nocase?: Maybe<Scalars['String']>;
    stoppedAtEvent_not_starts_with?: Maybe<Scalars['String']>;
    stoppedAtEvent_not_starts_with_nocase?: Maybe<Scalars['String']>;
    stoppedAtEvent_ends_with?: Maybe<Scalars['String']>;
    stoppedAtEvent_ends_with_nocase?: Maybe<Scalars['String']>;
    stoppedAtEvent_not_ends_with?: Maybe<Scalars['String']>;
    stoppedAtEvent_not_ends_with_nocase?: Maybe<Scalars['String']>;
    stoppedAtEvent_?: Maybe<FlowUpdatedEvent_Filter>;
    totalAmountStreamed?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<StreamPeriod_Filter>>>;
    or?: Maybe<Array<Maybe<StreamPeriod_Filter>>>;
};
export declare enum StreamPeriod_OrderBy {
    Id = "id",
    Stream = "stream",
    Stream__id = "stream__id",
    Stream__createdAtTimestamp = "stream__createdAtTimestamp",
    Stream__createdAtBlockNumber = "stream__createdAtBlockNumber",
    Stream__updatedAtTimestamp = "stream__updatedAtTimestamp",
    Stream__updatedAtBlockNumber = "stream__updatedAtBlockNumber",
    Stream__currentFlowRate = "stream__currentFlowRate",
    Stream__deposit = "stream__deposit",
    Stream__streamedUntilUpdatedAt = "stream__streamedUntilUpdatedAt",
    Stream__userData = "stream__userData",
    Sender = "sender",
    Sender__id = "sender__id",
    Sender__createdAtTimestamp = "sender__createdAtTimestamp",
    Sender__createdAtBlockNumber = "sender__createdAtBlockNumber",
    Sender__updatedAtTimestamp = "sender__updatedAtTimestamp",
    Sender__updatedAtBlockNumber = "sender__updatedAtBlockNumber",
    Sender__isSuperApp = "sender__isSuperApp",
    Receiver = "receiver",
    Receiver__id = "receiver__id",
    Receiver__createdAtTimestamp = "receiver__createdAtTimestamp",
    Receiver__createdAtBlockNumber = "receiver__createdAtBlockNumber",
    Receiver__updatedAtTimestamp = "receiver__updatedAtTimestamp",
    Receiver__updatedAtBlockNumber = "receiver__updatedAtBlockNumber",
    Receiver__isSuperApp = "receiver__isSuperApp",
    Token = "token",
    Token__id = "token__id",
    Token__createdAtTimestamp = "token__createdAtTimestamp",
    Token__createdAtBlockNumber = "token__createdAtBlockNumber",
    Token__decimals = "token__decimals",
    Token__name = "token__name",
    Token__symbol = "token__symbol",
    Token__isSuperToken = "token__isSuperToken",
    Token__isNativeAssetSuperToken = "token__isNativeAssetSuperToken",
    Token__isListed = "token__isListed",
    Token__underlyingAddress = "token__underlyingAddress",
    FlowRate = "flowRate",
    Deposit = "deposit",
    StartedAtTimestamp = "startedAtTimestamp",
    StartedAtBlockNumber = "startedAtBlockNumber",
    StartedAtEvent = "startedAtEvent",
    StartedAtEvent__id = "startedAtEvent__id",
    StartedAtEvent__transactionHash = "startedAtEvent__transactionHash",
    StartedAtEvent__gasPrice = "startedAtEvent__gasPrice",
    StartedAtEvent__gasUsed = "startedAtEvent__gasUsed",
    StartedAtEvent__timestamp = "startedAtEvent__timestamp",
    StartedAtEvent__name = "startedAtEvent__name",
    StartedAtEvent__blockNumber = "startedAtEvent__blockNumber",
    StartedAtEvent__logIndex = "startedAtEvent__logIndex",
    StartedAtEvent__order = "startedAtEvent__order",
    StartedAtEvent__token = "startedAtEvent__token",
    StartedAtEvent__sender = "startedAtEvent__sender",
    StartedAtEvent__receiver = "startedAtEvent__receiver",
    StartedAtEvent__flowOperator = "startedAtEvent__flowOperator",
    StartedAtEvent__flowRate = "startedAtEvent__flowRate",
    StartedAtEvent__totalSenderFlowRate = "startedAtEvent__totalSenderFlowRate",
    StartedAtEvent__totalReceiverFlowRate = "startedAtEvent__totalReceiverFlowRate",
    StartedAtEvent__deposit = "startedAtEvent__deposit",
    StartedAtEvent__userData = "startedAtEvent__userData",
    StartedAtEvent__oldFlowRate = "startedAtEvent__oldFlowRate",
    StartedAtEvent__type = "startedAtEvent__type",
    StartedAtEvent__totalAmountStreamedUntilTimestamp = "startedAtEvent__totalAmountStreamedUntilTimestamp",
    StoppedAtTimestamp = "stoppedAtTimestamp",
    StoppedAtBlockNumber = "stoppedAtBlockNumber",
    StoppedAtEvent = "stoppedAtEvent",
    StoppedAtEvent__id = "stoppedAtEvent__id",
    StoppedAtEvent__transactionHash = "stoppedAtEvent__transactionHash",
    StoppedAtEvent__gasPrice = "stoppedAtEvent__gasPrice",
    StoppedAtEvent__gasUsed = "stoppedAtEvent__gasUsed",
    StoppedAtEvent__timestamp = "stoppedAtEvent__timestamp",
    StoppedAtEvent__name = "stoppedAtEvent__name",
    StoppedAtEvent__blockNumber = "stoppedAtEvent__blockNumber",
    StoppedAtEvent__logIndex = "stoppedAtEvent__logIndex",
    StoppedAtEvent__order = "stoppedAtEvent__order",
    StoppedAtEvent__token = "stoppedAtEvent__token",
    StoppedAtEvent__sender = "stoppedAtEvent__sender",
    StoppedAtEvent__receiver = "stoppedAtEvent__receiver",
    StoppedAtEvent__flowOperator = "stoppedAtEvent__flowOperator",
    StoppedAtEvent__flowRate = "stoppedAtEvent__flowRate",
    StoppedAtEvent__totalSenderFlowRate = "stoppedAtEvent__totalSenderFlowRate",
    StoppedAtEvent__totalReceiverFlowRate = "stoppedAtEvent__totalReceiverFlowRate",
    StoppedAtEvent__deposit = "stoppedAtEvent__deposit",
    StoppedAtEvent__userData = "stoppedAtEvent__userData",
    StoppedAtEvent__oldFlowRate = "stoppedAtEvent__oldFlowRate",
    StoppedAtEvent__type = "stoppedAtEvent__type",
    StoppedAtEvent__totalAmountStreamedUntilTimestamp = "stoppedAtEvent__totalAmountStreamedUntilTimestamp",
    TotalAmountStreamed = "totalAmountStreamed"
}
export type StreamRevision = {
    __typename?: 'StreamRevision';
    /** ID composed of: keccak256(abi.encode(sender,receiver))-tokenAddress */
    id: Scalars['ID'];
    revisionIndex: Scalars['Int'];
    periodRevisionIndex: Scalars['Int'];
    /**
     * The "most recently alive" stream between a sender and receiver.
     * Note: The `revisionIndex` property may not be the same as the `revisionIndex` of `mostRecentStream`. Which means `mostRecentStream` has been closed and no new stream has been opened.
     */
    mostRecentStream: Stream;
};
export type StreamRevision_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    revisionIndex?: Maybe<Scalars['Int']>;
    revisionIndex_not?: Maybe<Scalars['Int']>;
    revisionIndex_gt?: Maybe<Scalars['Int']>;
    revisionIndex_lt?: Maybe<Scalars['Int']>;
    revisionIndex_gte?: Maybe<Scalars['Int']>;
    revisionIndex_lte?: Maybe<Scalars['Int']>;
    revisionIndex_in?: Maybe<Array<Scalars['Int']>>;
    revisionIndex_not_in?: Maybe<Array<Scalars['Int']>>;
    periodRevisionIndex?: Maybe<Scalars['Int']>;
    periodRevisionIndex_not?: Maybe<Scalars['Int']>;
    periodRevisionIndex_gt?: Maybe<Scalars['Int']>;
    periodRevisionIndex_lt?: Maybe<Scalars['Int']>;
    periodRevisionIndex_gte?: Maybe<Scalars['Int']>;
    periodRevisionIndex_lte?: Maybe<Scalars['Int']>;
    periodRevisionIndex_in?: Maybe<Array<Scalars['Int']>>;
    periodRevisionIndex_not_in?: Maybe<Array<Scalars['Int']>>;
    mostRecentStream?: Maybe<Scalars['String']>;
    mostRecentStream_not?: Maybe<Scalars['String']>;
    mostRecentStream_gt?: Maybe<Scalars['String']>;
    mostRecentStream_lt?: Maybe<Scalars['String']>;
    mostRecentStream_gte?: Maybe<Scalars['String']>;
    mostRecentStream_lte?: Maybe<Scalars['String']>;
    mostRecentStream_in?: Maybe<Array<Scalars['String']>>;
    mostRecentStream_not_in?: Maybe<Array<Scalars['String']>>;
    mostRecentStream_contains?: Maybe<Scalars['String']>;
    mostRecentStream_contains_nocase?: Maybe<Scalars['String']>;
    mostRecentStream_not_contains?: Maybe<Scalars['String']>;
    mostRecentStream_not_contains_nocase?: Maybe<Scalars['String']>;
    mostRecentStream_starts_with?: Maybe<Scalars['String']>;
    mostRecentStream_starts_with_nocase?: Maybe<Scalars['String']>;
    mostRecentStream_not_starts_with?: Maybe<Scalars['String']>;
    mostRecentStream_not_starts_with_nocase?: Maybe<Scalars['String']>;
    mostRecentStream_ends_with?: Maybe<Scalars['String']>;
    mostRecentStream_ends_with_nocase?: Maybe<Scalars['String']>;
    mostRecentStream_not_ends_with?: Maybe<Scalars['String']>;
    mostRecentStream_not_ends_with_nocase?: Maybe<Scalars['String']>;
    mostRecentStream_?: Maybe<Stream_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<StreamRevision_Filter>>>;
    or?: Maybe<Array<Maybe<StreamRevision_Filter>>>;
};
export declare enum StreamRevision_OrderBy {
    Id = "id",
    RevisionIndex = "revisionIndex",
    PeriodRevisionIndex = "periodRevisionIndex",
    MostRecentStream = "mostRecentStream",
    MostRecentStream__id = "mostRecentStream__id",
    MostRecentStream__createdAtTimestamp = "mostRecentStream__createdAtTimestamp",
    MostRecentStream__createdAtBlockNumber = "mostRecentStream__createdAtBlockNumber",
    MostRecentStream__updatedAtTimestamp = "mostRecentStream__updatedAtTimestamp",
    MostRecentStream__updatedAtBlockNumber = "mostRecentStream__updatedAtBlockNumber",
    MostRecentStream__currentFlowRate = "mostRecentStream__currentFlowRate",
    MostRecentStream__deposit = "mostRecentStream__deposit",
    MostRecentStream__streamedUntilUpdatedAt = "mostRecentStream__streamedUntilUpdatedAt",
    MostRecentStream__userData = "mostRecentStream__userData"
}
export type Stream_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    createdAtTimestamp?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    currentFlowRate?: Maybe<Scalars['BigInt']>;
    currentFlowRate_not?: Maybe<Scalars['BigInt']>;
    currentFlowRate_gt?: Maybe<Scalars['BigInt']>;
    currentFlowRate_lt?: Maybe<Scalars['BigInt']>;
    currentFlowRate_gte?: Maybe<Scalars['BigInt']>;
    currentFlowRate_lte?: Maybe<Scalars['BigInt']>;
    currentFlowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    currentFlowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    deposit?: Maybe<Scalars['BigInt']>;
    deposit_not?: Maybe<Scalars['BigInt']>;
    deposit_gt?: Maybe<Scalars['BigInt']>;
    deposit_lt?: Maybe<Scalars['BigInt']>;
    deposit_gte?: Maybe<Scalars['BigInt']>;
    deposit_lte?: Maybe<Scalars['BigInt']>;
    deposit_in?: Maybe<Array<Scalars['BigInt']>>;
    deposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    streamedUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    streamedUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    streamedUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    streamedUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    streamedUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    streamedUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    streamedUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    streamedUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['String']>;
    token_not?: Maybe<Scalars['String']>;
    token_gt?: Maybe<Scalars['String']>;
    token_lt?: Maybe<Scalars['String']>;
    token_gte?: Maybe<Scalars['String']>;
    token_lte?: Maybe<Scalars['String']>;
    token_in?: Maybe<Array<Scalars['String']>>;
    token_not_in?: Maybe<Array<Scalars['String']>>;
    token_contains?: Maybe<Scalars['String']>;
    token_contains_nocase?: Maybe<Scalars['String']>;
    token_not_contains?: Maybe<Scalars['String']>;
    token_not_contains_nocase?: Maybe<Scalars['String']>;
    token_starts_with?: Maybe<Scalars['String']>;
    token_starts_with_nocase?: Maybe<Scalars['String']>;
    token_not_starts_with?: Maybe<Scalars['String']>;
    token_not_starts_with_nocase?: Maybe<Scalars['String']>;
    token_ends_with?: Maybe<Scalars['String']>;
    token_ends_with_nocase?: Maybe<Scalars['String']>;
    token_not_ends_with?: Maybe<Scalars['String']>;
    token_not_ends_with_nocase?: Maybe<Scalars['String']>;
    token_?: Maybe<Token_Filter>;
    sender?: Maybe<Scalars['String']>;
    sender_not?: Maybe<Scalars['String']>;
    sender_gt?: Maybe<Scalars['String']>;
    sender_lt?: Maybe<Scalars['String']>;
    sender_gte?: Maybe<Scalars['String']>;
    sender_lte?: Maybe<Scalars['String']>;
    sender_in?: Maybe<Array<Scalars['String']>>;
    sender_not_in?: Maybe<Array<Scalars['String']>>;
    sender_contains?: Maybe<Scalars['String']>;
    sender_contains_nocase?: Maybe<Scalars['String']>;
    sender_not_contains?: Maybe<Scalars['String']>;
    sender_not_contains_nocase?: Maybe<Scalars['String']>;
    sender_starts_with?: Maybe<Scalars['String']>;
    sender_starts_with_nocase?: Maybe<Scalars['String']>;
    sender_not_starts_with?: Maybe<Scalars['String']>;
    sender_not_starts_with_nocase?: Maybe<Scalars['String']>;
    sender_ends_with?: Maybe<Scalars['String']>;
    sender_ends_with_nocase?: Maybe<Scalars['String']>;
    sender_not_ends_with?: Maybe<Scalars['String']>;
    sender_not_ends_with_nocase?: Maybe<Scalars['String']>;
    sender_?: Maybe<Account_Filter>;
    receiver?: Maybe<Scalars['String']>;
    receiver_not?: Maybe<Scalars['String']>;
    receiver_gt?: Maybe<Scalars['String']>;
    receiver_lt?: Maybe<Scalars['String']>;
    receiver_gte?: Maybe<Scalars['String']>;
    receiver_lte?: Maybe<Scalars['String']>;
    receiver_in?: Maybe<Array<Scalars['String']>>;
    receiver_not_in?: Maybe<Array<Scalars['String']>>;
    receiver_contains?: Maybe<Scalars['String']>;
    receiver_contains_nocase?: Maybe<Scalars['String']>;
    receiver_not_contains?: Maybe<Scalars['String']>;
    receiver_not_contains_nocase?: Maybe<Scalars['String']>;
    receiver_starts_with?: Maybe<Scalars['String']>;
    receiver_starts_with_nocase?: Maybe<Scalars['String']>;
    receiver_not_starts_with?: Maybe<Scalars['String']>;
    receiver_not_starts_with_nocase?: Maybe<Scalars['String']>;
    receiver_ends_with?: Maybe<Scalars['String']>;
    receiver_ends_with_nocase?: Maybe<Scalars['String']>;
    receiver_not_ends_with?: Maybe<Scalars['String']>;
    receiver_not_ends_with_nocase?: Maybe<Scalars['String']>;
    receiver_?: Maybe<Account_Filter>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_gt?: Maybe<Scalars['Bytes']>;
    userData_lt?: Maybe<Scalars['Bytes']>;
    userData_gte?: Maybe<Scalars['Bytes']>;
    userData_lte?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    flowUpdatedEvents_?: Maybe<FlowUpdatedEvent_Filter>;
    streamPeriods_?: Maybe<StreamPeriod_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<Stream_Filter>>>;
    or?: Maybe<Array<Maybe<Stream_Filter>>>;
};
export declare enum Stream_OrderBy {
    Id = "id",
    CreatedAtTimestamp = "createdAtTimestamp",
    CreatedAtBlockNumber = "createdAtBlockNumber",
    UpdatedAtTimestamp = "updatedAtTimestamp",
    UpdatedAtBlockNumber = "updatedAtBlockNumber",
    CurrentFlowRate = "currentFlowRate",
    Deposit = "deposit",
    StreamedUntilUpdatedAt = "streamedUntilUpdatedAt",
    Token = "token",
    Token__id = "token__id",
    Token__createdAtTimestamp = "token__createdAtTimestamp",
    Token__createdAtBlockNumber = "token__createdAtBlockNumber",
    Token__decimals = "token__decimals",
    Token__name = "token__name",
    Token__symbol = "token__symbol",
    Token__isSuperToken = "token__isSuperToken",
    Token__isNativeAssetSuperToken = "token__isNativeAssetSuperToken",
    Token__isListed = "token__isListed",
    Token__underlyingAddress = "token__underlyingAddress",
    Sender = "sender",
    Sender__id = "sender__id",
    Sender__createdAtTimestamp = "sender__createdAtTimestamp",
    Sender__createdAtBlockNumber = "sender__createdAtBlockNumber",
    Sender__updatedAtTimestamp = "sender__updatedAtTimestamp",
    Sender__updatedAtBlockNumber = "sender__updatedAtBlockNumber",
    Sender__isSuperApp = "sender__isSuperApp",
    Receiver = "receiver",
    Receiver__id = "receiver__id",
    Receiver__createdAtTimestamp = "receiver__createdAtTimestamp",
    Receiver__createdAtBlockNumber = "receiver__createdAtBlockNumber",
    Receiver__updatedAtTimestamp = "receiver__updatedAtTimestamp",
    Receiver__updatedAtBlockNumber = "receiver__updatedAtBlockNumber",
    Receiver__isSuperApp = "receiver__isSuperApp",
    UserData = "userData",
    FlowUpdatedEvents = "flowUpdatedEvents",
    StreamPeriods = "streamPeriods"
}
export type Subscription = {
    __typename?: 'Subscription';
    flowUpdatedEvent?: Maybe<FlowUpdatedEvent>;
    flowUpdatedEvents: Array<FlowUpdatedEvent>;
    flowOperatorUpdatedEvent?: Maybe<FlowOperatorUpdatedEvent>;
    flowOperatorUpdatedEvents: Array<FlowOperatorUpdatedEvent>;
    indexCreatedEvent?: Maybe<IndexCreatedEvent>;
    indexCreatedEvents: Array<IndexCreatedEvent>;
    indexDistributionClaimedEvent?: Maybe<IndexDistributionClaimedEvent>;
    indexDistributionClaimedEvents: Array<IndexDistributionClaimedEvent>;
    indexUpdatedEvent?: Maybe<IndexUpdatedEvent>;
    indexUpdatedEvents: Array<IndexUpdatedEvent>;
    indexSubscribedEvent?: Maybe<IndexSubscribedEvent>;
    indexSubscribedEvents: Array<IndexSubscribedEvent>;
    indexUnitsUpdatedEvent?: Maybe<IndexUnitsUpdatedEvent>;
    indexUnitsUpdatedEvents: Array<IndexUnitsUpdatedEvent>;
    indexUnsubscribedEvent?: Maybe<IndexUnsubscribedEvent>;
    indexUnsubscribedEvents: Array<IndexUnsubscribedEvent>;
    subscriptionApprovedEvent?: Maybe<SubscriptionApprovedEvent>;
    subscriptionApprovedEvents: Array<SubscriptionApprovedEvent>;
    subscriptionDistributionClaimedEvent?: Maybe<SubscriptionDistributionClaimedEvent>;
    subscriptionDistributionClaimedEvents: Array<SubscriptionDistributionClaimedEvent>;
    subscriptionRevokedEvent?: Maybe<SubscriptionRevokedEvent>;
    subscriptionRevokedEvents: Array<SubscriptionRevokedEvent>;
    subscriptionUnitsUpdatedEvent?: Maybe<SubscriptionUnitsUpdatedEvent>;
    subscriptionUnitsUpdatedEvents: Array<SubscriptionUnitsUpdatedEvent>;
    agreementClassRegisteredEvent?: Maybe<AgreementClassRegisteredEvent>;
    agreementClassRegisteredEvents: Array<AgreementClassRegisteredEvent>;
    agreementClassUpdatedEvent?: Maybe<AgreementClassUpdatedEvent>;
    agreementClassUpdatedEvents: Array<AgreementClassUpdatedEvent>;
    appRegisteredEvent?: Maybe<AppRegisteredEvent>;
    appRegisteredEvents: Array<AppRegisteredEvent>;
    governanceReplacedEvent?: Maybe<GovernanceReplacedEvent>;
    governanceReplacedEvents: Array<GovernanceReplacedEvent>;
    jailEvent?: Maybe<JailEvent>;
    jailEvents: Array<JailEvent>;
    superTokenFactoryUpdatedEvent?: Maybe<SuperTokenFactoryUpdatedEvent>;
    superTokenFactoryUpdatedEvents: Array<SuperTokenFactoryUpdatedEvent>;
    superTokenLogicUpdatedEvent?: Maybe<SuperTokenLogicUpdatedEvent>;
    superTokenLogicUpdatedEvents: Array<SuperTokenLogicUpdatedEvent>;
    roleAdminChangedEvent?: Maybe<RoleAdminChangedEvent>;
    roleAdminChangedEvents: Array<RoleAdminChangedEvent>;
    roleGrantedEvent?: Maybe<RoleGrantedEvent>;
    roleGrantedEvents: Array<RoleGrantedEvent>;
    roleRevokedEvent?: Maybe<RoleRevokedEvent>;
    roleRevokedEvents: Array<RoleRevokedEvent>;
    setEvent?: Maybe<SetEvent>;
    setEvents: Array<SetEvent>;
    cfav1LiquidationPeriodChangedEvent?: Maybe<CfAv1LiquidationPeriodChangedEvent>;
    cfav1LiquidationPeriodChangedEvents: Array<CfAv1LiquidationPeriodChangedEvent>;
    configChangedEvent?: Maybe<ConfigChangedEvent>;
    configChangedEvents: Array<ConfigChangedEvent>;
    rewardAddressChangedEvent?: Maybe<RewardAddressChangedEvent>;
    rewardAddressChangedEvents: Array<RewardAddressChangedEvent>;
    pppconfigurationChangedEvent?: Maybe<PppConfigurationChangedEvent>;
    pppconfigurationChangedEvents: Array<PppConfigurationChangedEvent>;
    superTokenMinimumDepositChangedEvent?: Maybe<SuperTokenMinimumDepositChangedEvent>;
    superTokenMinimumDepositChangedEvents: Array<SuperTokenMinimumDepositChangedEvent>;
    trustedForwarderChangedEvent?: Maybe<TrustedForwarderChangedEvent>;
    trustedForwarderChangedEvents: Array<TrustedForwarderChangedEvent>;
    agreementLiquidatedByEvent?: Maybe<AgreementLiquidatedByEvent>;
    agreementLiquidatedByEvents: Array<AgreementLiquidatedByEvent>;
    agreementLiquidatedV2Event?: Maybe<AgreementLiquidatedV2Event>;
    agreementLiquidatedV2Events: Array<AgreementLiquidatedV2Event>;
    burnedEvent?: Maybe<BurnedEvent>;
    burnedEvents: Array<BurnedEvent>;
    mintedEvent?: Maybe<MintedEvent>;
    mintedEvents: Array<MintedEvent>;
    sentEvent?: Maybe<SentEvent>;
    sentEvents: Array<SentEvent>;
    transferEvent?: Maybe<TransferEvent>;
    transferEvents: Array<TransferEvent>;
    tokenDowngradedEvent?: Maybe<TokenDowngradedEvent>;
    tokenDowngradedEvents: Array<TokenDowngradedEvent>;
    tokenUpgradedEvent?: Maybe<TokenUpgradedEvent>;
    tokenUpgradedEvents: Array<TokenUpgradedEvent>;
    customSuperTokenCreatedEvent?: Maybe<CustomSuperTokenCreatedEvent>;
    customSuperTokenCreatedEvents: Array<CustomSuperTokenCreatedEvent>;
    superTokenCreatedEvent?: Maybe<SuperTokenCreatedEvent>;
    superTokenCreatedEvents: Array<SuperTokenCreatedEvent>;
    superTokenLogicCreatedEvent?: Maybe<SuperTokenLogicCreatedEvent>;
    superTokenLogicCreatedEvents: Array<SuperTokenLogicCreatedEvent>;
    newPICEvent?: Maybe<NewPicEvent>;
    newPICEvents: Array<NewPicEvent>;
    exitRateChangedEvent?: Maybe<ExitRateChangedEvent>;
    exitRateChangedEvents: Array<ExitRateChangedEvent>;
    bondIncreasedEvent?: Maybe<BondIncreasedEvent>;
    bondIncreasedEvents: Array<BondIncreasedEvent>;
    account?: Maybe<Account>;
    accounts: Array<Account>;
    index?: Maybe<Index>;
    indexes: Array<Index>;
    indexSubscription?: Maybe<IndexSubscription>;
    indexSubscriptions: Array<IndexSubscription>;
    stream?: Maybe<Stream>;
    streams: Array<Stream>;
    flowOperator?: Maybe<FlowOperator>;
    flowOperators: Array<FlowOperator>;
    streamPeriod?: Maybe<StreamPeriod>;
    streamPeriods: Array<StreamPeriod>;
    tokenGovernanceConfig?: Maybe<TokenGovernanceConfig>;
    tokenGovernanceConfigs: Array<TokenGovernanceConfig>;
    streamRevision?: Maybe<StreamRevision>;
    streamRevisions: Array<StreamRevision>;
    token?: Maybe<Token>;
    tokens: Array<Token>;
    resolverEntry?: Maybe<ResolverEntry>;
    resolverEntries: Array<ResolverEntry>;
    accountTokenSnapshot?: Maybe<AccountTokenSnapshot>;
    accountTokenSnapshots: Array<AccountTokenSnapshot>;
    accountTokenSnapshotLog?: Maybe<AccountTokenSnapshotLog>;
    accountTokenSnapshotLogs: Array<AccountTokenSnapshotLog>;
    tokenStatistic?: Maybe<TokenStatistic>;
    tokenStatistics: Array<TokenStatistic>;
    tokenStatisticLog?: Maybe<TokenStatisticLog>;
    tokenStatisticLogs: Array<TokenStatisticLog>;
    sfmeta?: Maybe<SfMeta>;
    sfmetas: Array<SfMeta>;
    event?: Maybe<Event>;
    events: Array<Event>;
    /** Access to subgraph metadata */
    _meta?: Maybe<_Meta_>;
};
export type SubscriptionFlowUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionFlowUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionFlowOperatorUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionFlowOperatorUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowOperatorUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowOperatorUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionIndexCreatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionIndexCreatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexCreatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexCreatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionIndexDistributionClaimedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionIndexDistributionClaimedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexDistributionClaimedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexDistributionClaimedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionIndexUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionIndexUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionIndexSubscribedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionIndexSubscribedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexSubscribedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexSubscribedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionIndexUnitsUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionIndexUnitsUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUnitsUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUnitsUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionIndexUnsubscribedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionIndexUnsubscribedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUnsubscribedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUnsubscribedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSubscriptionApprovedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSubscriptionApprovedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionApprovedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionApprovedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSubscriptionDistributionClaimedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSubscriptionDistributionClaimedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionDistributionClaimedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionDistributionClaimedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSubscriptionRevokedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSubscriptionRevokedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionRevokedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionRevokedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSubscriptionUnitsUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSubscriptionUnitsUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionUnitsUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionUnitsUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionAgreementClassRegisteredEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionAgreementClassRegisteredEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AgreementClassRegisteredEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AgreementClassRegisteredEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionAgreementClassUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionAgreementClassUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AgreementClassUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AgreementClassUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionAppRegisteredEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionAppRegisteredEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AppRegisteredEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AppRegisteredEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionGovernanceReplacedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionGovernanceReplacedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<GovernanceReplacedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<GovernanceReplacedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionJailEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionJailEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<JailEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<JailEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSuperTokenFactoryUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSuperTokenFactoryUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenFactoryUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenFactoryUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSuperTokenLogicUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSuperTokenLogicUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenLogicUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenLogicUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionRoleAdminChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionRoleAdminChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RoleAdminChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RoleAdminChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionRoleGrantedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionRoleGrantedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RoleGrantedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RoleGrantedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionRoleRevokedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionRoleRevokedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RoleRevokedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RoleRevokedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSetEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSetEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SetEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SetEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionCfav1LiquidationPeriodChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionCfav1LiquidationPeriodChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<CfAv1LiquidationPeriodChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<CfAv1LiquidationPeriodChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionConfigChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionConfigChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<ConfigChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<ConfigChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionRewardAddressChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionRewardAddressChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RewardAddressChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RewardAddressChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionPppconfigurationChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionPppconfigurationChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<PppConfigurationChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<PppConfigurationChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSuperTokenMinimumDepositChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSuperTokenMinimumDepositChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenMinimumDepositChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenMinimumDepositChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionTrustedForwarderChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionTrustedForwarderChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TrustedForwarderChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TrustedForwarderChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionAgreementLiquidatedByEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionAgreementLiquidatedByEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AgreementLiquidatedByEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AgreementLiquidatedByEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionAgreementLiquidatedV2EventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionAgreementLiquidatedV2EventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AgreementLiquidatedV2Event_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AgreementLiquidatedV2Event_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionBurnedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionBurnedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<BurnedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<BurnedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionMintedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionMintedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<MintedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<MintedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSentEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSentEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SentEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SentEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionTransferEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionTransferEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TransferEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TransferEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionTokenDowngradedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionTokenDowngradedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenDowngradedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenDowngradedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionTokenUpgradedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionTokenUpgradedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenUpgradedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenUpgradedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionCustomSuperTokenCreatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionCustomSuperTokenCreatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<CustomSuperTokenCreatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<CustomSuperTokenCreatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSuperTokenCreatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSuperTokenCreatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenCreatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenCreatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSuperTokenLogicCreatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSuperTokenLogicCreatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenLogicCreatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenLogicCreatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionNewPicEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionNewPicEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<NewPicEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<NewPicEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionExitRateChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionExitRateChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<ExitRateChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<ExitRateChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionBondIncreasedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionBondIncreasedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<BondIncreasedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<BondIncreasedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionAccountArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionAccountsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Account_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Account_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionIndexArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionIndexesArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Index_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Index_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionIndexSubscriptionArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionIndexSubscriptionsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexSubscription_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexSubscription_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionStreamArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionStreamsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Stream_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Stream_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionFlowOperatorArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionFlowOperatorsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowOperator_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowOperator_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionStreamPeriodArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionStreamPeriodsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<StreamPeriod_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<StreamPeriod_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionTokenGovernanceConfigArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionTokenGovernanceConfigsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenGovernanceConfig_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenGovernanceConfig_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionStreamRevisionArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionStreamRevisionsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<StreamRevision_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<StreamRevision_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionTokenArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionTokensArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Token_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Token_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionResolverEntryArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionResolverEntriesArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<ResolverEntry_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<ResolverEntry_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionAccountTokenSnapshotArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionAccountTokenSnapshotsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AccountTokenSnapshot_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AccountTokenSnapshot_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionAccountTokenSnapshotLogArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionAccountTokenSnapshotLogsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AccountTokenSnapshotLog_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AccountTokenSnapshotLog_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionTokenStatisticArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionTokenStatisticsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenStatistic_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenStatistic_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionTokenStatisticLogArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionTokenStatisticLogsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenStatisticLog_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenStatisticLog_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSfmetaArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionSfmetasArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SfMeta_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SfMeta_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type SubscriptionEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Event_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Event_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export type Subscription_MetaArgs = {
    block?: Maybe<Block_Height>;
};
export type SubscriptionApprovedEvent = Event & {
    __typename?: 'SubscriptionApprovedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `publisher`
     * addresses[2] = `subscriber`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    /**
     * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
     * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
     */
    subscriber: Scalars['Bytes'];
    /** The creator of the `index`. */
    publisher: Scalars['Bytes'];
    /** An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`. */
    indexId: Scalars['BigInt'];
    userData: Scalars['Bytes'];
    subscription: IndexSubscription;
};
export type SubscriptionApprovedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    subscriber?: Maybe<Scalars['Bytes']>;
    subscriber_not?: Maybe<Scalars['Bytes']>;
    subscriber_gt?: Maybe<Scalars['Bytes']>;
    subscriber_lt?: Maybe<Scalars['Bytes']>;
    subscriber_gte?: Maybe<Scalars['Bytes']>;
    subscriber_lte?: Maybe<Scalars['Bytes']>;
    subscriber_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_not_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_contains?: Maybe<Scalars['Bytes']>;
    subscriber_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_gt?: Maybe<Scalars['Bytes']>;
    publisher_lt?: Maybe<Scalars['Bytes']>;
    publisher_gte?: Maybe<Scalars['Bytes']>;
    publisher_lte?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_gt?: Maybe<Scalars['Bytes']>;
    userData_lt?: Maybe<Scalars['Bytes']>;
    userData_gte?: Maybe<Scalars['Bytes']>;
    userData_lte?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    subscription?: Maybe<Scalars['String']>;
    subscription_not?: Maybe<Scalars['String']>;
    subscription_gt?: Maybe<Scalars['String']>;
    subscription_lt?: Maybe<Scalars['String']>;
    subscription_gte?: Maybe<Scalars['String']>;
    subscription_lte?: Maybe<Scalars['String']>;
    subscription_in?: Maybe<Array<Scalars['String']>>;
    subscription_not_in?: Maybe<Array<Scalars['String']>>;
    subscription_contains?: Maybe<Scalars['String']>;
    subscription_contains_nocase?: Maybe<Scalars['String']>;
    subscription_not_contains?: Maybe<Scalars['String']>;
    subscription_not_contains_nocase?: Maybe<Scalars['String']>;
    subscription_starts_with?: Maybe<Scalars['String']>;
    subscription_starts_with_nocase?: Maybe<Scalars['String']>;
    subscription_not_starts_with?: Maybe<Scalars['String']>;
    subscription_not_starts_with_nocase?: Maybe<Scalars['String']>;
    subscription_ends_with?: Maybe<Scalars['String']>;
    subscription_ends_with_nocase?: Maybe<Scalars['String']>;
    subscription_not_ends_with?: Maybe<Scalars['String']>;
    subscription_not_ends_with_nocase?: Maybe<Scalars['String']>;
    subscription_?: Maybe<IndexSubscription_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<SubscriptionApprovedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<SubscriptionApprovedEvent_Filter>>>;
};
export declare enum SubscriptionApprovedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Subscriber = "subscriber",
    Publisher = "publisher",
    IndexId = "indexId",
    UserData = "userData",
    Subscription = "subscription",
    Subscription__id = "subscription__id",
    Subscription__createdAtTimestamp = "subscription__createdAtTimestamp",
    Subscription__createdAtBlockNumber = "subscription__createdAtBlockNumber",
    Subscription__updatedAtTimestamp = "subscription__updatedAtTimestamp",
    Subscription__updatedAtBlockNumber = "subscription__updatedAtBlockNumber",
    Subscription__approved = "subscription__approved",
    Subscription__units = "subscription__units",
    Subscription__totalAmountReceivedUntilUpdatedAt = "subscription__totalAmountReceivedUntilUpdatedAt",
    Subscription__indexValueUntilUpdatedAt = "subscription__indexValueUntilUpdatedAt"
}
export type SubscriptionDistributionClaimedEvent = Event & {
    __typename?: 'SubscriptionDistributionClaimedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `publisher`
     * addresses[2] = `subscriber`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    /**
     * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
     * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
     */
    subscriber: Scalars['Bytes'];
    /** The creator of the `index`. */
    publisher: Scalars['Bytes'];
    /** An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`. */
    indexId: Scalars['BigInt'];
    amount: Scalars['BigInt'];
    subscription: IndexSubscription;
};
export type SubscriptionDistributionClaimedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    subscriber?: Maybe<Scalars['Bytes']>;
    subscriber_not?: Maybe<Scalars['Bytes']>;
    subscriber_gt?: Maybe<Scalars['Bytes']>;
    subscriber_lt?: Maybe<Scalars['Bytes']>;
    subscriber_gte?: Maybe<Scalars['Bytes']>;
    subscriber_lte?: Maybe<Scalars['Bytes']>;
    subscriber_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_not_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_contains?: Maybe<Scalars['Bytes']>;
    subscriber_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_gt?: Maybe<Scalars['Bytes']>;
    publisher_lt?: Maybe<Scalars['Bytes']>;
    publisher_gte?: Maybe<Scalars['Bytes']>;
    publisher_lte?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    amount?: Maybe<Scalars['BigInt']>;
    amount_not?: Maybe<Scalars['BigInt']>;
    amount_gt?: Maybe<Scalars['BigInt']>;
    amount_lt?: Maybe<Scalars['BigInt']>;
    amount_gte?: Maybe<Scalars['BigInt']>;
    amount_lte?: Maybe<Scalars['BigInt']>;
    amount_in?: Maybe<Array<Scalars['BigInt']>>;
    amount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    subscription?: Maybe<Scalars['String']>;
    subscription_not?: Maybe<Scalars['String']>;
    subscription_gt?: Maybe<Scalars['String']>;
    subscription_lt?: Maybe<Scalars['String']>;
    subscription_gte?: Maybe<Scalars['String']>;
    subscription_lte?: Maybe<Scalars['String']>;
    subscription_in?: Maybe<Array<Scalars['String']>>;
    subscription_not_in?: Maybe<Array<Scalars['String']>>;
    subscription_contains?: Maybe<Scalars['String']>;
    subscription_contains_nocase?: Maybe<Scalars['String']>;
    subscription_not_contains?: Maybe<Scalars['String']>;
    subscription_not_contains_nocase?: Maybe<Scalars['String']>;
    subscription_starts_with?: Maybe<Scalars['String']>;
    subscription_starts_with_nocase?: Maybe<Scalars['String']>;
    subscription_not_starts_with?: Maybe<Scalars['String']>;
    subscription_not_starts_with_nocase?: Maybe<Scalars['String']>;
    subscription_ends_with?: Maybe<Scalars['String']>;
    subscription_ends_with_nocase?: Maybe<Scalars['String']>;
    subscription_not_ends_with?: Maybe<Scalars['String']>;
    subscription_not_ends_with_nocase?: Maybe<Scalars['String']>;
    subscription_?: Maybe<IndexSubscription_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<SubscriptionDistributionClaimedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<SubscriptionDistributionClaimedEvent_Filter>>>;
};
export declare enum SubscriptionDistributionClaimedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Subscriber = "subscriber",
    Publisher = "publisher",
    IndexId = "indexId",
    Amount = "amount",
    Subscription = "subscription",
    Subscription__id = "subscription__id",
    Subscription__createdAtTimestamp = "subscription__createdAtTimestamp",
    Subscription__createdAtBlockNumber = "subscription__createdAtBlockNumber",
    Subscription__updatedAtTimestamp = "subscription__updatedAtTimestamp",
    Subscription__updatedAtBlockNumber = "subscription__updatedAtBlockNumber",
    Subscription__approved = "subscription__approved",
    Subscription__units = "subscription__units",
    Subscription__totalAmountReceivedUntilUpdatedAt = "subscription__totalAmountReceivedUntilUpdatedAt",
    Subscription__indexValueUntilUpdatedAt = "subscription__indexValueUntilUpdatedAt"
}
export type SubscriptionRevokedEvent = Event & {
    __typename?: 'SubscriptionRevokedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `publisher`
     * addresses[2] = `subscriber`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    /**
     * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
     * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
     */
    subscriber: Scalars['Bytes'];
    /** The creator of the `index`. */
    publisher: Scalars['Bytes'];
    /** An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`. */
    indexId: Scalars['BigInt'];
    userData: Scalars['Bytes'];
    subscription: IndexSubscription;
};
export type SubscriptionRevokedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    subscriber?: Maybe<Scalars['Bytes']>;
    subscriber_not?: Maybe<Scalars['Bytes']>;
    subscriber_gt?: Maybe<Scalars['Bytes']>;
    subscriber_lt?: Maybe<Scalars['Bytes']>;
    subscriber_gte?: Maybe<Scalars['Bytes']>;
    subscriber_lte?: Maybe<Scalars['Bytes']>;
    subscriber_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_not_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_contains?: Maybe<Scalars['Bytes']>;
    subscriber_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_gt?: Maybe<Scalars['Bytes']>;
    publisher_lt?: Maybe<Scalars['Bytes']>;
    publisher_gte?: Maybe<Scalars['Bytes']>;
    publisher_lte?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_gt?: Maybe<Scalars['Bytes']>;
    userData_lt?: Maybe<Scalars['Bytes']>;
    userData_gte?: Maybe<Scalars['Bytes']>;
    userData_lte?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    subscription?: Maybe<Scalars['String']>;
    subscription_not?: Maybe<Scalars['String']>;
    subscription_gt?: Maybe<Scalars['String']>;
    subscription_lt?: Maybe<Scalars['String']>;
    subscription_gte?: Maybe<Scalars['String']>;
    subscription_lte?: Maybe<Scalars['String']>;
    subscription_in?: Maybe<Array<Scalars['String']>>;
    subscription_not_in?: Maybe<Array<Scalars['String']>>;
    subscription_contains?: Maybe<Scalars['String']>;
    subscription_contains_nocase?: Maybe<Scalars['String']>;
    subscription_not_contains?: Maybe<Scalars['String']>;
    subscription_not_contains_nocase?: Maybe<Scalars['String']>;
    subscription_starts_with?: Maybe<Scalars['String']>;
    subscription_starts_with_nocase?: Maybe<Scalars['String']>;
    subscription_not_starts_with?: Maybe<Scalars['String']>;
    subscription_not_starts_with_nocase?: Maybe<Scalars['String']>;
    subscription_ends_with?: Maybe<Scalars['String']>;
    subscription_ends_with_nocase?: Maybe<Scalars['String']>;
    subscription_not_ends_with?: Maybe<Scalars['String']>;
    subscription_not_ends_with_nocase?: Maybe<Scalars['String']>;
    subscription_?: Maybe<IndexSubscription_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<SubscriptionRevokedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<SubscriptionRevokedEvent_Filter>>>;
};
export declare enum SubscriptionRevokedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Subscriber = "subscriber",
    Publisher = "publisher",
    IndexId = "indexId",
    UserData = "userData",
    Subscription = "subscription",
    Subscription__id = "subscription__id",
    Subscription__createdAtTimestamp = "subscription__createdAtTimestamp",
    Subscription__createdAtBlockNumber = "subscription__createdAtBlockNumber",
    Subscription__updatedAtTimestamp = "subscription__updatedAtTimestamp",
    Subscription__updatedAtBlockNumber = "subscription__updatedAtBlockNumber",
    Subscription__approved = "subscription__approved",
    Subscription__units = "subscription__units",
    Subscription__totalAmountReceivedUntilUpdatedAt = "subscription__totalAmountReceivedUntilUpdatedAt",
    Subscription__indexValueUntilUpdatedAt = "subscription__indexValueUntilUpdatedAt"
}
export type SubscriptionUnitsUpdatedEvent = Event & {
    __typename?: 'SubscriptionUnitsUpdatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `publisher`
     * addresses[2] = `subscriber`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    /**
     * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
     * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
     */
    subscriber: Scalars['Bytes'];
    /** The creator of the `index`. */
    publisher: Scalars['Bytes'];
    /** An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`. */
    indexId: Scalars['BigInt'];
    units: Scalars['BigInt'];
    userData: Scalars['Bytes'];
    oldUnits: Scalars['BigInt'];
    subscription: IndexSubscription;
};
export type SubscriptionUnitsUpdatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    subscriber?: Maybe<Scalars['Bytes']>;
    subscriber_not?: Maybe<Scalars['Bytes']>;
    subscriber_gt?: Maybe<Scalars['Bytes']>;
    subscriber_lt?: Maybe<Scalars['Bytes']>;
    subscriber_gte?: Maybe<Scalars['Bytes']>;
    subscriber_lte?: Maybe<Scalars['Bytes']>;
    subscriber_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_not_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_contains?: Maybe<Scalars['Bytes']>;
    subscriber_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_gt?: Maybe<Scalars['Bytes']>;
    publisher_lt?: Maybe<Scalars['Bytes']>;
    publisher_gte?: Maybe<Scalars['Bytes']>;
    publisher_lte?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    units?: Maybe<Scalars['BigInt']>;
    units_not?: Maybe<Scalars['BigInt']>;
    units_gt?: Maybe<Scalars['BigInt']>;
    units_lt?: Maybe<Scalars['BigInt']>;
    units_gte?: Maybe<Scalars['BigInt']>;
    units_lte?: Maybe<Scalars['BigInt']>;
    units_in?: Maybe<Array<Scalars['BigInt']>>;
    units_not_in?: Maybe<Array<Scalars['BigInt']>>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_gt?: Maybe<Scalars['Bytes']>;
    userData_lt?: Maybe<Scalars['Bytes']>;
    userData_gte?: Maybe<Scalars['Bytes']>;
    userData_lte?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    oldUnits?: Maybe<Scalars['BigInt']>;
    oldUnits_not?: Maybe<Scalars['BigInt']>;
    oldUnits_gt?: Maybe<Scalars['BigInt']>;
    oldUnits_lt?: Maybe<Scalars['BigInt']>;
    oldUnits_gte?: Maybe<Scalars['BigInt']>;
    oldUnits_lte?: Maybe<Scalars['BigInt']>;
    oldUnits_in?: Maybe<Array<Scalars['BigInt']>>;
    oldUnits_not_in?: Maybe<Array<Scalars['BigInt']>>;
    subscription?: Maybe<Scalars['String']>;
    subscription_not?: Maybe<Scalars['String']>;
    subscription_gt?: Maybe<Scalars['String']>;
    subscription_lt?: Maybe<Scalars['String']>;
    subscription_gte?: Maybe<Scalars['String']>;
    subscription_lte?: Maybe<Scalars['String']>;
    subscription_in?: Maybe<Array<Scalars['String']>>;
    subscription_not_in?: Maybe<Array<Scalars['String']>>;
    subscription_contains?: Maybe<Scalars['String']>;
    subscription_contains_nocase?: Maybe<Scalars['String']>;
    subscription_not_contains?: Maybe<Scalars['String']>;
    subscription_not_contains_nocase?: Maybe<Scalars['String']>;
    subscription_starts_with?: Maybe<Scalars['String']>;
    subscription_starts_with_nocase?: Maybe<Scalars['String']>;
    subscription_not_starts_with?: Maybe<Scalars['String']>;
    subscription_not_starts_with_nocase?: Maybe<Scalars['String']>;
    subscription_ends_with?: Maybe<Scalars['String']>;
    subscription_ends_with_nocase?: Maybe<Scalars['String']>;
    subscription_not_ends_with?: Maybe<Scalars['String']>;
    subscription_not_ends_with_nocase?: Maybe<Scalars['String']>;
    subscription_?: Maybe<IndexSubscription_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<SubscriptionUnitsUpdatedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<SubscriptionUnitsUpdatedEvent_Filter>>>;
};
export declare enum SubscriptionUnitsUpdatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Subscriber = "subscriber",
    Publisher = "publisher",
    IndexId = "indexId",
    Units = "units",
    UserData = "userData",
    OldUnits = "oldUnits",
    Subscription = "subscription",
    Subscription__id = "subscription__id",
    Subscription__createdAtTimestamp = "subscription__createdAtTimestamp",
    Subscription__createdAtBlockNumber = "subscription__createdAtBlockNumber",
    Subscription__updatedAtTimestamp = "subscription__updatedAtTimestamp",
    Subscription__updatedAtBlockNumber = "subscription__updatedAtBlockNumber",
    Subscription__approved = "subscription__approved",
    Subscription__units = "subscription__units",
    Subscription__totalAmountReceivedUntilUpdatedAt = "subscription__totalAmountReceivedUntilUpdatedAt",
    Subscription__indexValueUntilUpdatedAt = "subscription__indexValueUntilUpdatedAt"
}
export type SuperTokenCreatedEvent = Event & {
    __typename?: 'SuperTokenCreatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
};
export type SuperTokenCreatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<SuperTokenCreatedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<SuperTokenCreatedEvent_Filter>>>;
};
export declare enum SuperTokenCreatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token"
}
export type SuperTokenFactoryUpdatedEvent = Event & {
    __typename?: 'SuperTokenFactoryUpdatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    newFactory: Scalars['Bytes'];
};
export type SuperTokenFactoryUpdatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    newFactory?: Maybe<Scalars['Bytes']>;
    newFactory_not?: Maybe<Scalars['Bytes']>;
    newFactory_gt?: Maybe<Scalars['Bytes']>;
    newFactory_lt?: Maybe<Scalars['Bytes']>;
    newFactory_gte?: Maybe<Scalars['Bytes']>;
    newFactory_lte?: Maybe<Scalars['Bytes']>;
    newFactory_in?: Maybe<Array<Scalars['Bytes']>>;
    newFactory_not_in?: Maybe<Array<Scalars['Bytes']>>;
    newFactory_contains?: Maybe<Scalars['Bytes']>;
    newFactory_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<SuperTokenFactoryUpdatedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<SuperTokenFactoryUpdatedEvent_Filter>>>;
};
export declare enum SuperTokenFactoryUpdatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    NewFactory = "newFactory"
}
export type SuperTokenLogicCreatedEvent = Event & {
    __typename?: 'SuperTokenLogicCreatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    tokenLogic: Scalars['Bytes'];
};
export type SuperTokenLogicCreatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    tokenLogic?: Maybe<Scalars['Bytes']>;
    tokenLogic_not?: Maybe<Scalars['Bytes']>;
    tokenLogic_gt?: Maybe<Scalars['Bytes']>;
    tokenLogic_lt?: Maybe<Scalars['Bytes']>;
    tokenLogic_gte?: Maybe<Scalars['Bytes']>;
    tokenLogic_lte?: Maybe<Scalars['Bytes']>;
    tokenLogic_in?: Maybe<Array<Scalars['Bytes']>>;
    tokenLogic_not_in?: Maybe<Array<Scalars['Bytes']>>;
    tokenLogic_contains?: Maybe<Scalars['Bytes']>;
    tokenLogic_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<SuperTokenLogicCreatedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<SuperTokenLogicCreatedEvent_Filter>>>;
};
export declare enum SuperTokenLogicCreatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    TokenLogic = "tokenLogic"
}
export type SuperTokenLogicUpdatedEvent = Event & {
    __typename?: 'SuperTokenLogicUpdatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    code: Scalars['Bytes'];
};
export type SuperTokenLogicUpdatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    code?: Maybe<Scalars['Bytes']>;
    code_not?: Maybe<Scalars['Bytes']>;
    code_gt?: Maybe<Scalars['Bytes']>;
    code_lt?: Maybe<Scalars['Bytes']>;
    code_gte?: Maybe<Scalars['Bytes']>;
    code_lte?: Maybe<Scalars['Bytes']>;
    code_in?: Maybe<Array<Scalars['Bytes']>>;
    code_not_in?: Maybe<Array<Scalars['Bytes']>>;
    code_contains?: Maybe<Scalars['Bytes']>;
    code_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<SuperTokenLogicUpdatedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<SuperTokenLogicUpdatedEvent_Filter>>>;
};
export declare enum SuperTokenLogicUpdatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Code = "code"
}
export type SuperTokenMinimumDepositChangedEvent = Event & {
    __typename?: 'SuperTokenMinimumDepositChangedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** The address of the governance contract the event was emitted from. */
    governanceAddress: Scalars['Bytes'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    host: Scalars['Bytes'];
    superToken: Scalars['Bytes'];
    isKeySet: Scalars['Boolean'];
    minimumDeposit: Scalars['BigInt'];
};
export type SuperTokenMinimumDepositChangedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    governanceAddress?: Maybe<Scalars['Bytes']>;
    governanceAddress_not?: Maybe<Scalars['Bytes']>;
    governanceAddress_gt?: Maybe<Scalars['Bytes']>;
    governanceAddress_lt?: Maybe<Scalars['Bytes']>;
    governanceAddress_gte?: Maybe<Scalars['Bytes']>;
    governanceAddress_lte?: Maybe<Scalars['Bytes']>;
    governanceAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_contains?: Maybe<Scalars['Bytes']>;
    governanceAddress_not_contains?: Maybe<Scalars['Bytes']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    host?: Maybe<Scalars['Bytes']>;
    host_not?: Maybe<Scalars['Bytes']>;
    host_gt?: Maybe<Scalars['Bytes']>;
    host_lt?: Maybe<Scalars['Bytes']>;
    host_gte?: Maybe<Scalars['Bytes']>;
    host_lte?: Maybe<Scalars['Bytes']>;
    host_in?: Maybe<Array<Scalars['Bytes']>>;
    host_not_in?: Maybe<Array<Scalars['Bytes']>>;
    host_contains?: Maybe<Scalars['Bytes']>;
    host_not_contains?: Maybe<Scalars['Bytes']>;
    superToken?: Maybe<Scalars['Bytes']>;
    superToken_not?: Maybe<Scalars['Bytes']>;
    superToken_gt?: Maybe<Scalars['Bytes']>;
    superToken_lt?: Maybe<Scalars['Bytes']>;
    superToken_gte?: Maybe<Scalars['Bytes']>;
    superToken_lte?: Maybe<Scalars['Bytes']>;
    superToken_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_not_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_contains?: Maybe<Scalars['Bytes']>;
    superToken_not_contains?: Maybe<Scalars['Bytes']>;
    isKeySet?: Maybe<Scalars['Boolean']>;
    isKeySet_not?: Maybe<Scalars['Boolean']>;
    isKeySet_in?: Maybe<Array<Scalars['Boolean']>>;
    isKeySet_not_in?: Maybe<Array<Scalars['Boolean']>>;
    minimumDeposit?: Maybe<Scalars['BigInt']>;
    minimumDeposit_not?: Maybe<Scalars['BigInt']>;
    minimumDeposit_gt?: Maybe<Scalars['BigInt']>;
    minimumDeposit_lt?: Maybe<Scalars['BigInt']>;
    minimumDeposit_gte?: Maybe<Scalars['BigInt']>;
    minimumDeposit_lte?: Maybe<Scalars['BigInt']>;
    minimumDeposit_in?: Maybe<Array<Scalars['BigInt']>>;
    minimumDeposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<SuperTokenMinimumDepositChangedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<SuperTokenMinimumDepositChangedEvent_Filter>>>;
};
export declare enum SuperTokenMinimumDepositChangedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    GovernanceAddress = "governanceAddress",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Host = "host",
    SuperToken = "superToken",
    IsKeySet = "isKeySet",
    MinimumDeposit = "minimumDeposit"
}
/** Token: A higher order entity created for super tokens (and underlying tokens) that are "valid" (tokens that have Superfluid's host contract address set as the host). */
export type Token = {
    __typename?: 'Token';
    /** ID: the token address */
    id: Scalars['ID'];
    createdAtTimestamp: Scalars['BigInt'];
    createdAtBlockNumber: Scalars['BigInt'];
    decimals: Scalars['Int'];
    name: Scalars['String'];
    symbol: Scalars['String'];
    isSuperToken: Scalars['Boolean'];
    /** A boolean indicating whether the token is a NativeAssetSuperToken. */
    isNativeAssetSuperToken: Scalars['Boolean'];
    /** A boolean indicating whether the token is a part of our resolver list. */
    isListed: Scalars['Boolean'];
    /** The address of the underlying ERC20 token (zero address for non-ERC20WrapperSuperToken's) */
    underlyingAddress: Scalars['Bytes'];
    /** The underlying ERC20 token for a ERC20WrapperSuperToken otherwise null. */
    underlyingToken?: Maybe<Token>;
    governanceConfig?: Maybe<TokenGovernanceConfig>;
};
export type TokenDowngradedEvent = Event & {
    __typename?: 'TokenDowngradedEvent';
    id: Scalars['ID'];
    account: Account;
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `account`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    amount: Scalars['BigInt'];
};
export type TokenDowngradedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    account?: Maybe<Scalars['String']>;
    account_not?: Maybe<Scalars['String']>;
    account_gt?: Maybe<Scalars['String']>;
    account_lt?: Maybe<Scalars['String']>;
    account_gte?: Maybe<Scalars['String']>;
    account_lte?: Maybe<Scalars['String']>;
    account_in?: Maybe<Array<Scalars['String']>>;
    account_not_in?: Maybe<Array<Scalars['String']>>;
    account_contains?: Maybe<Scalars['String']>;
    account_contains_nocase?: Maybe<Scalars['String']>;
    account_not_contains?: Maybe<Scalars['String']>;
    account_not_contains_nocase?: Maybe<Scalars['String']>;
    account_starts_with?: Maybe<Scalars['String']>;
    account_starts_with_nocase?: Maybe<Scalars['String']>;
    account_not_starts_with?: Maybe<Scalars['String']>;
    account_not_starts_with_nocase?: Maybe<Scalars['String']>;
    account_ends_with?: Maybe<Scalars['String']>;
    account_ends_with_nocase?: Maybe<Scalars['String']>;
    account_not_ends_with?: Maybe<Scalars['String']>;
    account_not_ends_with_nocase?: Maybe<Scalars['String']>;
    account_?: Maybe<Account_Filter>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    amount?: Maybe<Scalars['BigInt']>;
    amount_not?: Maybe<Scalars['BigInt']>;
    amount_gt?: Maybe<Scalars['BigInt']>;
    amount_lt?: Maybe<Scalars['BigInt']>;
    amount_gte?: Maybe<Scalars['BigInt']>;
    amount_lte?: Maybe<Scalars['BigInt']>;
    amount_in?: Maybe<Array<Scalars['BigInt']>>;
    amount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<TokenDowngradedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<TokenDowngradedEvent_Filter>>>;
};
export declare enum TokenDowngradedEvent_OrderBy {
    Id = "id",
    Account = "account",
    Account__id = "account__id",
    Account__createdAtTimestamp = "account__createdAtTimestamp",
    Account__createdAtBlockNumber = "account__createdAtBlockNumber",
    Account__updatedAtTimestamp = "account__updatedAtTimestamp",
    Account__updatedAtBlockNumber = "account__updatedAtBlockNumber",
    Account__isSuperApp = "account__isSuperApp",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Amount = "amount"
}
/**
 * TokenGovernanceConfig: A higher order entity that represents the governance configs for a token.
 * If `id` is `address(0)`, it will be used as the default config.
 */
export type TokenGovernanceConfig = {
    __typename?: 'TokenGovernanceConfig';
    /**
     * id is the address of the SuperToken
     * NOTE: the zero address is reserved for the default config for all tokens with unset configs.
     */
    id: Scalars['ID'];
    createdAtTimestamp: Scalars['BigInt'];
    createdAtBlockNumber: Scalars['BigInt'];
    updatedAtTimestamp: Scalars['BigInt'];
    updatedAtBlockNumber: Scalars['BigInt'];
    /** If true, `id` is `address(0)` and this is the default config for all tokens with unset configs. */
    isDefault: Scalars['Boolean'];
    /** The (default or token-specific) address that receives liquidation rewards for a token prior to 3Ps and the TOGA address after 3Ps. */
    rewardAddress?: Maybe<Scalars['Bytes']>;
    /**
     * The (default or token-specific) liquidation period (buffer amount required for a token).
     * This field can be used to calculate the liquidation buffer (or deposit) amount for a token: `liquidationBufferAmount = liquidationPeriod * flowRate`.
     * Note that if `minimumDeposit` is set, the liquidation buffer amount will be the greater of the two values.
     */
    liquidationPeriod?: Maybe<Scalars['BigInt']>;
    /** The (default or token-specific) patrician period, the patrician period is the window in which a patrician receives all rewards for a liquidation, no matter the liquidating account. */
    patricianPeriod?: Maybe<Scalars['BigInt']>;
    /** The (default or token-specific) minimum deposit amount. */
    minimumDeposit?: Maybe<Scalars['BigInt']>;
    /** A reverse lookup to the token it is associated with and null if it is the default config. */
    token?: Maybe<Token>;
};
export type TokenGovernanceConfig_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    createdAtTimestamp?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    isDefault?: Maybe<Scalars['Boolean']>;
    isDefault_not?: Maybe<Scalars['Boolean']>;
    isDefault_in?: Maybe<Array<Scalars['Boolean']>>;
    isDefault_not_in?: Maybe<Array<Scalars['Boolean']>>;
    rewardAddress?: Maybe<Scalars['Bytes']>;
    rewardAddress_not?: Maybe<Scalars['Bytes']>;
    rewardAddress_gt?: Maybe<Scalars['Bytes']>;
    rewardAddress_lt?: Maybe<Scalars['Bytes']>;
    rewardAddress_gte?: Maybe<Scalars['Bytes']>;
    rewardAddress_lte?: Maybe<Scalars['Bytes']>;
    rewardAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    rewardAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    rewardAddress_contains?: Maybe<Scalars['Bytes']>;
    rewardAddress_not_contains?: Maybe<Scalars['Bytes']>;
    liquidationPeriod?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_not?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_gt?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_lt?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_gte?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_lte?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_in?: Maybe<Array<Scalars['BigInt']>>;
    liquidationPeriod_not_in?: Maybe<Array<Scalars['BigInt']>>;
    patricianPeriod?: Maybe<Scalars['BigInt']>;
    patricianPeriod_not?: Maybe<Scalars['BigInt']>;
    patricianPeriod_gt?: Maybe<Scalars['BigInt']>;
    patricianPeriod_lt?: Maybe<Scalars['BigInt']>;
    patricianPeriod_gte?: Maybe<Scalars['BigInt']>;
    patricianPeriod_lte?: Maybe<Scalars['BigInt']>;
    patricianPeriod_in?: Maybe<Array<Scalars['BigInt']>>;
    patricianPeriod_not_in?: Maybe<Array<Scalars['BigInt']>>;
    minimumDeposit?: Maybe<Scalars['BigInt']>;
    minimumDeposit_not?: Maybe<Scalars['BigInt']>;
    minimumDeposit_gt?: Maybe<Scalars['BigInt']>;
    minimumDeposit_lt?: Maybe<Scalars['BigInt']>;
    minimumDeposit_gte?: Maybe<Scalars['BigInt']>;
    minimumDeposit_lte?: Maybe<Scalars['BigInt']>;
    minimumDeposit_in?: Maybe<Array<Scalars['BigInt']>>;
    minimumDeposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['String']>;
    token_not?: Maybe<Scalars['String']>;
    token_gt?: Maybe<Scalars['String']>;
    token_lt?: Maybe<Scalars['String']>;
    token_gte?: Maybe<Scalars['String']>;
    token_lte?: Maybe<Scalars['String']>;
    token_in?: Maybe<Array<Scalars['String']>>;
    token_not_in?: Maybe<Array<Scalars['String']>>;
    token_contains?: Maybe<Scalars['String']>;
    token_contains_nocase?: Maybe<Scalars['String']>;
    token_not_contains?: Maybe<Scalars['String']>;
    token_not_contains_nocase?: Maybe<Scalars['String']>;
    token_starts_with?: Maybe<Scalars['String']>;
    token_starts_with_nocase?: Maybe<Scalars['String']>;
    token_not_starts_with?: Maybe<Scalars['String']>;
    token_not_starts_with_nocase?: Maybe<Scalars['String']>;
    token_ends_with?: Maybe<Scalars['String']>;
    token_ends_with_nocase?: Maybe<Scalars['String']>;
    token_not_ends_with?: Maybe<Scalars['String']>;
    token_not_ends_with_nocase?: Maybe<Scalars['String']>;
    token_?: Maybe<Token_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<TokenGovernanceConfig_Filter>>>;
    or?: Maybe<Array<Maybe<TokenGovernanceConfig_Filter>>>;
};
export declare enum TokenGovernanceConfig_OrderBy {
    Id = "id",
    CreatedAtTimestamp = "createdAtTimestamp",
    CreatedAtBlockNumber = "createdAtBlockNumber",
    UpdatedAtTimestamp = "updatedAtTimestamp",
    UpdatedAtBlockNumber = "updatedAtBlockNumber",
    IsDefault = "isDefault",
    RewardAddress = "rewardAddress",
    LiquidationPeriod = "liquidationPeriod",
    PatricianPeriod = "patricianPeriod",
    MinimumDeposit = "minimumDeposit",
    Token = "token",
    Token__id = "token__id",
    Token__createdAtTimestamp = "token__createdAtTimestamp",
    Token__createdAtBlockNumber = "token__createdAtBlockNumber",
    Token__decimals = "token__decimals",
    Token__name = "token__name",
    Token__symbol = "token__symbol",
    Token__isSuperToken = "token__isSuperToken",
    Token__isNativeAssetSuperToken = "token__isNativeAssetSuperToken",
    Token__isListed = "token__isListed",
    Token__underlyingAddress = "token__underlyingAddress"
}
/** TokenStatistic: An aggregate entity which contains aggregate data for `token`. */
export type TokenStatistic = {
    __typename?: 'TokenStatistic';
    /** id: `token` (superToken) address */
    id: Scalars['ID'];
    updatedAtTimestamp: Scalars['BigInt'];
    updatedAtBlockNumber: Scalars['BigInt'];
    /** The total number of currently active `token` streams. */
    totalNumberOfActiveStreams: Scalars['Int'];
    /** The count of closed streams for `token`. */
    totalNumberOfClosedStreams: Scalars['Int'];
    /** The total number of Indexes created with `token`. */
    totalNumberOfIndexes: Scalars['Int'];
    /** The total number of "active" (has greater than 0 units and has distributed it at least once) Indexes created with `token`. */
    totalNumberOfActiveIndexes: Scalars['Int'];
    /** The number of subscriptions which have units allocated to them created with Indexes that distribute `token`. */
    totalSubscriptionsWithUnits: Scalars['Int'];
    /** Counts all approved subscriptions whether or not they have units. */
    totalApprovedSubscriptions: Scalars['Int'];
    /** The total deposit held by the CFA agreement for this particular `token`. */
    totalDeposit: Scalars['BigInt'];
    /** The total outflow rate of the `token` (how much value is being moved). */
    totalOutflowRate: Scalars['BigInt'];
    /** The all-time total amount streamed (outflows) until the `updatedAtTimestamp`/`updatedAtBlock`. */
    totalAmountStreamedUntilUpdatedAt: Scalars['BigInt'];
    /** The all-time total amount transferred until the `updatedAtTimestamp`/`updatedAtBlock`. */
    totalAmountTransferredUntilUpdatedAt: Scalars['BigInt'];
    /** The all-time total amount distributed until the `updatedAtTimestamp`/`updatedAtBlock`. */
    totalAmountDistributedUntilUpdatedAt: Scalars['BigInt'];
    /** The total supply of the token - this is impacted by users upgrading/downgrading their tokens. */
    totalSupply: Scalars['BigInt'];
    token: Token;
    tokenStatisticLogs: Array<TokenStatisticLog>;
};
/** TokenStatistic: An aggregate entity which contains aggregate data for `token`. */
export type TokenStatisticTokenStatisticLogsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenStatisticLog_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenStatisticLog_Filter>;
};
/** TokenStatisticLog: Historical entries of `TokenStatistic` updates. */
export type TokenStatisticLog = {
    __typename?: 'TokenStatisticLog';
    id: Scalars['ID'];
    timestamp: Scalars['BigInt'];
    blockNumber: Scalars['BigInt'];
    transactionHash: Scalars['Bytes'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    triggeredByEventName: Scalars['String'];
    /** The total number of currently active `token` streams. */
    totalNumberOfActiveStreams: Scalars['Int'];
    /** The count of closed streams for `token`. */
    totalNumberOfClosedStreams: Scalars['Int'];
    /** The total number of Indexes created with `token`. */
    totalNumberOfIndexes: Scalars['Int'];
    /** The total number of "active" (has greater than 0 units and has distributed it at least once) Indexes created with `token`. */
    totalNumberOfActiveIndexes: Scalars['Int'];
    /** The number of subscriptions which have units allocated to them created with Indexes that distribute `token`. */
    totalSubscriptionsWithUnits: Scalars['Int'];
    /** Counts all approved subscriptions whether or not they have units. */
    totalApprovedSubscriptions: Scalars['Int'];
    /** The total deposit held by the CFA agreement for this particular `token`. */
    totalDeposit: Scalars['BigInt'];
    /** The total outflow rate of the `token` (how much value is being moved). */
    totalOutflowRate: Scalars['BigInt'];
    /** The all-time total amount of `token` streamed (outflows) until the `timestamp`/`block`. */
    totalAmountStreamed: Scalars['BigInt'];
    /** The all-time total amount of `token` transferred until the `timestamp`/`block`. */
    totalAmountTransferred: Scalars['BigInt'];
    /** The all-time total amount of `token` distributed until the `timestamp`/`block`. */
    totalAmountDistributed: Scalars['BigInt'];
    /** The total supply of the token - this is impacted by users upgrading/downgrading their tokens. */
    totalSupply: Scalars['BigInt'];
    token: Token;
    tokenStatistic: TokenStatistic;
};
export type TokenStatisticLog_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    triggeredByEventName?: Maybe<Scalars['String']>;
    triggeredByEventName_not?: Maybe<Scalars['String']>;
    triggeredByEventName_gt?: Maybe<Scalars['String']>;
    triggeredByEventName_lt?: Maybe<Scalars['String']>;
    triggeredByEventName_gte?: Maybe<Scalars['String']>;
    triggeredByEventName_lte?: Maybe<Scalars['String']>;
    triggeredByEventName_in?: Maybe<Array<Scalars['String']>>;
    triggeredByEventName_not_in?: Maybe<Array<Scalars['String']>>;
    triggeredByEventName_contains?: Maybe<Scalars['String']>;
    triggeredByEventName_contains_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_not_contains?: Maybe<Scalars['String']>;
    triggeredByEventName_not_contains_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_starts_with?: Maybe<Scalars['String']>;
    triggeredByEventName_starts_with_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_not_starts_with?: Maybe<Scalars['String']>;
    triggeredByEventName_not_starts_with_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_ends_with?: Maybe<Scalars['String']>;
    triggeredByEventName_ends_with_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_not_ends_with?: Maybe<Scalars['String']>;
    triggeredByEventName_not_ends_with_nocase?: Maybe<Scalars['String']>;
    totalNumberOfActiveStreams?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_not?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_gt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_lt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_gte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_lte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfActiveStreams_not_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfClosedStreams?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_not?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_gt?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_lt?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_gte?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_lte?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfClosedStreams_not_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfIndexes?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_not?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_gt?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_lt?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_gte?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_lte?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfIndexes_not_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfActiveIndexes?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_not?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_gt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_lt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_gte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_lte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfActiveIndexes_not_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_not?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits_not_in?: Maybe<Array<Scalars['Int']>>;
    totalApprovedSubscriptions?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_not?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_gt?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_lt?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_gte?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_lte?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_in?: Maybe<Array<Scalars['Int']>>;
    totalApprovedSubscriptions_not_in?: Maybe<Array<Scalars['Int']>>;
    totalDeposit?: Maybe<Scalars['BigInt']>;
    totalDeposit_not?: Maybe<Scalars['BigInt']>;
    totalDeposit_gt?: Maybe<Scalars['BigInt']>;
    totalDeposit_lt?: Maybe<Scalars['BigInt']>;
    totalDeposit_gte?: Maybe<Scalars['BigInt']>;
    totalDeposit_lte?: Maybe<Scalars['BigInt']>;
    totalDeposit_in?: Maybe<Array<Scalars['BigInt']>>;
    totalDeposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalOutflowRate?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_not?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_gt?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_lt?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_gte?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_lte?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalOutflowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamed?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountTransferred?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_not?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_gt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_lt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_gte?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_lte?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountTransferred_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountDistributed?: Maybe<Scalars['BigInt']>;
    totalAmountDistributed_not?: Maybe<Scalars['BigInt']>;
    totalAmountDistributed_gt?: Maybe<Scalars['BigInt']>;
    totalAmountDistributed_lt?: Maybe<Scalars['BigInt']>;
    totalAmountDistributed_gte?: Maybe<Scalars['BigInt']>;
    totalAmountDistributed_lte?: Maybe<Scalars['BigInt']>;
    totalAmountDistributed_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountDistributed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalSupply?: Maybe<Scalars['BigInt']>;
    totalSupply_not?: Maybe<Scalars['BigInt']>;
    totalSupply_gt?: Maybe<Scalars['BigInt']>;
    totalSupply_lt?: Maybe<Scalars['BigInt']>;
    totalSupply_gte?: Maybe<Scalars['BigInt']>;
    totalSupply_lte?: Maybe<Scalars['BigInt']>;
    totalSupply_in?: Maybe<Array<Scalars['BigInt']>>;
    totalSupply_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['String']>;
    token_not?: Maybe<Scalars['String']>;
    token_gt?: Maybe<Scalars['String']>;
    token_lt?: Maybe<Scalars['String']>;
    token_gte?: Maybe<Scalars['String']>;
    token_lte?: Maybe<Scalars['String']>;
    token_in?: Maybe<Array<Scalars['String']>>;
    token_not_in?: Maybe<Array<Scalars['String']>>;
    token_contains?: Maybe<Scalars['String']>;
    token_contains_nocase?: Maybe<Scalars['String']>;
    token_not_contains?: Maybe<Scalars['String']>;
    token_not_contains_nocase?: Maybe<Scalars['String']>;
    token_starts_with?: Maybe<Scalars['String']>;
    token_starts_with_nocase?: Maybe<Scalars['String']>;
    token_not_starts_with?: Maybe<Scalars['String']>;
    token_not_starts_with_nocase?: Maybe<Scalars['String']>;
    token_ends_with?: Maybe<Scalars['String']>;
    token_ends_with_nocase?: Maybe<Scalars['String']>;
    token_not_ends_with?: Maybe<Scalars['String']>;
    token_not_ends_with_nocase?: Maybe<Scalars['String']>;
    token_?: Maybe<Token_Filter>;
    tokenStatistic?: Maybe<Scalars['String']>;
    tokenStatistic_not?: Maybe<Scalars['String']>;
    tokenStatistic_gt?: Maybe<Scalars['String']>;
    tokenStatistic_lt?: Maybe<Scalars['String']>;
    tokenStatistic_gte?: Maybe<Scalars['String']>;
    tokenStatistic_lte?: Maybe<Scalars['String']>;
    tokenStatistic_in?: Maybe<Array<Scalars['String']>>;
    tokenStatistic_not_in?: Maybe<Array<Scalars['String']>>;
    tokenStatistic_contains?: Maybe<Scalars['String']>;
    tokenStatistic_contains_nocase?: Maybe<Scalars['String']>;
    tokenStatistic_not_contains?: Maybe<Scalars['String']>;
    tokenStatistic_not_contains_nocase?: Maybe<Scalars['String']>;
    tokenStatistic_starts_with?: Maybe<Scalars['String']>;
    tokenStatistic_starts_with_nocase?: Maybe<Scalars['String']>;
    tokenStatistic_not_starts_with?: Maybe<Scalars['String']>;
    tokenStatistic_not_starts_with_nocase?: Maybe<Scalars['String']>;
    tokenStatistic_ends_with?: Maybe<Scalars['String']>;
    tokenStatistic_ends_with_nocase?: Maybe<Scalars['String']>;
    tokenStatistic_not_ends_with?: Maybe<Scalars['String']>;
    tokenStatistic_not_ends_with_nocase?: Maybe<Scalars['String']>;
    tokenStatistic_?: Maybe<TokenStatistic_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<TokenStatisticLog_Filter>>>;
    or?: Maybe<Array<Maybe<TokenStatisticLog_Filter>>>;
};
export declare enum TokenStatisticLog_OrderBy {
    Id = "id",
    Timestamp = "timestamp",
    BlockNumber = "blockNumber",
    TransactionHash = "transactionHash",
    LogIndex = "logIndex",
    Order = "order",
    TriggeredByEventName = "triggeredByEventName",
    TotalNumberOfActiveStreams = "totalNumberOfActiveStreams",
    TotalNumberOfClosedStreams = "totalNumberOfClosedStreams",
    TotalNumberOfIndexes = "totalNumberOfIndexes",
    TotalNumberOfActiveIndexes = "totalNumberOfActiveIndexes",
    TotalSubscriptionsWithUnits = "totalSubscriptionsWithUnits",
    TotalApprovedSubscriptions = "totalApprovedSubscriptions",
    TotalDeposit = "totalDeposit",
    TotalOutflowRate = "totalOutflowRate",
    TotalAmountStreamed = "totalAmountStreamed",
    TotalAmountTransferred = "totalAmountTransferred",
    TotalAmountDistributed = "totalAmountDistributed",
    TotalSupply = "totalSupply",
    Token = "token",
    Token__id = "token__id",
    Token__createdAtTimestamp = "token__createdAtTimestamp",
    Token__createdAtBlockNumber = "token__createdAtBlockNumber",
    Token__decimals = "token__decimals",
    Token__name = "token__name",
    Token__symbol = "token__symbol",
    Token__isSuperToken = "token__isSuperToken",
    Token__isNativeAssetSuperToken = "token__isNativeAssetSuperToken",
    Token__isListed = "token__isListed",
    Token__underlyingAddress = "token__underlyingAddress",
    TokenStatistic = "tokenStatistic",
    TokenStatistic__id = "tokenStatistic__id",
    TokenStatistic__updatedAtTimestamp = "tokenStatistic__updatedAtTimestamp",
    TokenStatistic__updatedAtBlockNumber = "tokenStatistic__updatedAtBlockNumber",
    TokenStatistic__totalNumberOfActiveStreams = "tokenStatistic__totalNumberOfActiveStreams",
    TokenStatistic__totalNumberOfClosedStreams = "tokenStatistic__totalNumberOfClosedStreams",
    TokenStatistic__totalNumberOfIndexes = "tokenStatistic__totalNumberOfIndexes",
    TokenStatistic__totalNumberOfActiveIndexes = "tokenStatistic__totalNumberOfActiveIndexes",
    TokenStatistic__totalSubscriptionsWithUnits = "tokenStatistic__totalSubscriptionsWithUnits",
    TokenStatistic__totalApprovedSubscriptions = "tokenStatistic__totalApprovedSubscriptions",
    TokenStatistic__totalDeposit = "tokenStatistic__totalDeposit",
    TokenStatistic__totalOutflowRate = "tokenStatistic__totalOutflowRate",
    TokenStatistic__totalAmountStreamedUntilUpdatedAt = "tokenStatistic__totalAmountStreamedUntilUpdatedAt",
    TokenStatistic__totalAmountTransferredUntilUpdatedAt = "tokenStatistic__totalAmountTransferredUntilUpdatedAt",
    TokenStatistic__totalAmountDistributedUntilUpdatedAt = "tokenStatistic__totalAmountDistributedUntilUpdatedAt",
    TokenStatistic__totalSupply = "tokenStatistic__totalSupply"
}
export type TokenStatistic_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    updatedAtTimestamp?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalNumberOfActiveStreams?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_not?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_gt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_lt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_gte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_lte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfActiveStreams_not_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfClosedStreams?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_not?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_gt?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_lt?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_gte?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_lte?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfClosedStreams_not_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfIndexes?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_not?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_gt?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_lt?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_gte?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_lte?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfIndexes_not_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfActiveIndexes?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_not?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_gt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_lt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_gte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_lte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfActiveIndexes_not_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_not?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits_not_in?: Maybe<Array<Scalars['Int']>>;
    totalApprovedSubscriptions?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_not?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_gt?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_lt?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_gte?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_lte?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_in?: Maybe<Array<Scalars['Int']>>;
    totalApprovedSubscriptions_not_in?: Maybe<Array<Scalars['Int']>>;
    totalDeposit?: Maybe<Scalars['BigInt']>;
    totalDeposit_not?: Maybe<Scalars['BigInt']>;
    totalDeposit_gt?: Maybe<Scalars['BigInt']>;
    totalDeposit_lt?: Maybe<Scalars['BigInt']>;
    totalDeposit_gte?: Maybe<Scalars['BigInt']>;
    totalDeposit_lte?: Maybe<Scalars['BigInt']>;
    totalDeposit_in?: Maybe<Array<Scalars['BigInt']>>;
    totalDeposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalOutflowRate?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_not?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_gt?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_lt?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_gte?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_lte?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalOutflowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountTransferredUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountTransferredUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountDistributedUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountDistributedUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalSupply?: Maybe<Scalars['BigInt']>;
    totalSupply_not?: Maybe<Scalars['BigInt']>;
    totalSupply_gt?: Maybe<Scalars['BigInt']>;
    totalSupply_lt?: Maybe<Scalars['BigInt']>;
    totalSupply_gte?: Maybe<Scalars['BigInt']>;
    totalSupply_lte?: Maybe<Scalars['BigInt']>;
    totalSupply_in?: Maybe<Array<Scalars['BigInt']>>;
    totalSupply_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['String']>;
    token_not?: Maybe<Scalars['String']>;
    token_gt?: Maybe<Scalars['String']>;
    token_lt?: Maybe<Scalars['String']>;
    token_gte?: Maybe<Scalars['String']>;
    token_lte?: Maybe<Scalars['String']>;
    token_in?: Maybe<Array<Scalars['String']>>;
    token_not_in?: Maybe<Array<Scalars['String']>>;
    token_contains?: Maybe<Scalars['String']>;
    token_contains_nocase?: Maybe<Scalars['String']>;
    token_not_contains?: Maybe<Scalars['String']>;
    token_not_contains_nocase?: Maybe<Scalars['String']>;
    token_starts_with?: Maybe<Scalars['String']>;
    token_starts_with_nocase?: Maybe<Scalars['String']>;
    token_not_starts_with?: Maybe<Scalars['String']>;
    token_not_starts_with_nocase?: Maybe<Scalars['String']>;
    token_ends_with?: Maybe<Scalars['String']>;
    token_ends_with_nocase?: Maybe<Scalars['String']>;
    token_not_ends_with?: Maybe<Scalars['String']>;
    token_not_ends_with_nocase?: Maybe<Scalars['String']>;
    token_?: Maybe<Token_Filter>;
    tokenStatisticLogs_?: Maybe<TokenStatisticLog_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<TokenStatistic_Filter>>>;
    or?: Maybe<Array<Maybe<TokenStatistic_Filter>>>;
};
export declare enum TokenStatistic_OrderBy {
    Id = "id",
    UpdatedAtTimestamp = "updatedAtTimestamp",
    UpdatedAtBlockNumber = "updatedAtBlockNumber",
    TotalNumberOfActiveStreams = "totalNumberOfActiveStreams",
    TotalNumberOfClosedStreams = "totalNumberOfClosedStreams",
    TotalNumberOfIndexes = "totalNumberOfIndexes",
    TotalNumberOfActiveIndexes = "totalNumberOfActiveIndexes",
    TotalSubscriptionsWithUnits = "totalSubscriptionsWithUnits",
    TotalApprovedSubscriptions = "totalApprovedSubscriptions",
    TotalDeposit = "totalDeposit",
    TotalOutflowRate = "totalOutflowRate",
    TotalAmountStreamedUntilUpdatedAt = "totalAmountStreamedUntilUpdatedAt",
    TotalAmountTransferredUntilUpdatedAt = "totalAmountTransferredUntilUpdatedAt",
    TotalAmountDistributedUntilUpdatedAt = "totalAmountDistributedUntilUpdatedAt",
    TotalSupply = "totalSupply",
    Token = "token",
    Token__id = "token__id",
    Token__createdAtTimestamp = "token__createdAtTimestamp",
    Token__createdAtBlockNumber = "token__createdAtBlockNumber",
    Token__decimals = "token__decimals",
    Token__name = "token__name",
    Token__symbol = "token__symbol",
    Token__isSuperToken = "token__isSuperToken",
    Token__isNativeAssetSuperToken = "token__isNativeAssetSuperToken",
    Token__isListed = "token__isListed",
    Token__underlyingAddress = "token__underlyingAddress",
    TokenStatisticLogs = "tokenStatisticLogs"
}
export type TokenUpgradedEvent = Event & {
    __typename?: 'TokenUpgradedEvent';
    id: Scalars['ID'];
    account: Account;
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `account`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    amount: Scalars['BigInt'];
};
export type TokenUpgradedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    account?: Maybe<Scalars['String']>;
    account_not?: Maybe<Scalars['String']>;
    account_gt?: Maybe<Scalars['String']>;
    account_lt?: Maybe<Scalars['String']>;
    account_gte?: Maybe<Scalars['String']>;
    account_lte?: Maybe<Scalars['String']>;
    account_in?: Maybe<Array<Scalars['String']>>;
    account_not_in?: Maybe<Array<Scalars['String']>>;
    account_contains?: Maybe<Scalars['String']>;
    account_contains_nocase?: Maybe<Scalars['String']>;
    account_not_contains?: Maybe<Scalars['String']>;
    account_not_contains_nocase?: Maybe<Scalars['String']>;
    account_starts_with?: Maybe<Scalars['String']>;
    account_starts_with_nocase?: Maybe<Scalars['String']>;
    account_not_starts_with?: Maybe<Scalars['String']>;
    account_not_starts_with_nocase?: Maybe<Scalars['String']>;
    account_ends_with?: Maybe<Scalars['String']>;
    account_ends_with_nocase?: Maybe<Scalars['String']>;
    account_not_ends_with?: Maybe<Scalars['String']>;
    account_not_ends_with_nocase?: Maybe<Scalars['String']>;
    account_?: Maybe<Account_Filter>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    amount?: Maybe<Scalars['BigInt']>;
    amount_not?: Maybe<Scalars['BigInt']>;
    amount_gt?: Maybe<Scalars['BigInt']>;
    amount_lt?: Maybe<Scalars['BigInt']>;
    amount_gte?: Maybe<Scalars['BigInt']>;
    amount_lte?: Maybe<Scalars['BigInt']>;
    amount_in?: Maybe<Array<Scalars['BigInt']>>;
    amount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<TokenUpgradedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<TokenUpgradedEvent_Filter>>>;
};
export declare enum TokenUpgradedEvent_OrderBy {
    Id = "id",
    Account = "account",
    Account__id = "account__id",
    Account__createdAtTimestamp = "account__createdAtTimestamp",
    Account__createdAtBlockNumber = "account__createdAtBlockNumber",
    Account__updatedAtTimestamp = "account__updatedAtTimestamp",
    Account__updatedAtBlockNumber = "account__updatedAtBlockNumber",
    Account__isSuperApp = "account__isSuperApp",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Amount = "amount"
}
export type Token_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    createdAtTimestamp?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    decimals?: Maybe<Scalars['Int']>;
    decimals_not?: Maybe<Scalars['Int']>;
    decimals_gt?: Maybe<Scalars['Int']>;
    decimals_lt?: Maybe<Scalars['Int']>;
    decimals_gte?: Maybe<Scalars['Int']>;
    decimals_lte?: Maybe<Scalars['Int']>;
    decimals_in?: Maybe<Array<Scalars['Int']>>;
    decimals_not_in?: Maybe<Array<Scalars['Int']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    symbol?: Maybe<Scalars['String']>;
    symbol_not?: Maybe<Scalars['String']>;
    symbol_gt?: Maybe<Scalars['String']>;
    symbol_lt?: Maybe<Scalars['String']>;
    symbol_gte?: Maybe<Scalars['String']>;
    symbol_lte?: Maybe<Scalars['String']>;
    symbol_in?: Maybe<Array<Scalars['String']>>;
    symbol_not_in?: Maybe<Array<Scalars['String']>>;
    symbol_contains?: Maybe<Scalars['String']>;
    symbol_contains_nocase?: Maybe<Scalars['String']>;
    symbol_not_contains?: Maybe<Scalars['String']>;
    symbol_not_contains_nocase?: Maybe<Scalars['String']>;
    symbol_starts_with?: Maybe<Scalars['String']>;
    symbol_starts_with_nocase?: Maybe<Scalars['String']>;
    symbol_not_starts_with?: Maybe<Scalars['String']>;
    symbol_not_starts_with_nocase?: Maybe<Scalars['String']>;
    symbol_ends_with?: Maybe<Scalars['String']>;
    symbol_ends_with_nocase?: Maybe<Scalars['String']>;
    symbol_not_ends_with?: Maybe<Scalars['String']>;
    symbol_not_ends_with_nocase?: Maybe<Scalars['String']>;
    isSuperToken?: Maybe<Scalars['Boolean']>;
    isSuperToken_not?: Maybe<Scalars['Boolean']>;
    isSuperToken_in?: Maybe<Array<Scalars['Boolean']>>;
    isSuperToken_not_in?: Maybe<Array<Scalars['Boolean']>>;
    isNativeAssetSuperToken?: Maybe<Scalars['Boolean']>;
    isNativeAssetSuperToken_not?: Maybe<Scalars['Boolean']>;
    isNativeAssetSuperToken_in?: Maybe<Array<Scalars['Boolean']>>;
    isNativeAssetSuperToken_not_in?: Maybe<Array<Scalars['Boolean']>>;
    isListed?: Maybe<Scalars['Boolean']>;
    isListed_not?: Maybe<Scalars['Boolean']>;
    isListed_in?: Maybe<Array<Scalars['Boolean']>>;
    isListed_not_in?: Maybe<Array<Scalars['Boolean']>>;
    underlyingAddress?: Maybe<Scalars['Bytes']>;
    underlyingAddress_not?: Maybe<Scalars['Bytes']>;
    underlyingAddress_gt?: Maybe<Scalars['Bytes']>;
    underlyingAddress_lt?: Maybe<Scalars['Bytes']>;
    underlyingAddress_gte?: Maybe<Scalars['Bytes']>;
    underlyingAddress_lte?: Maybe<Scalars['Bytes']>;
    underlyingAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    underlyingAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    underlyingAddress_contains?: Maybe<Scalars['Bytes']>;
    underlyingAddress_not_contains?: Maybe<Scalars['Bytes']>;
    underlyingToken?: Maybe<Scalars['String']>;
    underlyingToken_not?: Maybe<Scalars['String']>;
    underlyingToken_gt?: Maybe<Scalars['String']>;
    underlyingToken_lt?: Maybe<Scalars['String']>;
    underlyingToken_gte?: Maybe<Scalars['String']>;
    underlyingToken_lte?: Maybe<Scalars['String']>;
    underlyingToken_in?: Maybe<Array<Scalars['String']>>;
    underlyingToken_not_in?: Maybe<Array<Scalars['String']>>;
    underlyingToken_contains?: Maybe<Scalars['String']>;
    underlyingToken_contains_nocase?: Maybe<Scalars['String']>;
    underlyingToken_not_contains?: Maybe<Scalars['String']>;
    underlyingToken_not_contains_nocase?: Maybe<Scalars['String']>;
    underlyingToken_starts_with?: Maybe<Scalars['String']>;
    underlyingToken_starts_with_nocase?: Maybe<Scalars['String']>;
    underlyingToken_not_starts_with?: Maybe<Scalars['String']>;
    underlyingToken_not_starts_with_nocase?: Maybe<Scalars['String']>;
    underlyingToken_ends_with?: Maybe<Scalars['String']>;
    underlyingToken_ends_with_nocase?: Maybe<Scalars['String']>;
    underlyingToken_not_ends_with?: Maybe<Scalars['String']>;
    underlyingToken_not_ends_with_nocase?: Maybe<Scalars['String']>;
    underlyingToken_?: Maybe<Token_Filter>;
    governanceConfig?: Maybe<Scalars['String']>;
    governanceConfig_not?: Maybe<Scalars['String']>;
    governanceConfig_gt?: Maybe<Scalars['String']>;
    governanceConfig_lt?: Maybe<Scalars['String']>;
    governanceConfig_gte?: Maybe<Scalars['String']>;
    governanceConfig_lte?: Maybe<Scalars['String']>;
    governanceConfig_in?: Maybe<Array<Scalars['String']>>;
    governanceConfig_not_in?: Maybe<Array<Scalars['String']>>;
    governanceConfig_contains?: Maybe<Scalars['String']>;
    governanceConfig_contains_nocase?: Maybe<Scalars['String']>;
    governanceConfig_not_contains?: Maybe<Scalars['String']>;
    governanceConfig_not_contains_nocase?: Maybe<Scalars['String']>;
    governanceConfig_starts_with?: Maybe<Scalars['String']>;
    governanceConfig_starts_with_nocase?: Maybe<Scalars['String']>;
    governanceConfig_not_starts_with?: Maybe<Scalars['String']>;
    governanceConfig_not_starts_with_nocase?: Maybe<Scalars['String']>;
    governanceConfig_ends_with?: Maybe<Scalars['String']>;
    governanceConfig_ends_with_nocase?: Maybe<Scalars['String']>;
    governanceConfig_not_ends_with?: Maybe<Scalars['String']>;
    governanceConfig_not_ends_with_nocase?: Maybe<Scalars['String']>;
    governanceConfig_?: Maybe<TokenGovernanceConfig_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<Token_Filter>>>;
    or?: Maybe<Array<Maybe<Token_Filter>>>;
};
export declare enum Token_OrderBy {
    Id = "id",
    CreatedAtTimestamp = "createdAtTimestamp",
    CreatedAtBlockNumber = "createdAtBlockNumber",
    Decimals = "decimals",
    Name = "name",
    Symbol = "symbol",
    IsSuperToken = "isSuperToken",
    IsNativeAssetSuperToken = "isNativeAssetSuperToken",
    IsListed = "isListed",
    UnderlyingAddress = "underlyingAddress",
    UnderlyingToken = "underlyingToken",
    UnderlyingToken__id = "underlyingToken__id",
    UnderlyingToken__createdAtTimestamp = "underlyingToken__createdAtTimestamp",
    UnderlyingToken__createdAtBlockNumber = "underlyingToken__createdAtBlockNumber",
    UnderlyingToken__decimals = "underlyingToken__decimals",
    UnderlyingToken__name = "underlyingToken__name",
    UnderlyingToken__symbol = "underlyingToken__symbol",
    UnderlyingToken__isSuperToken = "underlyingToken__isSuperToken",
    UnderlyingToken__isNativeAssetSuperToken = "underlyingToken__isNativeAssetSuperToken",
    UnderlyingToken__isListed = "underlyingToken__isListed",
    UnderlyingToken__underlyingAddress = "underlyingToken__underlyingAddress",
    GovernanceConfig = "governanceConfig",
    GovernanceConfig__id = "governanceConfig__id",
    GovernanceConfig__createdAtTimestamp = "governanceConfig__createdAtTimestamp",
    GovernanceConfig__createdAtBlockNumber = "governanceConfig__createdAtBlockNumber",
    GovernanceConfig__updatedAtTimestamp = "governanceConfig__updatedAtTimestamp",
    GovernanceConfig__updatedAtBlockNumber = "governanceConfig__updatedAtBlockNumber",
    GovernanceConfig__isDefault = "governanceConfig__isDefault",
    GovernanceConfig__rewardAddress = "governanceConfig__rewardAddress",
    GovernanceConfig__liquidationPeriod = "governanceConfig__liquidationPeriod",
    GovernanceConfig__patricianPeriod = "governanceConfig__patricianPeriod",
    GovernanceConfig__minimumDeposit = "governanceConfig__minimumDeposit"
}
export type TransferEvent = Event & {
    __typename?: 'TransferEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /**
     * Contains the addresses that were impacted by this event:
     * addresses[0] = `token` (superToken)
     * addresses[1] = `from`
     * addresses[2] = `to`
     */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    from: Account;
    to: Account;
    value: Scalars['BigInt'];
    token: Scalars['Bytes'];
};
export type TransferEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    from?: Maybe<Scalars['String']>;
    from_not?: Maybe<Scalars['String']>;
    from_gt?: Maybe<Scalars['String']>;
    from_lt?: Maybe<Scalars['String']>;
    from_gte?: Maybe<Scalars['String']>;
    from_lte?: Maybe<Scalars['String']>;
    from_in?: Maybe<Array<Scalars['String']>>;
    from_not_in?: Maybe<Array<Scalars['String']>>;
    from_contains?: Maybe<Scalars['String']>;
    from_contains_nocase?: Maybe<Scalars['String']>;
    from_not_contains?: Maybe<Scalars['String']>;
    from_not_contains_nocase?: Maybe<Scalars['String']>;
    from_starts_with?: Maybe<Scalars['String']>;
    from_starts_with_nocase?: Maybe<Scalars['String']>;
    from_not_starts_with?: Maybe<Scalars['String']>;
    from_not_starts_with_nocase?: Maybe<Scalars['String']>;
    from_ends_with?: Maybe<Scalars['String']>;
    from_ends_with_nocase?: Maybe<Scalars['String']>;
    from_not_ends_with?: Maybe<Scalars['String']>;
    from_not_ends_with_nocase?: Maybe<Scalars['String']>;
    from_?: Maybe<Account_Filter>;
    to?: Maybe<Scalars['String']>;
    to_not?: Maybe<Scalars['String']>;
    to_gt?: Maybe<Scalars['String']>;
    to_lt?: Maybe<Scalars['String']>;
    to_gte?: Maybe<Scalars['String']>;
    to_lte?: Maybe<Scalars['String']>;
    to_in?: Maybe<Array<Scalars['String']>>;
    to_not_in?: Maybe<Array<Scalars['String']>>;
    to_contains?: Maybe<Scalars['String']>;
    to_contains_nocase?: Maybe<Scalars['String']>;
    to_not_contains?: Maybe<Scalars['String']>;
    to_not_contains_nocase?: Maybe<Scalars['String']>;
    to_starts_with?: Maybe<Scalars['String']>;
    to_starts_with_nocase?: Maybe<Scalars['String']>;
    to_not_starts_with?: Maybe<Scalars['String']>;
    to_not_starts_with_nocase?: Maybe<Scalars['String']>;
    to_ends_with?: Maybe<Scalars['String']>;
    to_ends_with_nocase?: Maybe<Scalars['String']>;
    to_not_ends_with?: Maybe<Scalars['String']>;
    to_not_ends_with_nocase?: Maybe<Scalars['String']>;
    to_?: Maybe<Account_Filter>;
    value?: Maybe<Scalars['BigInt']>;
    value_not?: Maybe<Scalars['BigInt']>;
    value_gt?: Maybe<Scalars['BigInt']>;
    value_lt?: Maybe<Scalars['BigInt']>;
    value_gte?: Maybe<Scalars['BigInt']>;
    value_lte?: Maybe<Scalars['BigInt']>;
    value_in?: Maybe<Array<Scalars['BigInt']>>;
    value_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_gt?: Maybe<Scalars['Bytes']>;
    token_lt?: Maybe<Scalars['Bytes']>;
    token_gte?: Maybe<Scalars['Bytes']>;
    token_lte?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<TransferEvent_Filter>>>;
    or?: Maybe<Array<Maybe<TransferEvent_Filter>>>;
};
export declare enum TransferEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    From = "from",
    From__id = "from__id",
    From__createdAtTimestamp = "from__createdAtTimestamp",
    From__createdAtBlockNumber = "from__createdAtBlockNumber",
    From__updatedAtTimestamp = "from__updatedAtTimestamp",
    From__updatedAtBlockNumber = "from__updatedAtBlockNumber",
    From__isSuperApp = "from__isSuperApp",
    To = "to",
    To__id = "to__id",
    To__createdAtTimestamp = "to__createdAtTimestamp",
    To__createdAtBlockNumber = "to__createdAtBlockNumber",
    To__updatedAtTimestamp = "to__updatedAtTimestamp",
    To__updatedAtBlockNumber = "to__updatedAtBlockNumber",
    To__isSuperApp = "to__isSuperApp",
    Value = "value",
    Token = "token"
}
export type TrustedForwarderChangedEvent = Event & {
    __typename?: 'TrustedForwarderChangedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    gasUsed: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** The address of the governance contract the event was emitted from. */
    governanceAddress: Scalars['Bytes'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    host: Scalars['Bytes'];
    superToken: Scalars['Bytes'];
    isKeySet: Scalars['Boolean'];
    forwarder: Scalars['Bytes'];
    enabled: Scalars['Boolean'];
};
export type TrustedForwarderChangedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_gt?: Maybe<Scalars['Bytes']>;
    transactionHash_lt?: Maybe<Scalars['Bytes']>;
    transactionHash_gte?: Maybe<Scalars['Bytes']>;
    transactionHash_lte?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed?: Maybe<Scalars['BigInt']>;
    gasUsed_not?: Maybe<Scalars['BigInt']>;
    gasUsed_gt?: Maybe<Scalars['BigInt']>;
    gasUsed_lt?: Maybe<Scalars['BigInt']>;
    gasUsed_gte?: Maybe<Scalars['BigInt']>;
    gasUsed_lte?: Maybe<Scalars['BigInt']>;
    gasUsed_in?: Maybe<Array<Scalars['BigInt']>>;
    gasUsed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    governanceAddress?: Maybe<Scalars['Bytes']>;
    governanceAddress_not?: Maybe<Scalars['Bytes']>;
    governanceAddress_gt?: Maybe<Scalars['Bytes']>;
    governanceAddress_lt?: Maybe<Scalars['Bytes']>;
    governanceAddress_gte?: Maybe<Scalars['Bytes']>;
    governanceAddress_lte?: Maybe<Scalars['Bytes']>;
    governanceAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_contains?: Maybe<Scalars['Bytes']>;
    governanceAddress_not_contains?: Maybe<Scalars['Bytes']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    host?: Maybe<Scalars['Bytes']>;
    host_not?: Maybe<Scalars['Bytes']>;
    host_gt?: Maybe<Scalars['Bytes']>;
    host_lt?: Maybe<Scalars['Bytes']>;
    host_gte?: Maybe<Scalars['Bytes']>;
    host_lte?: Maybe<Scalars['Bytes']>;
    host_in?: Maybe<Array<Scalars['Bytes']>>;
    host_not_in?: Maybe<Array<Scalars['Bytes']>>;
    host_contains?: Maybe<Scalars['Bytes']>;
    host_not_contains?: Maybe<Scalars['Bytes']>;
    superToken?: Maybe<Scalars['Bytes']>;
    superToken_not?: Maybe<Scalars['Bytes']>;
    superToken_gt?: Maybe<Scalars['Bytes']>;
    superToken_lt?: Maybe<Scalars['Bytes']>;
    superToken_gte?: Maybe<Scalars['Bytes']>;
    superToken_lte?: Maybe<Scalars['Bytes']>;
    superToken_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_not_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_contains?: Maybe<Scalars['Bytes']>;
    superToken_not_contains?: Maybe<Scalars['Bytes']>;
    isKeySet?: Maybe<Scalars['Boolean']>;
    isKeySet_not?: Maybe<Scalars['Boolean']>;
    isKeySet_in?: Maybe<Array<Scalars['Boolean']>>;
    isKeySet_not_in?: Maybe<Array<Scalars['Boolean']>>;
    forwarder?: Maybe<Scalars['Bytes']>;
    forwarder_not?: Maybe<Scalars['Bytes']>;
    forwarder_gt?: Maybe<Scalars['Bytes']>;
    forwarder_lt?: Maybe<Scalars['Bytes']>;
    forwarder_gte?: Maybe<Scalars['Bytes']>;
    forwarder_lte?: Maybe<Scalars['Bytes']>;
    forwarder_in?: Maybe<Array<Scalars['Bytes']>>;
    forwarder_not_in?: Maybe<Array<Scalars['Bytes']>>;
    forwarder_contains?: Maybe<Scalars['Bytes']>;
    forwarder_not_contains?: Maybe<Scalars['Bytes']>;
    enabled?: Maybe<Scalars['Boolean']>;
    enabled_not?: Maybe<Scalars['Boolean']>;
    enabled_in?: Maybe<Array<Scalars['Boolean']>>;
    enabled_not_in?: Maybe<Array<Scalars['Boolean']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
    and?: Maybe<Array<Maybe<TrustedForwarderChangedEvent_Filter>>>;
    or?: Maybe<Array<Maybe<TrustedForwarderChangedEvent_Filter>>>;
};
export declare enum TrustedForwarderChangedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    GasUsed = "gasUsed",
    Timestamp = "timestamp",
    Name = "name",
    GovernanceAddress = "governanceAddress",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Host = "host",
    SuperToken = "superToken",
    IsKeySet = "isKeySet",
    Forwarder = "forwarder",
    Enabled = "enabled"
}
export type _Block_ = {
    __typename?: '_Block_';
    /** The hash of the block */
    hash?: Maybe<Scalars['Bytes']>;
    /** The block number */
    number: Scalars['Int'];
    /** Integer representation of the timestamp stored in blocks for the chain */
    timestamp?: Maybe<Scalars['Int']>;
};
/** The type for the top-level _meta field */
export type _Meta_ = {
    __typename?: '_Meta_';
    /**
     * Information about a specific subgraph block. The hash of the block
     * will be null if the _meta field has a block constraint that asks for
     * a block number. It will be filled if the _meta field has no block constraint
     * and therefore asks for the latest  block
     */
    block: _Block_;
    /** The deployment ID */
    deployment: Scalars['String'];
    /** If `true`, the subgraph encountered indexing errors at some past block */
    hasIndexingErrors: Scalars['Boolean'];
};
export declare enum _SubgraphErrorPolicy_ {
    /** Data will be returned even if the subgraph has indexing errors */
    Allow = "allow",
    /** If the subgraph has indexing errors, data will be omitted. The default. */
    Deny = "deny"
}
export type EventFragmentFragment = ({
    __typename?: 'FlowUpdatedEvent';
} & Pick<FlowUpdatedEvent, 'transactionHash' | 'blockNumber' | 'timestamp' | 'sender' | 'flowRate' | 'oldFlowRate' | 'type'>);
export type PaymentFragmentFragment = ({
    __typename?: 'SentEvent';
} & Pick<SentEvent, 'transactionHash' | 'blockNumber' | 'timestamp' | 'from' | 'amount'>);
export type GetSuperFluidEventsQueryVariables = Exact<{
    tokenAddress: Scalars['Bytes'];
    to: Scalars['Bytes'];
    reference: Scalars['Bytes'];
}>;
export type GetSuperFluidEventsQuery = ({
    __typename?: 'Query';
} & {
    untagged: Array<({
        __typename?: 'FlowUpdatedEvent';
    } & EventFragmentFragment)>;
    flow: Array<({
        __typename?: 'FlowUpdatedEvent';
    } & EventFragmentFragment)>;
    payment: Array<({
        __typename?: 'SentEvent';
    } & PaymentFragmentFragment)>;
});
export declare const EventFragmentFragmentDoc: import("graphql/language/ast").DocumentNode;
export declare const PaymentFragmentFragmentDoc: import("graphql/language/ast").DocumentNode;
export declare const GetSuperFluidEventsDocument: import("graphql/language/ast").DocumentNode;
export type SdkFunctionWrapper = <T>(action: (requestHeaders?: Record<string, string>) => Promise<T>, operationName: string) => Promise<T>;
export declare function getSdk(client: GraphQLClient, withWrapper?: SdkFunctionWrapper): {
    GetSuperFluidEvents(variables: GetSuperFluidEventsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetSuperFluidEventsQuery>;
};
export type Sdk = ReturnType<typeof getSdk>;
export declare const EventFragment: import("graphql/language/ast").DocumentNode;
export declare const PaymentFragment: import("graphql/language/ast").DocumentNode;
export declare const GetSuperFluidEvents: import("graphql/language/ast").DocumentNode;
//# sourceMappingURL=graphql-superfluid.d.ts.map