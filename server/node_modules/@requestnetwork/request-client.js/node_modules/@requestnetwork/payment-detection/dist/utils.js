"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatAddress = exports.hashReference = exports.getPaymentReference = exports.getPaymentNetworkExtension = exports.calculateEscrowState = exports.makeGetDeploymentInformation = exports.unpadAmountFromChainlink = exports.padAmountForChainlink = exports.parseLogArgs = void 0;
const currency_1 = require("@requestnetwork/currency");
const types_1 = require("@requestnetwork/types");
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const balance_error_1 = require("./balance-error");
const payment_reference_calculator_1 = require("./payment-reference-calculator");
/**
 * Converts the Log's args from array to an object with keys being the name of the arguments
 */
const parseLogArgs = ({ args, eventFragment }) => {
    return args.reduce((prev, current, i) => {
        prev[eventFragment.inputs[i].name] = current;
        return prev;
    }, {});
};
exports.parseLogArgs = parseLogArgs;
/**
 * Pads an amount to match Chainlink's own currency decimals (eg. for fiat amounts).
 */
const padAmountForChainlink = (amount, currency) => {
    // eslint-disable-next-line no-magic-numbers
    return ethers_1.BigNumber.from(amount).mul(Math.pow(10, getChainlinkPaddingSize(currency)));
};
exports.padAmountForChainlink = padAmountForChainlink;
const unpadAmountFromChainlink = (amount, currency) => {
    // eslint-disable-next-line no-magic-numbers
    return ethers_1.BigNumber.from(amount).div(Math.pow(10, getChainlinkPaddingSize(currency)));
};
exports.unpadAmountFromChainlink = unpadAmountFromChainlink;
const getChainlinkPaddingSize = ({ type, decimals, }) => {
    switch (type) {
        case types_1.RequestLogicTypes.CURRENCY.ISO4217: {
            const chainlinkFiatDecimal = 8;
            return Math.max(chainlinkFiatDecimal - decimals, 0);
        }
        case types_1.RequestLogicTypes.CURRENCY.ETH:
        case types_1.RequestLogicTypes.CURRENCY.ERC20: {
            return 0;
        }
        default:
            throw new Error('Unsupported request currency for conversion with Chainlink. The request currency has to be fiat, ETH or ERC20.');
    }
};
/*
 * Returns the method to get deployment information for the underlying smart contract (based on a payment network version)
 * for given artifact and version mapping.
 */
const makeGetDeploymentInformation = (artifact, map, allowUndefined) => {
    return (network, paymentNetworkVersion) => {
        const contractVersion = map[paymentNetworkVersion];
        if (!contractVersion) {
            throw new balance_error_1.VersionNotSupported(`No contract matches payment network version: ${paymentNetworkVersion}.`);
        }
        const info = artifact.getOptionalDeploymentInformation(network, contractVersion);
        if (!info) {
            if (!allowUndefined) {
                if (artifact.getOptionalDeploymentInformation(network)) {
                    throw new balance_error_1.VersionNotSupported(`Payment network version not supported: ${paymentNetworkVersion}`);
                }
                throw new balance_error_1.NetworkNotSupported(`Network not supported for this payment network: ${network}`);
            }
            return null;
        }
        return Object.assign(Object.assign({}, info), { contractVersion });
    };
};
exports.makeGetDeploymentInformation = makeGetDeploymentInformation;
/**
 * Returns escrow status based on array of escrow events
 * @param escrowEvents Balance of the request being updated
 * @returns
 */
const calculateEscrowState = (escrowEvents) => {
    var _a;
    if (escrowEvents.length === 0) {
        return null;
    }
    const latestEscrowEvent = escrowEvents[escrowEvents.length - 1];
    switch ((_a = latestEscrowEvent.parameters) === null || _a === void 0 ? void 0 : _a.eventName) {
        case types_1.PaymentTypes.ESCROW_EVENTS_NAMES.FREEZE_ESCROW:
            return types_1.PaymentTypes.ESCROW_STATE.IN_FROZEN;
        case types_1.PaymentTypes.ESCROW_EVENTS_NAMES.INITIATE_EMERGENCY_CLAIM:
            return types_1.PaymentTypes.ESCROW_STATE.IN_EMERGENCY;
        case types_1.PaymentTypes.ESCROW_EVENTS_NAMES.PAID_ESCROW:
        case types_1.PaymentTypes.ESCROW_EVENTS_NAMES.REVERT_EMERGENCY_CLAIM:
            return types_1.PaymentTypes.ESCROW_STATE.PAID_ESCROW;
        case types_1.PaymentTypes.ESCROW_EVENTS_NAMES.PAID_ISSUER:
            return types_1.PaymentTypes.ESCROW_STATE.PAID_ISSUER;
    }
    return null;
};
exports.calculateEscrowState = calculateEscrowState;
/**
 * Return the payment network extension of a Request.
 */
function getPaymentNetworkExtension(request) {
    return Object.values(request.extensions).find((x) => x.type === types_1.ExtensionTypes.TYPE.PAYMENT_NETWORK);
}
exports.getPaymentNetworkExtension = getPaymentNetworkExtension;
/** Gets the payment info based on parameters, for payment reference calculation */
const getInfo = ({ paymentAddress, paymentInfo, refundAddress, refundInfo }, event) => {
    if (event === types_1.PaymentTypes.EVENTS_NAMES.REFUND) {
        return refundAddress || JSON.stringify(refundInfo);
    }
    return paymentAddress || JSON.stringify(paymentInfo);
};
/** Gets a payment (or refund) reference for any type of Request */
function getPaymentReference(request, event = types_1.PaymentTypes.EVENTS_NAMES.PAYMENT) {
    const extension = getPaymentNetworkExtension(request);
    if (!extension) {
        throw new Error('no payment network found');
    }
    const requestId = request.requestId;
    const salt = extension.values.salt;
    if (!salt)
        return;
    const info = getInfo(extension.values, event);
    if (!info)
        return;
    return payment_reference_calculator_1.default.calculate(requestId, salt, info);
}
exports.getPaymentReference = getPaymentReference;
/**
 * Returns the hash of a payment reference.
 * @see getPaymentReference
 */
const hashReference = (paymentReference) => {
    return (0, utils_1.keccak256)(`0x${paymentReference}`);
};
exports.hashReference = hashReference;
/**
 * For EVMs: alias to ethers.utils.getAddress that adds the key to error message, and supports nullish values.
 * For other chains: applies lower-case to the address.
 */
const formatAddress = (address, key, allowsUndefined = false) => {
    if (!address && allowsUndefined)
        return undefined;
    if (address && (0, currency_1.isValidNearAddress)(address)) {
        return address === null || address === void 0 ? void 0 : address.toLowerCase();
    }
    try {
        return (0, utils_1.getAddress)(address || '');
    }
    catch (e) {
        ethers_1.logger.throwError('invalid address', ethers_1.errors.INVALID_ARGUMENT, {
            argument: 'address',
            value: address,
            key,
        });
    }
};
exports.formatAddress = formatAddress;
//# sourceMappingURL=utils.js.map