import { CurrencyTypes, ExtensionTypes, PaymentTypes, RequestLogicTypes } from '@requestnetwork/types';
import { AnyToNativeDetector } from '../any-to-native-detector';
import { NativeDetectorOptions } from '../types';
/**
 * Handle payment detection for NEAR native token payment with conversion
 */
export declare class NearConversionNativeTokenPaymentDetector extends AnyToNativeDetector {
    private readonly getSubgraphClient;
    constructor(args: NativeDetectorOptions);
    static getContractName: (chainName: CurrencyTypes.NearChainName, paymentNetworkVersion?: string) => string;
    /**
     * Extracts the events for an address and a payment reference
     *
     * @param toAddress Address to check
     * @param eventName Indicate if it is an address for payment or refund
     * @param requestCurrency The request currency
     * @param paymentReference The reference to identify the payment
     * @param paymentNetwork the payment network state
     * @returns The balance with events
     */
    protected extractEvents(eventName: PaymentTypes.EVENTS_NAMES, toAddress: string | undefined, paymentReference: string, requestCurrency: RequestLogicTypes.ICurrency, paymentChain: CurrencyTypes.NearChainName, paymentNetwork: ExtensionTypes.IState<ExtensionTypes.PnAnyToEth.ICreationParameters>): Promise<PaymentTypes.AllNetworkRetrieverEvents<PaymentTypes.ETHPaymentNetworkEvent>>;
    protected getPaymentChain(request: RequestLogicTypes.IRequest): CurrencyTypes.NearChainName;
    protected static getVersionOrThrow: (paymentNetworkVersion: string) => string;
}
//# sourceMappingURL=near-conversion-detector.d.ts.map