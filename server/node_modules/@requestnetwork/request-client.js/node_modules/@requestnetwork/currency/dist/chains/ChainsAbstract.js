"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainsAbstract = void 0;
const native_1 = require("../native");
class ChainsAbstract {
    constructor(chains, currencyType) {
        /**
         * @returns true if both chains have the same ID or same name
         */
        this.isSameChain = (chain1, chain2) => {
            return chain1 === chain2 || this.getChainId(chain1) === this.getChainId(chain2);
        };
        /**
         * @returns true if both chains have the same ID or same name
         */
        this.isSameChainFromString = (chain1, chain2) => {
            try {
                this.assertChainSupported(chain1);
                this.assertChainSupported(chain2);
            }
            catch (_a) {
                return false;
            }
            return this.isSameChain(chain1, chain2);
        };
        this.chains = chains;
        this.chainNames = Object.keys(chains);
        this.addNativeCurrenciesToChains(currencyType);
    }
    /**
     * Adds the native currency to the list of currencies supported by each chain
     */
    addNativeCurrenciesToChains(currencyType) {
        this.chainNames.forEach((chainName) => {
            const nativeCurrency = native_1.nativeCurrencies[currencyType].find((currency) => currency.network === chainName);
            if (nativeCurrency) {
                const chainCurrencies = this.chains[chainName].currencies || {};
                chainCurrencies.native = nativeCurrency;
                this.chains[chainName].currencies = chainCurrencies;
            }
        });
    }
    /**
     * Check if chainName lives amongst the list of supported chains by this chain type.
     * Throws in the case it's not supported.
     */
    assertChainSupported(chainName) {
        if (!this.isChainSupported(chainName))
            throw new Error(`Unsupported chain ${chainName}`);
    }
    /**
     * Check if chainName lives amongst the list of supported chains by this chain type.
     */
    isChainSupported(chainName) {
        return !!chainName && this.chainNames.includes(chainName);
    }
    /**
     * Retrieve the corresponding chain ID from Request Network's internal chain name representation
     */
    getChainId(chainName) {
        return this.chains[chainName].chainId;
    }
    /**
     * Retrieve Request Network's internal chain name representation from the corresponding chain ID
     */
    getChainName(chainId) {
        return this.chainNames.find((chainName) => this.chains[chainName].chainId === chainId);
    }
    /**
     * Returns true is the chain is a testnet chain
     */
    isTestnet(chainName) {
        return Boolean(this.chains[chainName].testnet);
    }
}
exports.ChainsAbstract = ChainsAbstract;
//# sourceMappingURL=ChainsAbstract.js.map