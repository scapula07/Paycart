"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPath = exports.conversionSupportedNetworks = exports.defaultConversionPairs = void 0;
const tslib_1 = require("tslib");
const node_dijkstra_1 = tslib_1.__importDefault(require("node-dijkstra"));
const private_json_1 = tslib_1.__importDefault(require("./aggregators/private.json"));
const mainnet_json_1 = tslib_1.__importDefault(require("./aggregators/mainnet.json"));
const goerli_json_1 = tslib_1.__importDefault(require("./aggregators/goerli.json"));
const rinkeby_json_1 = tslib_1.__importDefault(require("./aggregators/rinkeby.json"));
const matic_json_1 = tslib_1.__importDefault(require("./aggregators/matic.json"));
const fantom_json_1 = tslib_1.__importDefault(require("./aggregators/fantom.json"));
const near_json_1 = tslib_1.__importDefault(require("./aggregators/near.json"));
const near_testnet_json_1 = tslib_1.__importDefault(require("./aggregators/near-testnet.json"));
const aurora_testnet_json_1 = tslib_1.__importDefault(require("./aggregators/aurora-testnet.json"));
// Pairs supported by Chainlink (can be generated from requestNetwork/toolbox/src/chainlinkConversionPathTools.ts)
const chainlinkCurrencyPairs = {
    private: private_json_1.default,
    goerli: goerli_json_1.default,
    rinkeby: rinkeby_json_1.default,
    mainnet: mainnet_json_1.default,
    matic: matic_json_1.default,
    fantom: fantom_json_1.default,
};
// Pairs supported by Flux Protocol
const fluxCurrencyPairs = {
    aurora: near_json_1.default,
    'aurora-testnet': aurora_testnet_json_1.default,
    'near-testnet': near_testnet_json_1.default,
};
// FIX ME: This fix enables to get these networks registered in conversionSupportedNetworks.
// Could be improved by removing the supported network check from the protocol
const noConversionNetworks = {
    'arbitrum-rinkeby': {},
    'arbitrum-one': {},
    xdai: {},
    avalanche: {},
    bsc: {},
    optimism: {},
    moonbeam: {},
};
/**
 * Conversion paths per network used by default if no other path given to the Currency Manager.
 * Must be updated every time an aggregator is added to one network.
 */
exports.defaultConversionPairs = Object.assign(Object.assign(Object.assign({}, chainlinkCurrencyPairs), fluxCurrencyPairs), noConversionNetworks);
exports.conversionSupportedNetworks = Object.keys(exports.defaultConversionPairs);
/**
 * Gets the on-chain conversion path between two currencies.
 * The path is used to value currencyFrom against currencyTo.
 *
 * @param currencyFrom currency from
 * @param currencyTo currency to
 * @param network ethereum network (default: 'mainnet')
 *
 * @returns conversion path
 */
function getPath(currencyFrom, currencyTo, network = 'mainnet', pairs = exports.defaultConversionPairs) {
    if (!pairs[network]) {
        throw Error(`network ${network} not supported`);
    }
    // load the Graph
    const route = new node_dijkstra_1.default(pairs[network]);
    // Get the path
    return route.path(currencyFrom.hash.toLowerCase(), currencyTo.hash.toLowerCase());
}
exports.getPath = getPath;
//# sourceMappingURL=conversion-aggregators.js.map