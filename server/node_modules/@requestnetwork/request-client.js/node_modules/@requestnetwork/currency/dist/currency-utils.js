"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isERC777Currency = exports.isERC20Currency = exports.isISO4217Currency = exports.isNativeCurrency = exports.isValidNearAddress = void 0;
const types_1 = require("@requestnetwork/types");
/**
 * Checks if a Near address is valid according to a currency network.
 * Returns true if the currency network is not given and the address is correct for any network.
 */
const isValidNearAddress = (address, network) => {
    if (!network) {
        return (0, exports.isValidNearAddress)(address, 'near') || (0, exports.isValidNearAddress)(address, 'near-testnet');
    }
    // see link bellow for NEAR address specification
    // https://nomicon.io/DataStructures/Account.html
    if (address.length < 2 || address.length > 64) {
        return false;
    }
    if (!address.match(/^(([a-z\d]+[-_])*[a-z\d]+\.)*([a-z\d]+[-_])*[a-z\d]+$/)) {
        return false;
    }
    // Return true when account format is in hexadecimal format
    if (address.match(/[a-fA-F0-9]{64}$/)) {
        return true;
    }
    // see link bellow for details about top level accounts on mainnet and testnet
    // https://docs.near.org/docs/videos/accounts-keys
    switch (network) {
        case 'aurora':
        case 'near':
            return !!address.match(/\.near$/);
        case 'aurora-testnet':
        case 'near-testnet':
            return !!address.match(/\.testnet$/);
        default:
            throw new Error(`Cannot validate NEAR address for network ${network}`);
    }
};
exports.isValidNearAddress = isValidNearAddress;
/**
 * Type guards
 * Enable filtering per currency type
 */
const isNativeCurrency = (currency) => {
    return (currency.type === types_1.RequestLogicTypes.CURRENCY.BTC ||
        currency.type === types_1.RequestLogicTypes.CURRENCY.ETH);
};
exports.isNativeCurrency = isNativeCurrency;
const isISO4217Currency = (currency) => {
    return currency.type === types_1.RequestLogicTypes.CURRENCY.ISO4217;
};
exports.isISO4217Currency = isISO4217Currency;
const isERC20Currency = (currency) => {
    return currency.type === types_1.RequestLogicTypes.CURRENCY.ERC20;
};
exports.isERC20Currency = isERC20Currency;
const isERC777Currency = (currency) => {
    return currency.type === types_1.RequestLogicTypes.CURRENCY.ERC777;
};
exports.isERC777Currency = isERC777Currency;
//# sourceMappingURL=currency-utils.js.map