"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CurrencyManager = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const ethers_1 = require("ethers");
const multicoin_address_validator_1 = tslib_1.__importDefault(require("multicoin-address-validator"));
const erc20_1 = require("./erc20");
const erc777_1 = require("./erc777");
const getHash_1 = require("./getHash");
const iso4217_1 = tslib_1.__importDefault(require("./iso4217"));
const native_1 = require("./native");
const conversion_aggregators_1 = require("./conversion-aggregators");
const currency_utils_1 = require("./currency-utils");
const chains_1 = require("./chains");
const { BTC, ERC20, ERC777, ETH, ISO4217 } = types_1.RequestLogicTypes.CURRENCY;
/**
 * Handles a list of currencies and provide features to retrieve them, as well as convert to/from storage format
 */
class CurrencyManager {
    /**
     *
     * @param inputCurrencies The list of currencies known by the Manager.
     * @param legacyTokens A mapping of legacy currency name or network name, in the format { "chainName": {"TOKEN": ["NEW_TOKEN","NEW_CHAIN"]}}
     * @param conversionPairs A mapping of possible conversions by network (network => currencyFrom => currencyTo => cost)
     */
    constructor(inputCurrencies, legacyTokens, conversionPairs) {
        this.knownCurrencies = [];
        for (const input of inputCurrencies) {
            const currency = CurrencyManager.fromInput(input);
            if (this.knownCurrencies.some((x) => x.id === currency.id)) {
                throw new Error(`Duplicate found: ${currency.id}`);
            }
            this.knownCurrencies.push(currency);
        }
        this.legacyTokens = legacyTokens || CurrencyManager.getDefaultLegacyTokens();
        this.conversionPairs = conversionPairs || CurrencyManager.getDefaultConversionPairs();
    }
    /**
     * Gets a supported currency from a symbol, symbol-network, currency definition id or address.
     *
     * @param currencyIdentifier e.g. 'DAI', 'FAU', 'FAU-rinkeby', 'ETH-rinkeby-rinkeby' or '0xFab46E002BbF0b4509813474841E0716E6730136'
     * @param network e.g. rinkeby, mainnet
     */
    from(currencyIdentifier, network) {
        if (!currencyIdentifier) {
            return;
        }
        if (ethers_1.utils.isAddress(currencyIdentifier)) {
            return this.fromAddress(currencyIdentifier, network);
        }
        const parts = currencyIdentifier.split('-');
        const currencyFromSymbol = this.fromSymbol(parts[0], network || parts[1]) ||
            // try without splitting the symbol to support currencies like ETH-rinkeby
            this.fromSymbol(currencyIdentifier, network);
        if (currencyFromSymbol) {
            return currencyFromSymbol;
        }
        return this.fromId(currencyIdentifier);
    }
    /**
     * Gets a supported currency from its CurrencyDefinition id
     */
    fromId(id) {
        return this.knownCurrencies.find((knownCurrency) => knownCurrency.id === id);
    }
    /**
     * Gets a supported currency from its address and network.
     * If more than one currency are found, undefined is returned
     */
    fromAddress(address, network) {
        address = ethers_1.utils.getAddress(address);
        const matches = this.knownCurrencies.filter((x) => (x.type === ERC20 || x.type === ERC777) &&
            x.address === address &&
            (!network || x.network === network));
        if (matches.length > 1) {
            const networks = matches.map((x) => x.network).join(', ');
            console.warn(`${address} has several matches on ${networks}. To avoid errors, specify a network.`);
            return undefined;
        }
        return matches[0];
    }
    /**
     * Gets a supported currency from its symbol and network.
     */
    fromSymbol(symbol, network) {
        var _a;
        symbol = symbol === null || symbol === void 0 ? void 0 : symbol.toUpperCase();
        network = network === null || network === void 0 ? void 0 : network.toLowerCase();
        const legacy = network ? (_a = this.legacyTokens[network]) === null || _a === void 0 ? void 0 : _a[symbol] : undefined;
        if (legacy) {
            [symbol, network] = legacy;
        }
        return this.knownCurrencies.find((x) => x.symbol.toUpperCase() === symbol &&
            ((x.type === ISO4217 && !network) || ('network' in x && x.network === network) || !network));
    }
    fromHash(hash, network) {
        return this.knownCurrencies.find((x) => x.hash.toLowerCase() === hash.toLowerCase() &&
            ((x.type === ISO4217 && !network) || ('network' in x && x.network === network) || !network));
    }
    /**
     * Retrieves a currency given its storage format (ICurrency)
     */
    fromStorageCurrency(currency) {
        if (!currency) {
            return;
        }
        if (!currency.type) {
            throw new Error('Invalid format');
        }
        const networkOrDefault = currency.network || 'mainnet';
        return this.knownCurrencies.find((x) => x.type === currency.type &&
            (((x.type === ERC20 || x.type === ERC777) &&
                currency.value === x.address &&
                x.network === networkOrDefault) ||
                ((x.type === ETH || x.type === BTC) && x.network === networkOrDefault) ||
                (x.symbol === currency.value && !currency.network)));
    }
    /**
     * Retrieves a Native currency for a type and network
     */
    getNativeCurrency(type, network) {
        return this.knownCurrencies.find((x) => x.type === type && x.network === network);
    }
    getConversionPath(from, to, network) {
        try {
            return (0, conversion_aggregators_1.getPath)(from, to, network, this.conversionPairs);
        }
        catch (e) {
            return null;
        }
    }
    supportsConversion(currency, network) {
        var _a;
        return !!((_a = this.conversionPairs[network]) === null || _a === void 0 ? void 0 : _a[currency.hash.toLowerCase()]);
    }
    /**
     * Adds computed parameters to a CurrencyInput
     */
    static fromInput(_a) {
        var { id, hash, meta } = _a, input = tslib_1.__rest(_a, ["id", "hash", "meta"]);
        if ('address' in input) {
            if (input.address.startsWith('0x') && input.address.length === 42) {
                input.address = ethers_1.utils.getAddress(input.address);
            }
        }
        return Object.assign({ id: id || CurrencyManager.currencyId(input), hash: hash || (0, getHash_1.getHash)(CurrencyManager.toStorageCurrency(input)), meta: meta }, input);
    }
    /**
     * Utility function to compute the unique identifier
     */
    static currencyId(currency) {
        return 'network' in currency ? `${currency.symbol}-${currency.network}` : currency.symbol;
    }
    /**
     * Converts a currency to the storage format (ICurrency)
     */
    static toStorageCurrency(currency) {
        return {
            type: currency.type,
            value: currency.type === ERC20 || currency.type === ERC777 ? currency.address : currency.symbol,
            network: currency.type === ISO4217 ? undefined : currency.network,
        };
    }
    /**
     * Validates an address for a given currency.
     * Throws if the currency is an ISO4217 currency.
     */
    static validateAddress(address, currency) {
        if (currency.type === types_1.RequestLogicTypes.CURRENCY.ISO4217) {
            throw new Error(`Could not validate an address for an ISO4217 currency`);
        }
        switch (currency.type) {
            case types_1.RequestLogicTypes.CURRENCY.ETH:
            case types_1.RequestLogicTypes.CURRENCY.ERC20:
            case types_1.RequestLogicTypes.CURRENCY.ERC777:
                if (chains_1.NearChains.isChainSupported(currency.network)) {
                    return (0, currency_utils_1.isValidNearAddress)(address, currency.network);
                }
                return multicoin_address_validator_1.default.validate(address, 'ETH');
            case types_1.RequestLogicTypes.CURRENCY.BTC:
                return multicoin_address_validator_1.default.validate(address, 'BTC', currency.network === 'testnet' ? 'testnet' : 'prod');
            default:
                throw new Error(`Could not validate an address for an unknown currency type`);
        }
    }
    /**
     * Validate the correctness of a Storage Currency
     */
    static validateCurrency(currency) {
        if (currency.type === types_1.RequestLogicTypes.CURRENCY.ISO4217 ||
            currency.type === types_1.RequestLogicTypes.CURRENCY.ETH ||
            currency.type === types_1.RequestLogicTypes.CURRENCY.BTC)
            return true;
        return this.validateAddress(currency.value, currency);
    }
    /**
     * Returns the list of currencies supported by Request out of the box
     * Contains:
     * - ISO currencies
     * - ERC20 currencies from Metamask/contract-metadata + some additional tokens
     * - ERC777 SuperTokens managed by SuperFluid
     * - ETH, & some EVM-compatible chains native tokens
     * - NEAR, YEL, ZIL, BTC
     * - ETH-rinkeby, FAU-rinkeby, CTBK-rinkeby
     */
    static getDefaultList() {
        const isoCurrencies = iso4217_1.default.map((cc) => ({
            decimals: cc.digits,
            name: cc.currency,
            symbol: cc.code,
            type: ISO4217,
        }));
        const eth = native_1.nativeCurrencies.ETH.map((x) => (Object.assign(Object.assign({}, x), { type: ETH })));
        const btc = native_1.nativeCurrencies.BTC.map((x) => (Object.assign(Object.assign({}, x), { type: BTC })));
        const erc20Tokens = (0, erc20_1.getSupportedERC20Tokens)();
        const erc20Currencies = erc20Tokens.map((x) => (Object.assign(Object.assign({}, x), { type: ERC20 })));
        const erc777Tokens = (0, erc777_1.getSupportedERC777Tokens)();
        const erc777Currencies = erc777Tokens.map((x) => (Object.assign(Object.assign({}, x), { type: ERC777 })));
        return isoCurrencies
            .concat(erc20Currencies)
            .concat(erc777Currencies)
            .concat(eth)
            .concat(btc)
            .map(CurrencyManager.fromInput);
    }
    /**
     * Returns the default list of legacy names (for symbol or network)
     */
    static getDefaultLegacyTokens() {
        return {
            near: {
                NEAR: ['NEAR', 'aurora'],
            },
        };
    }
    static getDefaultConversionPairs() {
        return conversion_aggregators_1.defaultConversionPairs;
    }
    /**
     * Returns a default instance of CurrencyManager based on default lists
     */
    static getDefault() {
        return new CurrencyManager(CurrencyManager.getDefaultList(), CurrencyManager.getDefaultLegacyTokens());
    }
}
exports.CurrencyManager = CurrencyManager;
//# sourceMappingURL=currencyManager.js.map