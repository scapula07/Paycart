"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sign = exports.recoverSigner = exports.getIdentityFromSignatureParams = void 0;
const types_1 = require("@requestnetwork/types");
const ethers_1 = require("ethers");
const crypto_1 = require("./crypto");
// Use to localize the parameter V in an ECDSA signature in hex format
const V_POSITION_FROM_END_IN_ECDSA_HEX = -2;
/**
 * Function to get the signer identity from the signature parameters
 *
 * @param ISignatureParameters signatureParams Signature parameters
 *
 * @returns REQUEST_ROLE the role of the signer (payee, payer or third party)
 */
function getIdentityFromSignatureParams(signatureParams) {
    if (signatureParams.method === types_1.SignatureTypes.METHOD.ECDSA) {
        return {
            type: types_1.IdentityTypes.TYPE.ETHEREUM_ADDRESS,
            value: (0, crypto_1.getAddressFromPrivateKey)(signatureParams.privateKey),
        };
    }
    throw new Error('signatureParams.method not supported');
}
exports.getIdentityFromSignatureParams = getIdentityFromSignatureParams;
/**
 * Function to sign data from signature parameters
 *
 * This must be used for test purpose only. A signature providers must be used in production.
 *
 * @param data the data to sign
 * @param signatureParams Signature parameters
 * @returns ISignature the signature
 */
function sign(data, signatureParams) {
    let value;
    if (signatureParams.method === types_1.SignatureTypes.METHOD.ECDSA) {
        value = (0, crypto_1.ecSign)(signatureParams.privateKey, (0, crypto_1.normalizeKeccak256Hash)(data).value);
        return { data, signature: { method: signatureParams.method, value } };
    }
    if (signatureParams.method === types_1.SignatureTypes.METHOD.ECDSA_ETHEREUM) {
        const normalizedData = (0, crypto_1.normalize)(data);
        value = (0, crypto_1.ecSign)(signatureParams.privateKey, ethers_1.ethers.utils.hashMessage(normalizedData));
        return { data, signature: { method: signatureParams.method, value } };
    }
    throw new Error('signatureParams.method not supported');
}
exports.sign = sign;
/**
 * Function to recover signer identity from a signature
 *
 * IMPORTANT: this is used to recover from the signature made by the signature providers
 *
 * @param signedData the data signed
 * @returns identity of the signer
 */
function recoverSigner(signedData) {
    let value;
    if (signedData.signature.method === types_1.SignatureTypes.METHOD.ECDSA) {
        value = (0, crypto_1.ecRecover)(signedData.signature.value, (0, crypto_1.normalizeKeccak256Hash)(signedData.data).value);
        return {
            type: types_1.IdentityTypes.TYPE.ETHEREUM_ADDRESS,
            value,
        };
    }
    if (signedData.signature.method === types_1.SignatureTypes.METHOD.ECDSA_ETHEREUM) {
        // In ethereum V = 0x1B or 0x1C instead of 0x00 or 0x01
        // We make the replacement here
        const v = signedData.signature.value.slice(V_POSITION_FROM_END_IN_ECDSA_HEX);
        let signature = signedData.signature.value;
        if (v.toLowerCase() === '00') {
            signature = `${signedData.signature.value.slice(0, V_POSITION_FROM_END_IN_ECDSA_HEX)}1b`;
        }
        else if (v.toLowerCase() === '01') {
            signature = `${signedData.signature.value.slice(0, V_POSITION_FROM_END_IN_ECDSA_HEX)}1b`;
        }
        const normalizedData = ethers_1.ethers.utils.hashMessage((0, crypto_1.normalize)(signedData.data));
        value = (0, crypto_1.ecRecover)(signature, normalizedData).toLowerCase();
        return {
            type: types_1.IdentityTypes.TYPE.ETHEREUM_ADDRESS,
            value,
        };
    }
    throw new Error('signatureParams.method not supported');
}
exports.recoverSigner = recoverSigner;
//# sourceMappingURL=signature.js.map