"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSignerAndGasFees = exports.updateNativeTokenHash = exports.updateNativeAndUSDAddress = exports.updateBatchConversionProxy = exports.updatePaymentFeeProxyAddress = exports.updateBatchPaymentFeeAmountUSDLimit = exports.updateBatchPaymentFees = exports.updateRequestSwapFees = exports.updateSwapRouter = exports.updateChainlinkConversionPath = exports.BATCH_FEE = exports.REQUEST_SWAP_FEES = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("../../src/lib");
const utils_1 = require("../../scripts/utils");
const artifacts = require("../../src/lib");
const ethers_1 = require("ethers");
const utils_2 = require("ethers/lib/utils");
const utils_3 = require("@requestnetwork/utils");
// Fees: 0.5%
exports.REQUEST_SWAP_FEES = 5;
// Batch Fees: .3%
exports.BATCH_FEE = ethers_1.BigNumber.from(30);
// Batch fee amount in USD Limit: 150 * 1e8 ($150)
const BATCH_FEE_AMOUNT_USD_LIMIT = (0, utils_2.parseUnits)('150', 8);
/**
 * Updates the chainlink address used by the contract.
 * @param contract A contract using chainlink:
 *                 Erc20ConversionProxy | EthConversionProxy | ERC20SwapToConversion.
 * @param network The network used.
 * @param txOverrides information related to gas fees. Increase their values if needed.
 * @param version The version of the chainlink proxy to use, the last one by default.
 */
const updateChainlinkConversionPath = (contract, network, txOverrides, version) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const currentChainlinkAddress = yield contract.chainlinkConversionPath();
    const chainlinkConversionPathAddress = lib_1.chainlinkConversionPath.getAddress(network, version);
    if (currentChainlinkAddress !== chainlinkConversionPathAddress) {
        const tx = yield contract.updateConversionPathAddress(chainlinkConversionPathAddress, txOverrides);
        yield tx.wait(1);
        console.log(`chainlink: the current address ${currentChainlinkAddress} has been replaced by: ${chainlinkConversionPathAddress}`);
    }
});
exports.updateChainlinkConversionPath = updateChainlinkConversionPath;
const updateSwapRouter = (contract, network, txOverrides) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const currentSwapRouter = yield contract.swapRouter();
    const expectedRouter = utils_1.uniswapV2RouterAddresses[network];
    if (expectedRouter && currentSwapRouter !== expectedRouter) {
        const tx = yield contract.setRouter(expectedRouter, txOverrides);
        yield tx.wait(1);
        console.log(`Swap router address set to ${expectedRouter}`);
    }
});
exports.updateSwapRouter = updateSwapRouter;
const updateRequestSwapFees = (contract, txOverrides) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const currentFees = yield contract.requestSwapFees();
    if (!currentFees.eq(exports.REQUEST_SWAP_FEES)) {
        const tx = yield contract.updateRequestSwapFees(exports.REQUEST_SWAP_FEES, txOverrides);
        yield tx.wait(1);
        console.log(`currentFees: ${currentFees.toNumber() / 10}%, new fees: ${exports.REQUEST_SWAP_FEES / 10}%`);
    }
});
exports.updateRequestSwapFees = updateRequestSwapFees;
/**
 * Updates the batchFee applied by the batch conversion proxy.
 * @param contract BatchConversionPayments contract.
 * @param txOverrides information related to gas fees. Increase their values if needed.
 */
const updateBatchPaymentFees = (contract, txOverrides) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const currentFees = yield contract.batchFee();
    if (!exports.BATCH_FEE.eq(currentFees)) {
        const tx = yield contract.setBatchFee(exports.BATCH_FEE, txOverrides);
        yield tx.wait(1);
        console.log(`Batch: currentFees: ${currentFees.toString()}, new fees: ${exports.BATCH_FEE.toString()}`);
    }
});
exports.updateBatchPaymentFees = updateBatchPaymentFees;
/**
 * Updates the feeAMountUSDLimit of the batch conversion proxy.
 * @param contract BatchConversionPayments contract.
 * @param txOverrides information related to gas fees. Increase their values if needed.
 */
const updateBatchPaymentFeeAmountUSDLimit = (contract, txOverrides) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const currentFeeAmountUSDLimit = yield contract.batchFeeAmountUSDLimit();
    if (!currentFeeAmountUSDLimit.eq(BATCH_FEE_AMOUNT_USD_LIMIT)) {
        const tx = yield contract.setBatchFeeAmountUSDLimit(BATCH_FEE_AMOUNT_USD_LIMIT, txOverrides);
        yield tx.wait(1);
        console.log(`Batch: the current fee amount in USD limit: ${currentFeeAmountUSDLimit.toString()}, have been replaced by: ${BATCH_FEE_AMOUNT_USD_LIMIT.toString()}. ($1 = 1e8)`);
    }
});
exports.updateBatchPaymentFeeAmountUSDLimit = updateBatchPaymentFeeAmountUSDLimit;
/**
 * Updates the address of a Native or ERC20 fee proxy stored within a Native or ERC20 fee conversion contract.
 * @param contract A contract using chainlink: EthConversionProxy | Erc20ConversionProxy.
 * @param network The network used.
 * @param txOverrides information related to gas fees. Increase their values if needed.
 * @param proxyType The type of the proxy fee.
 * @param version The version of the fee proxy to use, the last one by default.
 */
const updatePaymentFeeProxyAddress = (contract, network, txOverrides, proxyType, version) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    let proxyAddress;
    let currentAddress;
    if (proxyType === 'native') {
        proxyAddress = artifacts.ethereumFeeProxyArtifact.getAddress(network, version);
        currentAddress = yield contract.paymentProxy();
    }
    else {
        proxyAddress = artifacts.erc20FeeProxyArtifact.getAddress(network, version);
        currentAddress = yield contract.paymentProxy();
    }
    if (currentAddress.toLocaleLowerCase() !== proxyAddress.toLocaleLowerCase()) {
        const tx = yield contract.updateConversionProxyAddress(proxyAddress, txOverrides);
        yield tx.wait();
        console.log(`${proxyType} conversion proxy: the current address ${currentAddress} has been replaced by: ${proxyAddress}`);
    }
});
exports.updatePaymentFeeProxyAddress = updatePaymentFeeProxyAddress;
/**
 * Update the address of a proxy used by batch conversion contract.
 * @param contract BatchConversionPayments contract.
 * @param network The network used.
 * @param txOverrides information related to gas fees. Increase their values if needed.
 * @param proxyName The name of the fee proxy to update.
 */
const updateBatchConversionProxy = (contract, network, txOverrides, proxyName) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    let proxyAddress;
    let batchSetProxy;
    let currentAddress;
    switch (proxyName) {
        case 'native':
            proxyAddress = artifacts.ethereumFeeProxyArtifact.getAddress(network);
            batchSetProxy = yield contract.setPaymentNativeProxy;
            currentAddress = yield contract.paymentNativeProxy();
            break;
        case 'nativeConversion':
            proxyAddress = artifacts.ethConversionArtifact.getAddress(network);
            batchSetProxy = yield contract.setPaymentNativeConversionProxy;
            currentAddress = yield contract.paymentNativeConversionProxy();
            break;
        case 'erc20':
            proxyAddress = artifacts.erc20FeeProxyArtifact.getAddress(network);
            batchSetProxy = yield contract.setPaymentErc20Proxy;
            currentAddress = yield contract.paymentErc20Proxy();
            break;
        case 'erc20Conversion':
            proxyAddress = artifacts.erc20ConversionProxy.getAddress(network);
            batchSetProxy = yield contract.setPaymentErc20ConversionProxy;
            currentAddress = yield contract.paymentErc20ConversionProxy();
            break;
        case 'chainlinkConversionPath':
            proxyAddress = artifacts.chainlinkConversionPath.getAddress(network);
            batchSetProxy = yield contract.setChainlinkConversionPath;
            currentAddress = yield contract.chainlinkConversionPath();
            break;
    }
    if (currentAddress.toLocaleLowerCase() !== proxyAddress.toLocaleLowerCase()) {
        const tx = yield batchSetProxy(proxyAddress, txOverrides);
        yield tx.wait(1);
        console.log(`${proxyName}: the current address ${currentAddress} has been replaced by: ${proxyAddress}`);
    }
});
exports.updateBatchConversionProxy = updateBatchConversionProxy;
/**
 * Update the native and the USD addresses used by batch conversion contract.
 * @param contract BatchConversionPayments contract.
 * @param NativeAddress The address of native token, eg: ETH.
 * @param USDAddress The address of USD token.
 * @param txOverrides information related to gas fees. Increase their values if needed.
 */
const updateNativeAndUSDAddress = (contract, NativeAddress, USDAddress, txOverrides) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const currentUSDAddress = (yield contract.USDAddress()).toLocaleLowerCase();
    const currentNativeAddress = (yield contract.NativeAddress()).toLocaleLowerCase();
    if (currentNativeAddress !== NativeAddress.toLocaleLowerCase() ||
        currentUSDAddress !== USDAddress.toLocaleLowerCase()) {
        const tx = yield contract.setNativeAndUSDAddress(NativeAddress, USDAddress, txOverrides);
        yield tx.wait(1);
        console.log(`Batch: the current NativeAddress: ${currentNativeAddress}, have been replaced by: ${NativeAddress}`);
        console.log(`Batch: the current USDAddress: ${currentUSDAddress}, have been replaced by: ${USDAddress}`);
    }
});
exports.updateNativeAndUSDAddress = updateNativeAndUSDAddress;
/**
 * Update the native token hash used by a contract.
 * @param contract contract to be updated.
 * @param nativeTokenHash The address of native token, eg: ETH.
 * @param txOverrides information related to gas fees. Increase their values if needed.
 */
const updateNativeTokenHash = (contractType, contract, nativeTokenHash, txOverrides) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const currentNativeTokenHash = (yield contract.nativeTokenHash()).toLocaleLowerCase();
    if (currentNativeTokenHash !== nativeTokenHash.toLocaleLowerCase()) {
        const tx = yield contract.updateNativeTokenHash(nativeTokenHash, txOverrides);
        yield tx.wait(1);
        console.log(`${contractType}: the current NativeTokenHash: ${currentNativeTokenHash}, have been replaced by: ${nativeTokenHash}`);
    }
});
exports.updateNativeTokenHash = updateNativeTokenHash;
/**
 * Gets the signer and gas fees information.
 * @param network The network used.
 * @param hre Hardhat runtime environment.
 * @returns An object:
 * - The signer
 * - txOverrides, with gas fee information
 */
const getSignerAndGasFees = (network, hre) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    let provider;
    if (network === 'celo') {
        provider = (0, utils_3.getCeloProvider)();
    }
    else {
        provider = (0, utils_3.getDefaultProvider)(network);
    }
    const signer = new hre.ethers.Wallet(hre.config.xdeploy.signer).connect(provider);
    const txOverrides = (yield (0, utils_3.isEip1559Supported)(provider))
        ? yield (0, utils_3.estimateGasFees)({ provider })
        : {};
    return {
        signer,
        txOverrides,
    };
});
exports.getSignerAndGasFees = getSignerAndGasFees;
//# sourceMappingURL=adminTasks.js.map