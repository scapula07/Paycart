"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployWithCreate2FromList = exports.deployOneWithCreate2 = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("./utils");
const xdeployer_1 = require("./xdeployer");
const constructor_args_1 = require("./constructor-args");
const contract_setup_1 = require("./contract-setup");
const currency_1 = require("@requestnetwork/currency");
// Deploys, set up the contracts and returns the address
const deployOneWithCreate2 = (deploymentParams, hre) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    if (!hre.config.xdeploy.networks || hre.config.xdeploy.networks.length === 0) {
        throw new Error('Invalid networks');
    }
    // Deploy the contract on several network through xdeployer
    const deploymentResult = yield (0, xdeployer_1.xdeploy)(deploymentParams, hre);
    hre.config.xdeploy.networks.forEach((network, i) => {
        if (deploymentResult[i].deployed) {
            console.log(`${deploymentParams.contract} successfully deployed:`);
            console.log(`         On network:        ${network}`);
            console.log(`         At address:        ${deploymentResult[i].address}`);
            console.log(`         At block:          ${deploymentResult[i].receipt.blockNumber}`);
        }
        else {
            if ((0, utils_1.isContractDeployed)(deploymentParams.contract, network, deploymentResult[i].address)) {
                console.log(`${deploymentParams.contract} already deployed:`);
                console.log(`         On network:        ${network}`);
                console.log(`         At address:        ${deploymentResult[i].address}`);
            }
            else {
                console.log(`${deploymentParams.contract} has not been deployed:`);
                console.log(`         On network:        ${network}`);
                console.log(`         Error:             ${deploymentResult[i].error}`);
                console.log(`         Hint:              Check admin wallet balance and that your artifacts are up to date`);
            }
        }
    });
    return deploymentResult[0].address;
});
exports.deployOneWithCreate2 = deployOneWithCreate2;
const deployWithCreate2FromList = (hre) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    for (const contract of utils_1.create2ContractDeploymentList) {
        switch (contract) {
            case 'EthereumProxy':
            case 'ERC20FeeProxy':
            case 'EthereumFeeProxy': {
                const constructorArgs = (0, constructor_args_1.getConstructorArgs)(contract);
                yield (0, exports.deployOneWithCreate2)({ contract, constructorArgs }, hre);
                break;
            }
            case 'ChainlinkConversionPath': {
                const constructorArgs = (0, constructor_args_1.getConstructorArgs)(contract);
                const address = yield (0, exports.deployOneWithCreate2)({ contract, constructorArgs }, hre);
                yield (0, contract_setup_1.setupChainlinkConversionPath)(address, hre);
                break;
            }
            case 'EthConversionProxy': {
                const constructorArgs = (0, constructor_args_1.getConstructorArgs)(contract);
                const address = yield (0, exports.deployOneWithCreate2)({ contract, constructorArgs }, hre);
                yield (0, contract_setup_1.setupETHConversionProxy)(address, hre);
                break;
            }
            case 'Erc20ConversionProxy': {
                const constructorArgs = (0, constructor_args_1.getConstructorArgs)(contract);
                const address = yield (0, exports.deployOneWithCreate2)({ contract, constructorArgs }, hre);
                yield (0, contract_setup_1.setupErc20ConversionProxy)(address, hre);
                break;
            }
            case 'ERC20SwapToPay': {
                const constructorArgs = (0, constructor_args_1.getConstructorArgs)(contract);
                const address = yield (0, exports.deployOneWithCreate2)({ contract, constructorArgs }, hre);
                yield (0, contract_setup_1.setupERC20SwapToPay)(address, hre);
                break;
            }
            case 'ERC20SwapToConversion': {
                const constructorArgs = (0, constructor_args_1.getConstructorArgs)(contract);
                const address = yield (0, exports.deployOneWithCreate2)({ contract, constructorArgs }, hre);
                yield (0, contract_setup_1.setupERC20SwapToConversion)(address, hre);
                break;
            }
            case 'ERC20EscrowToPay':
            case 'ERC20TransferableReceivable': {
                const network = hre.config.xdeploy.networks[0];
                currency_1.EvmChains.assertChainSupported(network);
                const constructorArgs = (0, constructor_args_1.getConstructorArgs)(contract, network);
                yield (0, exports.deployOneWithCreate2)({ contract, constructorArgs }, hre);
                break;
            }
            case 'BatchConversionPayments': {
                const network = hre.config.xdeploy.networks[0];
                currency_1.EvmChains.assertChainSupported(network);
                const constructorArgs = (0, constructor_args_1.getConstructorArgs)(contract, network);
                const address = yield (0, exports.deployOneWithCreate2)({ contract, constructorArgs }, hre);
                yield (0, contract_setup_1.setupBatchConversionPayments)(address, hre);
                break;
            }
            // Other cases to add when necessary
            default:
                throw new Error(`The contract ${contract} is not to be deployed using the CREATE2 scheme`);
        }
    }
});
exports.deployWithCreate2FromList = deployWithCreate2FromList;
//# sourceMappingURL=deploy.js.map