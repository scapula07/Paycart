"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeCreate2DeploymentAddressesFromList = exports.computeCreate2DeploymentAddress = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("../src/lib");
const utils_1 = require("./utils");
const constructor_args_1 = require("./constructor-args");
const currency_1 = require("@requestnetwork/currency");
// Deploys, set up the contracts
function computeCreate2DeploymentAddress(deploymentParams, hre) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            if (!hre.config.xdeploy.salt) {
                throw new Error('Missing salt');
            }
            if (!hre.config.xdeploy.deployerAddress) {
                throw new Error('Missing deployer address');
            }
            const provider = new hre.ethers.providers.JsonRpcProvider('https://api.avax.network/ext/bc/C/rpc');
            const RequestDeployer = lib_1.requestDeployer.connect('avalanche', provider);
            const ContractToDeploy = yield hre.ethers.getContractFactory(deploymentParams.contract);
            let initcode;
            if (deploymentParams.constructorArgs) {
                initcode = yield ContractToDeploy.getDeployTransaction(...deploymentParams.constructorArgs);
            }
            else {
                initcode = yield ContractToDeploy.getDeployTransaction();
            }
            if (!initcode || !initcode.data) {
                throw new Error('Invalid initcode - check your contract and arguments');
            }
            const computedAddress = yield RequestDeployer.computeAddressWithDeployer(hre.ethers.utils.id(hre.config.xdeploy.salt), hre.ethers.utils.keccak256(initcode.data), hre.config.xdeploy.deployerAddress);
            return computedAddress;
        }
        catch (e) {
            throw new Error(e.toString());
        }
    });
}
exports.computeCreate2DeploymentAddress = computeCreate2DeploymentAddress;
const computeCreate2DeploymentAddressesFromList = (hre) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const chain = hre.network.name;
    currency_1.EvmChains.assertChainSupported(chain);
    yield Promise.all(utils_1.create2ContractDeploymentList.map((contract) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        let address;
        switch (contract) {
            case 'EthereumProxy':
            case 'EthereumFeeProxy':
            case 'EthConversionProxy':
            case 'ERC20FeeProxy':
            case 'Erc20ConversionProxy':
            case 'ERC20EscrowToPay':
            case 'BatchConversionPayments':
            case 'ERC20SwapToConversion':
            case 'ERC20TransferableReceivable': {
                try {
                    const constructorArgs = (0, constructor_args_1.getConstructorArgs)(contract, chain);
                    address = yield computeCreate2DeploymentAddress({ contract, constructorArgs }, hre);
                    console.log(`${contract.padEnd(36, ' ')}${address}`);
                }
                catch (e) {
                    console.warn(`ERROR computing address of ${contract}: ${e}`);
                }
                break;
            }
            // Other cases to add when necessary
            default:
                throw new Error(`The contrat ${contract} is not to be deployed using the CREATE2 scheme`);
        }
    })));
});
exports.computeCreate2DeploymentAddressesFromList = computeCreate2DeploymentAddressesFromList;
//# sourceMappingURL=compute-one-address.js.map