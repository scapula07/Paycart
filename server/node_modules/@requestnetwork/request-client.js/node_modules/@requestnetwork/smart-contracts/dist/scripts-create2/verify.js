"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VerifyCreate2FromList = exports.verifyOne = void 0;
const tslib_1 = require("tslib");
const compute_one_address_1 = require("./compute-one-address");
const constructor_args_1 = require("./constructor-args");
const utils_1 = require("./utils");
const currency_1 = require("@requestnetwork/currency");
const verifyOne = (contractAddress, deploymentParams, hre) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    try {
        yield hre.run('verify:verify', {
            address: contractAddress,
            constructorArguments: deploymentParams.constructorArgs,
        });
    }
    catch (err) {
        console.log(err);
    }
});
exports.verifyOne = verifyOne;
function VerifyCreate2FromList(hre) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            /**
             * Introduces a delay between each verification
             * Prevents reaching the API call limit
             */
            const delay = () => {
                return new Promise((resolve) => {
                    setTimeout(resolve, 250);
                });
            };
            let address;
            for (const contract of utils_1.create2ContractDeploymentList) {
                try {
                    yield delay();
                    switch (contract) {
                        case 'ChainlinkConversionPath':
                        case 'EthereumProxy':
                        case 'EthereumFeeProxy':
                        case 'EthConversionProxy':
                        case 'ERC20FeeProxy':
                        case 'ERC20SwapToPay':
                        case 'ERC20SwapToConversion':
                        case 'Erc20ConversionProxy':
                        case 'ERC20EscrowToPay':
                        case 'BatchConversionPayments':
                        case 'ERC20TransferableReceivable': {
                            const network = hre.config.xdeploy.networks[0];
                            currency_1.EvmChains.assertChainSupported(network);
                            const constructorArgs = (0, constructor_args_1.getConstructorArgs)(contract, network);
                            address = yield (0, compute_one_address_1.computeCreate2DeploymentAddress)({ contract, constructorArgs }, hre);
                            yield (0, exports.verifyOne)(address, { contract, constructorArgs }, hre);
                            break;
                        }
                        // Other cases to add when necessary
                        default:
                            throw new Error(`The contract ${contract} is not to be deployed using the CREATE2 scheme`);
                    }
                }
                catch (err) {
                    console.warn(err);
                }
            }
        }
        catch (e) {
            console.error(e);
        }
    });
}
exports.VerifyCreate2FromList = VerifyCreate2FromList;
//# sourceMappingURL=verify.js.map