import { ethers, Signer, providers, BigNumber, BigNumberish, ContractTransaction } from 'ethers';
import { ClientTypes, ExtensionTypes, RequestLogicTypes } from '@requestnetwork/types';
/** @constant MAX_ALLOWANCE set to the max uint256 value */
export declare const MAX_ALLOWANCE: ethers.BigNumber;
/**
 * Thrown when the library does not support a payment blockchain network.
 */
export declare class UnsupportedCurrencyNetwork extends Error {
    networkName?: string | undefined;
    constructor(networkName?: string | undefined);
}
/**
 * Utility to get the default window.ethereum provider, or throws an error.
 */
export declare function getProvider(): providers.Web3Provider;
/**
 * Utility to get a network provider, depending on the request's currency network.
 * Will throw an error if the network isn't mainnet, rinkeby, or goerli
 */
export declare function getNetworkProvider(request: ClientTypes.IRequestData): providers.Provider;
/**
 * Utility to return a signer from a provider.
 * @param signerOrProvider the provider, or signer. If Signer, it will simply be returned directly
 * @param address optionally, the address to retrieve the signer for.
 */
export declare function getSigner(signerOrProvider?: providers.Provider | Signer, address?: string): Signer;
/**
 * Utility to access the payment address, reference,
 * and optional feeAmount, feeAddress, expectedFlowRate, expectedStartDate
 * of a Request.
 */
export declare function getRequestPaymentValues(request: ClientTypes.IRequestData): {
    paymentAddress: string;
    paymentReference?: string;
    feeAmount?: string;
    feeAddress?: string;
    expectedFlowRate?: string;
    expectedStartDate?: string;
    tokensAccepted?: string[];
    maxRateTimespan?: string;
    network?: string;
    version: string;
};
export declare function getPaymentExtensionVersion(request: ClientTypes.IRequestData): string;
/**
 * @param pn It contains the payment network extension
 * @param currency It contains the currency information
 */
export declare const getProxyNetwork: (pn: ExtensionTypes.IState, currency: RequestLogicTypes.ICurrency) => string;
/**
 * @param request The request to pay
 * @return An object that contains the payment network extension and the currency information
 */
export declare function getPnAndNetwork(request: ClientTypes.IRequestData): {
    paymentNetwork: ExtensionTypes.IState<any>;
    network: string;
};
/**
 * @param request The request to pay
 * @param getDeploymentInformation The function to get the proxy address
 * @param version The version has to be set to get batch conversion proxy
 */
export declare const getProxyAddress: (request: ClientTypes.IRequestData, getDeploymentInformation: (network: string, version: string) => {
    address: string;
} | null, version?: string | undefined) => string;
/**
 * Utility to validate a request currency and payment details against a paymentNetwork.
 */
export declare function validateRequest(request: ClientTypes.IRequestData, paymentNetworkId: ExtensionTypes.PAYMENT_NETWORK_ID): void;
/**
 * Validates the amount and fee parameters for an ERC20 Fee Proxy based request.
 * @param request to validate
 * @param amount optionally, the custom amount to pay
 * @param feeAmountOverride optionally, the custom fee amount
 * @param paymentNetwork defaults to ERC20 Fee Proxy contract
 */
export declare function validateErc20FeeProxyRequest(request: ClientTypes.IRequestData, amount?: BigNumberish, feeAmountOverride?: BigNumberish, paymentNetwork?: ExtensionTypes.PAYMENT_NETWORK_ID): void;
/**
 * Validates the parameters for an ERC20 Fee Proxy payment.
 * @param request to validate
 * @param tokenAddress token address to pay with
 * @param amount optionally, the custom amount to pay
 * @param feeAmountOverride optionally, the custom fee amount
 */
export declare function validateConversionFeeProxyRequest(request: ClientTypes.IRequestData, path: string[], amount?: BigNumberish, feeAmountOverride?: BigNumberish): void;
/**
 * Computes the amount to pay.
 * If `amount` is specified, it will return it.
 * Otherwise, it will return the amount left to pay in the request.
 *
 * @param request the request to pay
 * @param amount the optional amount to pay.
 */
export declare function getAmountToPay(request: ClientTypes.IRequestData, amount?: BigNumberish): BigNumber;
/**
 * Compare 2 payment networks type and version in request's extension
 * and throw an exception if they are different
 * @param pn The payment network extension
 * @param request The request to pay
 */
export declare function comparePnTypeAndVersion(pn: ExtensionTypes.IState | undefined, request: ClientTypes.IRequestData): void;
/**
 * Revoke ERC20 approval of a token for a given `spenderAddress`
 */
export declare function revokeErc20Approval(spenderAddress: string, paymentTokenAddress: string, signerOrProvider?: providers.Provider | Signer): Promise<ContractTransaction>;
//# sourceMappingURL=utils.d.ts.map