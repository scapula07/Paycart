"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRequestErc20ApprovalWithSwapNeeded = exports.isRequestErc20ApprovalWithoutSwapNeeded = exports.isRequestErc20ApprovalNeeded = exports.encodeRequestErc20ApprovalWithSwap = exports.encodeRequestErc20ApprovalWithoutSwap = exports.encodeRequestErc20ApprovalWithSwapIfNeeded = exports.encodeRequestErc20ApprovalWithoutSwapIfNeeded = exports.encodeRequestErc20Approval = exports.encodeRequestErc20ApprovalIfNeeded = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const erc20_1 = require("./erc20");
const types_1 = require("@requestnetwork/types");
const conversion_erc20_1 = require("./conversion-erc20");
const swap_erc20_1 = require("./swap-erc20");
const swap_conversion_erc20_1 = require("./swap-conversion-erc20");
const payment_detection_1 = require("@requestnetwork/payment-detection");
/**
 * For a given request and user, encode an approval transaction if it is needed.
 * @param request the request
 * @param provider generic provider
 * @param from the user who will pay the request
 * @param options specific to the request payment (conversion, swapping, ...)
 */
function encodeRequestErc20ApprovalIfNeeded(request, provider, from, options) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        if (options && options.swap) {
            return encodeRequestErc20ApprovalWithSwapIfNeeded(request, provider, from, options);
        }
        else {
            return encodeRequestErc20ApprovalWithoutSwapIfNeeded(request, provider, from, options);
        }
    });
}
exports.encodeRequestErc20ApprovalIfNeeded = encodeRequestErc20ApprovalIfNeeded;
/**
 * For a given request, encode an approval transaction.
 * @param request the request
 * @param provider generic provider
 * @param options specific to the request payment (conversion, ...)
 */
function encodeRequestErc20Approval(request, provider, options) {
    if (options && options.swap) {
        return encodeRequestErc20ApprovalWithSwap(request, provider, options);
    }
    else {
        return encodeRequestErc20ApprovalWithoutSwap(request, provider, options);
    }
}
exports.encodeRequestErc20Approval = encodeRequestErc20Approval;
/**
 * For a given request and user, encode an approval transaction if it is needed when swap is not used.
 * @param request the request
 * @param provider generic provider
 * @param from user who will pay the request
 * @param options specific to the request payment (conversion, swapping, ...)
 */
function encodeRequestErc20ApprovalWithoutSwapIfNeeded(request, provider, from, options) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        if (yield isRequestErc20ApprovalWithoutSwapNeeded(request, provider, from, options)) {
            return encodeRequestErc20ApprovalWithoutSwap(request, provider, options);
        }
    });
}
exports.encodeRequestErc20ApprovalWithoutSwapIfNeeded = encodeRequestErc20ApprovalWithoutSwapIfNeeded;
/**
 * For a given request and user, encode an approval transaction if it is needed when swap is used.
 * @param request the request
 * @param provider generic provider
 * @param from user who will pay the request
 * @param options specific to the request payment (conversion, swapping, ...)
 */
function encodeRequestErc20ApprovalWithSwapIfNeeded(request, provider, from, options) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        if (!options || !options.swap) {
            throw new Error('No swap options');
        }
        if (yield isRequestErc20ApprovalWithSwapNeeded(request, provider, from, options)) {
            return encodeRequestErc20ApprovalWithSwap(request, provider, options);
        }
    });
}
exports.encodeRequestErc20ApprovalWithSwapIfNeeded = encodeRequestErc20ApprovalWithSwapIfNeeded;
/**
 * For a given request, encode an approval transaction when swap is not used.
 * @param request the request
 * @param provider generic provider
 * @param options specific to the request payment (conversion, ...)
 */
function encodeRequestErc20ApprovalWithoutSwap(request, provider, options) {
    var _a, _b, _c, _d;
    const paymentNetwork = (_a = (0, payment_detection_1.getPaymentNetworkExtension)(request)) === null || _a === void 0 ? void 0 : _a.id;
    const overrides = (options === null || options === void 0 ? void 0 : options.overrides) ? options.overrides : undefined;
    switch (paymentNetwork) {
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_PROXY_CONTRACT:
            return (0, erc20_1.prepareApproveErc20)(request, provider, overrides, (_b = options === null || options === void 0 ? void 0 : options.approval) === null || _b === void 0 ? void 0 : _b.amount);
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT:
            return (0, erc20_1.prepareApproveErc20)(request, provider, overrides, (_c = options === null || options === void 0 ? void 0 : options.approval) === null || _c === void 0 ? void 0 : _c.amount);
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY: {
            if (!options ||
                !options.conversion ||
                !options.conversion.currency ||
                options.conversion.currency.type !== types_1.RequestLogicTypes.CURRENCY.ERC20) {
                throw new Error('Conversion settings missing');
            }
            return (0, conversion_erc20_1.prepareApproveErc20ForProxyConversion)(request, options.conversion.currency.value, provider, overrides, (_d = options === null || options === void 0 ? void 0 : options.approval) === null || _d === void 0 ? void 0 : _d.amount);
        }
    }
}
exports.encodeRequestErc20ApprovalWithoutSwap = encodeRequestErc20ApprovalWithoutSwap;
/**
 * For a given request, encode an approval transaction when swap is used.
 * @param request the request
 * @param provider generic provider
 * @param options specific to the request payment (conversion, swapping, ...)
 */
function encodeRequestErc20ApprovalWithSwap(request, provider, options) {
    var _a, _b, _c;
    const paymentNetwork = (_a = (0, payment_detection_1.getPaymentNetworkExtension)(request)) === null || _a === void 0 ? void 0 : _a.id;
    const overrides = (options === null || options === void 0 ? void 0 : options.overrides) ? options.overrides : undefined;
    switch (paymentNetwork) {
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT:
            if (options && options.swap) {
                return (0, swap_erc20_1.prepareApprovalErc20ForSwapToPay)(request, options.swap.path[0], provider, overrides, (_b = options.approval) === null || _b === void 0 ? void 0 : _b.amount);
            }
            else {
                throw new Error('No swap options');
            }
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY: {
            if (!options ||
                !options.conversion ||
                !options.conversion.currency ||
                options.conversion.currency.type !== types_1.RequestLogicTypes.CURRENCY.ERC20) {
                throw new Error('Conversion settings missing');
            }
            if (options.swap) {
                return (0, swap_conversion_erc20_1.prepareApprovalErc20ForSwapWithConversionToPay)(request, options.swap.path[0], provider, overrides, (_c = options.approval) === null || _c === void 0 ? void 0 : _c.amount);
            }
            else {
                throw new Error('No swap options');
            }
        }
        default:
            return;
    }
}
exports.encodeRequestErc20ApprovalWithSwap = encodeRequestErc20ApprovalWithSwap;
/**
 * Check if for a given request and user, an approval transaction is needed.
 * @param request the request
 * @param provider generic provider
 * @param from user who will make the payment
 * @param options specific to the request payment (conversion, ...)
 */
function isRequestErc20ApprovalNeeded(request, provider, from, options) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        if (options && options.swap) {
            return isRequestErc20ApprovalWithSwapNeeded(request, provider, from, options);
        }
        return isRequestErc20ApprovalWithoutSwapNeeded(request, provider, from, options);
    });
}
exports.isRequestErc20ApprovalNeeded = isRequestErc20ApprovalNeeded;
/**
 * Check if for a given request and user, an approval transaction is needed when swap is not used.
 * @param request the request
 * @param provider generic provider
 * @param from user who will make the payment
 * @param options specific to the request payment (conversion, ...)
 */
function isRequestErc20ApprovalWithoutSwapNeeded(request, provider, from, options) {
    var _a;
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const paymentNetwork = (_a = (0, payment_detection_1.getPaymentNetworkExtension)(request)) === null || _a === void 0 ? void 0 : _a.id;
        switch (paymentNetwork) {
            case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_PROXY_CONTRACT:
                if (!(yield (0, erc20_1.hasErc20Approval)(request, from))) {
                    return true;
                }
                break;
            case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT:
                if (!(yield (0, erc20_1.hasErc20Approval)(request, from))) {
                    return true;
                }
                break;
            case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY: {
                if (!options ||
                    !options.conversion ||
                    !options.conversion.currency ||
                    options.conversion.currency.type !== types_1.RequestLogicTypes.CURRENCY.ERC20) {
                    throw new Error('Conversion settings missing');
                }
                const amount = options.conversion.maxToSpend
                    ? options.conversion.maxToSpend
                    : ethers_1.BigNumber.from(0);
                if (!(yield (0, conversion_erc20_1.hasErc20ApprovalForProxyConversion)(request, from, options.conversion.currency.value, provider, amount))) {
                    return true;
                }
                break;
            }
        }
        return false;
    });
}
exports.isRequestErc20ApprovalWithoutSwapNeeded = isRequestErc20ApprovalWithoutSwapNeeded;
/**
 * Check if for a given request and user, an approval transaction is needed when swap is used.
 * @param request the request
 * @param provider generic provider
 * @param from user who will make the payment
 * @param options specific to the request payment (conversion, swapping, ...)
 */
function isRequestErc20ApprovalWithSwapNeeded(request, provider, from, options) {
    var _a;
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const paymentNetwork = (_a = (0, payment_detection_1.getPaymentNetworkExtension)(request)) === null || _a === void 0 ? void 0 : _a.id;
        switch (paymentNetwork) {
            case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT:
                if (options && options.swap) {
                    if (!(yield (0, swap_erc20_1.hasApprovalErc20ForSwapToPay)(request, from, options.swap.path[0], provider, options.swap.maxInputAmount))) {
                        return true;
                    }
                }
                else {
                    throw new Error('No swap options');
                }
                break;
            case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY: {
                if (!options ||
                    !options.conversion ||
                    !options.conversion.currency ||
                    options.conversion.currency.type !== types_1.RequestLogicTypes.CURRENCY.ERC20) {
                    throw new Error('Conversion settings missing');
                }
                if (options.swap) {
                    const amount = options.swap.maxInputAmount
                        ? options.swap.maxInputAmount
                        : ethers_1.BigNumber.from(0);
                    if (!(yield (0, swap_conversion_erc20_1.hasErc20ApprovalForSwapWithConversion)(request, from, options.swap.path[0], provider, amount))) {
                        return true;
                    }
                }
                else {
                    throw new Error('No swap options');
                }
                break;
            }
        }
        return false;
    });
}
exports.isRequestErc20ApprovalWithSwapNeeded = isRequestErc20ApprovalWithSwapNeeded;
//# sourceMappingURL=encoder-approval.js.map