"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareAnyToErc20ProxyPaymentTransaction = exports.checkRequestAndGetPathAndCurrency = exports.encodePayAnyToErc20ProxyRequest = exports.payAnyToErc20ProxyRequest = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const currency_1 = require("@requestnetwork/currency");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const types_1 = require("@requestnetwork/smart-contracts/types");
const types_2 = require("@requestnetwork/types");
const utils_1 = require("./utils");
const payment_detection_2 = require("@requestnetwork/payment-detection");
/**
 * Processes a transaction to pay a request with an ERC20 currency that is different from the request currency (eg. fiat).
 * The payment is made by the ERC20 Conversion fee proxy contract.
 * @param request The request to pay
 * @param signerOrProvider The Web3 provider, or signer. Defaults to window.ethereum.
 * @param paymentSettings The payment settings
 * @param amount Optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param feeAmount Optionally, the fee amount to pay. Defaults to the fee amount.
 * @param overrides Optionally, override default transaction values, like gas.
 */
function payAnyToErc20ProxyRequest(request, signerOrProvider = (0, utils_1.getProvider)(), paymentSettings, amount, feeAmount, overrides) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const { data, to, value } = prepareAnyToErc20ProxyPaymentTransaction(request, paymentSettings, amount, feeAmount);
        const signer = (0, utils_1.getSigner)(signerOrProvider);
        return signer.sendTransaction(Object.assign({ data, to, value }, overrides));
    });
}
exports.payAnyToErc20ProxyRequest = payAnyToErc20ProxyRequest;
/**
 * Encodes the call to pay a request with an ERC20 currency that is different from the request currency (eg. fiat).
 * The payment is made by the ERC20 Conversion fee proxy contract.
 * @param request The request to pay
 * @param paymentSettings The payment settings
 * @param amount Optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param feeAmountOverride Optionally, the fee amount to pay. Defaults to the fee amount of the request.
 */
function encodePayAnyToErc20ProxyRequest(request, paymentSettings, amount, feeAmountOverride) {
    const { path, paymentReference, paymentAddress, feeAddress, maxRateTimespan, amountToPay, feeToPay, } = prepareAnyToErc20Arguments(request, paymentSettings, amount, feeAmountOverride);
    const proxyContract = types_1.Erc20ConversionProxy__factory.createInterface();
    return proxyContract.encodeFunctionData('transferFromWithReferenceAndFee', [
        paymentAddress,
        amountToPay,
        path,
        `0x${paymentReference}`,
        feeToPay,
        feeAddress || ethers_1.constants.AddressZero,
        ethers_1.BigNumber.from(paymentSettings.maxToSpend),
        maxRateTimespan || 0,
    ]);
}
exports.encodePayAnyToErc20ProxyRequest = encodePayAnyToErc20ProxyRequest;
/**
 * It checks paymentSettings values, it get request's path and requestCurrency
 * @param request The request to pay
 * @param paymentSettings The payment settings
 * @param amount Optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param feeAmountOverride Optionally, the fee amount to pay. Defaults to the fee amount of the request.
 */
function checkRequestAndGetPathAndCurrency(request, paymentSettings, amount, feeAmountOverride) {
    if (!paymentSettings.currency) {
        throw new Error('currency must be provided in the paymentSettings');
    }
    if (!paymentSettings.currency.network) {
        throw new Error('Cannot pay with a currency missing a network');
    }
    const currencyManager = paymentSettings.currencyManager || currency_1.CurrencyManager.getDefault();
    const requestCurrency = currencyManager.fromStorageCurrency(request.currencyInfo);
    if (!requestCurrency) {
        throw new currency_1.UnsupportedCurrencyError(request.currencyInfo);
    }
    const paymentCurrency = currencyManager.fromStorageCurrency(paymentSettings.currency);
    if (!paymentCurrency) {
        throw new currency_1.UnsupportedCurrencyError(paymentSettings.currency);
    }
    if (paymentCurrency.type !== types_2.RequestLogicTypes.CURRENCY.ERC20) {
        throw new Error(`Payment currency must be an ERC20`);
    }
    // Compute the path automatically
    const path = currencyManager.getConversionPath(requestCurrency, paymentCurrency, paymentCurrency.network);
    if (!path) {
        throw new Error(`Impossible to find a conversion path between from ${requestCurrency.symbol} (${requestCurrency.hash}) to ${paymentCurrency.symbol} (${paymentCurrency.hash})`);
    }
    // Check request
    (0, utils_1.validateConversionFeeProxyRequest)(request, path, amount, feeAmountOverride);
    return { path, requestCurrency };
}
exports.checkRequestAndGetPathAndCurrency = checkRequestAndGetPathAndCurrency;
/**
 * Prepares all necessaries arguments required to encode an any-to-erc20 request
 * @param request The request to pay
 * @param paymentSettings The payment settings
 * @param amount Optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param feeAmountOverride Optionally, the fee amount to pay. Defaults to the fee amount of the request.
 */
function prepareAnyToErc20Arguments(request, paymentSettings, amount, feeAmountOverride) {
    const { path, requestCurrency } = checkRequestAndGetPathAndCurrency(request, paymentSettings, amount, feeAmountOverride);
    const { paymentReference, paymentAddress, feeAddress, feeAmount, maxRateTimespan } = (0, utils_1.getRequestPaymentValues)(request);
    if (!paymentReference) {
        throw new Error('paymentReference is missing');
    }
    const amountToPay = (0, payment_detection_2.padAmountForChainlink)((0, utils_1.getAmountToPay)(request, amount), requestCurrency);
    const feeToPay = (0, payment_detection_2.padAmountForChainlink)(feeAmountOverride || feeAmount || 0, requestCurrency);
    return {
        path,
        paymentReference,
        paymentAddress,
        feeAddress,
        maxRateTimespan,
        amountToPay,
        feeToPay,
    };
}
function prepareAnyToErc20ProxyPaymentTransaction(request, paymentSettings, amount, feeAmount) {
    if (!paymentSettings.currency) {
        throw new Error('currency must be provided in the paymentSettings');
    }
    if (!paymentSettings.currency.network) {
        throw new Error('Cannot pay with a currency missing a network');
    }
    const encodedTx = encodePayAnyToErc20ProxyRequest(request, paymentSettings, amount, feeAmount);
    const proxyAddress = (0, utils_1.getProxyAddress)(request, payment_detection_1.AnyToERC20PaymentDetector.getDeploymentInformation);
    return {
        data: encodedTx,
        to: proxyAddress,
        value: 0,
    };
}
exports.prepareAnyToErc20ProxyPaymentTransaction = prepareAnyToErc20ProxyPaymentTransaction;
//# sourceMappingURL=any-to-erc20-proxy.js.map