"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeRequestPaymentWithSwap = exports.encodeRequestPaymentWithStream = exports.encodeRequestPaymentWithoutSwap = exports.encodeRequestPayment = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const erc20_proxy_1 = require("./erc20-proxy");
const erc20_fee_proxy_1 = require("./erc20-fee-proxy");
const any_to_erc20_proxy_1 = require("./any-to-erc20-proxy");
const swap_erc20_fee_proxy_1 = require("./swap-erc20-fee-proxy");
const swap_any_to_erc20_1 = require("./swap-any-to-erc20");
const eth_proxy_1 = require("./eth-proxy");
const eth_fee_proxy_1 = require("./eth-fee-proxy");
const any_to_eth_proxy_1 = require("./any-to-eth-proxy");
const erc777_stream_1 = require("./erc777-stream");
/**
 * Encodes a transaction to pay a Request in generic way. ERC777 stream excepted.
 * @param request the request data to pay
 * @param provider the Web3 provider. Defaults to window.ethereum.
 * @param options optionally, the request payment options.
 */
function encodeRequestPayment(request, provider, options) {
    if (options && options.swap) {
        return encodeRequestPaymentWithSwap(request, provider, options);
    }
    else {
        return encodeRequestPaymentWithoutSwap(request, options);
    }
}
exports.encodeRequestPayment = encodeRequestPayment;
/**
 * Encodes a transaction to pay a Request in generic way without swap.
 * @param request the request data to pay
 * @param options optionally, the request payment options.
 */
function encodeRequestPaymentWithoutSwap(request, options) {
    var _a;
    const paymentNetwork = (_a = (0, payment_detection_1.getPaymentNetworkExtension)(request)) === null || _a === void 0 ? void 0 : _a.id;
    const amount = (options === null || options === void 0 ? void 0 : options.amount) ? options.amount : undefined;
    const feeAmount = (options === null || options === void 0 ? void 0 : options.feeAmount) ? options.feeAmount : undefined;
    const overrides = (options === null || options === void 0 ? void 0 : options.overrides) ? options.overrides : {};
    switch (paymentNetwork) {
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_PROXY_CONTRACT:
            return Object.assign(Object.assign({}, (0, erc20_proxy_1.prepareErc20ProxyPaymentTransaction)(request, amount)), overrides);
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT:
            return Object.assign(Object.assign({}, (0, erc20_fee_proxy_1.prepareErc20FeeProxyPaymentTransaction)(request, amount, feeAmount)), overrides);
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY: {
            if (!options ||
                !options.conversion ||
                !options.conversion.currency ||
                options.conversion.currency.type !== types_1.RequestLogicTypes.CURRENCY.ERC20) {
                throw new Error('Conversion settings missing');
            }
            return Object.assign(Object.assign({}, (0, any_to_erc20_proxy_1.prepareAnyToErc20ProxyPaymentTransaction)(request, options.conversion, amount, feeAmount)), overrides);
        }
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ETH_PROXY: {
            if (!options ||
                !options.conversion ||
                !options.conversion.currency ||
                options.conversion.currency.type !== types_1.RequestLogicTypes.CURRENCY.ETH) {
                throw new Error('Conversion settings missing');
            }
            return Object.assign(Object.assign({}, (0, any_to_eth_proxy_1.prepareAnyToEthProxyPaymentTransaction)(request, options.conversion, amount, feeAmount)), overrides);
        }
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ETH_INPUT_DATA:
            return Object.assign(Object.assign({}, (0, eth_proxy_1.prepareEthProxyPaymentTransaction)(request, amount)), overrides);
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ETH_FEE_PROXY_CONTRACT:
            return Object.assign(Object.assign({}, (0, eth_fee_proxy_1.prepareEthFeeProxyPaymentTransaction)(request, amount, feeAmount)), overrides);
        default:
            throw new Error('Payment network not found');
    }
}
exports.encodeRequestPaymentWithoutSwap = encodeRequestPaymentWithoutSwap;
/**
 * Encodes a transaction to pay a Request with ERC777 stream.
 * @param request the request data to pay
 * @param provider the Web3 provider. Defaults to window.ethereum.
 * @param options optionally, the request payment options.
 */
function encodeRequestPaymentWithStream(request, provider, options) {
    var _a;
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const paymentNetwork = (_a = (0, payment_detection_1.getPaymentNetworkExtension)(request)) === null || _a === void 0 ? void 0 : _a.id;
        const overrides = (options === null || options === void 0 ? void 0 : options.overrides) ? options.overrides : {};
        switch (paymentNetwork) {
            case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC777_STREAM:
                return Object.assign(Object.assign({}, (yield (0, erc777_stream_1.prepareErc777StreamPaymentTransaction)(request, provider))), overrides);
            default:
                throw new Error(`Payment network {paymentNetwork} does not support stream`);
        }
    });
}
exports.encodeRequestPaymentWithStream = encodeRequestPaymentWithStream;
/**
 * Encodes a transaction to pay a Request in generic way with swap.
 * @param request the request data to pay
 * @param provider the Web3 provider. Defaults to window.ethereum.
 * @param options optionally, the request payment options.
 */
function encodeRequestPaymentWithSwap(request, provider, options) {
    var _a;
    const paymentNetwork = (_a = (0, payment_detection_1.getPaymentNetworkExtension)(request)) === null || _a === void 0 ? void 0 : _a.id;
    const amount = (options === null || options === void 0 ? void 0 : options.amount) ? options.amount : undefined;
    const feeAmount = (options === null || options === void 0 ? void 0 : options.feeAmount) ? options.feeAmount : undefined;
    const overrides = (options === null || options === void 0 ? void 0 : options.overrides) ? options.overrides : undefined;
    switch (paymentNetwork) {
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT:
            if (options && options.swap) {
                return (0, swap_erc20_fee_proxy_1.prepareSwapToPayErc20FeeRequest)(request, provider, options.swap, {
                    amount,
                    feeAmount,
                    overrides,
                });
            }
            else {
                throw new Error('No swap options');
            }
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY: {
            if (!options ||
                !options.conversion ||
                !options.conversion.currency ||
                options.conversion.currency.type !== types_1.RequestLogicTypes.CURRENCY.ERC20) {
                throw new Error('Conversion settings missing');
            }
            if (options.swap) {
                return (0, swap_any_to_erc20_1.prepareSwapToPayAnyToErc20Request)(request, provider, options);
            }
            else {
                throw new Error('Swap settings missing');
            }
        }
        default:
            throw new Error(`Payment network {paymentNetwork} does not support swap`);
    }
}
exports.encodeRequestPaymentWithSwap = encodeRequestPaymentWithSwap;
//# sourceMappingURL=encoder-payment.js.map