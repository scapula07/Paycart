"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeErc777OneOffPayment = exports.prepareErc777OneOffPayment = exports.encodeErc777OneOffPayment = exports.getErc777BalanceAt = exports.prepareErc777StreamPaymentTransaction = exports.encodePayErc777StreamRequest = exports.getSuperFluidFramework = exports.completeErc777StreamRequest = exports.payErc777StreamRequest = exports.USERDATA_PREFIX = exports.RESOLVER_ADDRESS = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const types_1 = require("@requestnetwork/types");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const utils_1 = require("./utils");
const sdk_core_1 = require("@superfluid-finance/sdk-core");
const erc777Artefact = require("@openzeppelin/contracts/build/contracts/IERC777.json");
exports.RESOLVER_ADDRESS = '0x913bbCFea2f347a24cfCA441d483E7CBAc8De3Db';
// Superfluid payments of requests use the generic field `userData` to index payments.
// Since it's a multi-purpose field, payments will use a fix-prefix heading the payment reference,
// in order to speed up the indexing and payment detection.
exports.USERDATA_PREFIX = '0xbeefac';
/**
 * Processes a transaction to pay an ERC777 stream Request.
 * @param request the request to pay
 * @param signer the Web3 signer. Defaults to window.ethereum.
 * @param overrides optionally, override default transaction values, like gas.
 */
function payErc777StreamRequest(request, signer, overrides) {
    var _a;
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const { data, to, value } = yield prepareErc777StreamPaymentTransaction(request, (_a = signer.provider) !== null && _a !== void 0 ? _a : (0, utils_1.getProvider)());
        return signer.sendTransaction(Object.assign({ data, to, value }, overrides));
    });
}
exports.payErc777StreamRequest = payErc777StreamRequest;
/**
 * Processes a transaction to complete an ERC777 stream paying a Request.
 * @param request the request to pay
 * @param signer the Web3 signer. Defaults to window.ethereum.
 * @param overrides optionally, override default transaction values, like gas.
 */
function completeErc777StreamRequest(request, signer, overrides) {
    var _a, _b;
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const id = (_a = (0, payment_detection_1.getPaymentNetworkExtension)(request)) === null || _a === void 0 ? void 0 : _a.id;
        if (id !== types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC777_STREAM) {
            throw new Error('Not a supported ERC777 payment network request');
        }
        (0, utils_1.validateRequest)(request, types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC777_STREAM);
        const sf = yield getSuperFluidFramework(request, (_b = signer.provider) !== null && _b !== void 0 ? _b : (0, utils_1.getProvider)());
        // FIXME: according to specs PR https://github.com/RequestNetwork/requestNetwork/pull/688
        // in file packages/advanced-logic/specs/payment-network-erc777-stream-0.1.0.md
        // Below are the SF actions to add in the BatchCall :
        // - use expectedEndDate to compute offset between stop of invoicing and stop of streaming
        // - stop fee streaming
        const streamPayOp = yield getStopStreamOp(sf, signer, request, overrides);
        const batchCall = sf.batchCall([streamPayOp]);
        return batchCall.exec(signer);
    });
}
exports.completeErc777StreamRequest = completeErc777StreamRequest;
/**
 * Encodes the call to pay a request through the ERC20 fee proxy contract, can be used with a Multisig contract.
 * @param request the request to pay
 * @param provider the Web3 provider. Defaults to window.ethereum.
 */
function getSuperFluidFramework(request, provider) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const isNetworkPrivate = request.currencyInfo.network === 'private';
        const networkName = isNetworkPrivate ? 'custom' : request.currencyInfo.network;
        return yield sdk_core_1.Framework.create({
            networkName,
            provider: provider,
            dataMode: isNetworkPrivate ? 'WEB3_ONLY' : undefined,
            resolverAddress: isNetworkPrivate ? exports.RESOLVER_ADDRESS : undefined,
            protocolReleaseVersion: isNetworkPrivate ? 'test' : undefined,
        });
    });
}
exports.getSuperFluidFramework = getSuperFluidFramework;
/**
 * Get from SuperFluid framework the operation to start paying a request.
 * @param sf the SuperFluid framework to use
 * @param request the request to pay
 */
function getStartStreamOp(sf, request) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const superToken = yield sf.loadSuperToken(request.currencyInfo.value);
        const { paymentReference, paymentAddress, expectedFlowRate } = (0, utils_1.getRequestPaymentValues)(request);
        return sf.cfaV1.createFlow({
            flowRate: expectedFlowRate !== null && expectedFlowRate !== void 0 ? expectedFlowRate : '0',
            receiver: paymentAddress,
            superToken: superToken.address,
            userData: `${exports.USERDATA_PREFIX}${paymentReference}`,
        });
    });
}
/**
 * Get from SuperFluid framework the operation to stop paying a request.
 * @param sf the SuperFluid framework to use
 * @param signer the Web3 signer. Defaults to window.ethereum.
 * @param request the request to pay
 * @param overrides optionally, override default transaction values, like gas.
 */
function getStopStreamOp(sf, signer, request, overrides) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const superToken = yield sf.loadSuperToken(request.currencyInfo.value);
        const { paymentReference, paymentAddress } = (0, utils_1.getRequestPaymentValues)(request);
        return sf.cfaV1.deleteFlow({
            superToken: superToken.address,
            sender: yield signer.getAddress(),
            receiver: paymentAddress,
            userData: `${exports.USERDATA_PREFIX}${paymentReference}`,
            overrides: overrides,
        });
    });
}
/**
 * Encodes the call to pay a request through the ERC777 SuperFluid stream contract.
 * @param request the request to pay
 * @param sf the SuperFluid framework to use
 */
function encodePayErc777StreamRequest(request, sf) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        // FIXME: according to specs PR https://github.com/RequestNetwork/requestNetwork/pull/688
        // in file packages/advanced-logic/specs/payment-network-erc777-stream-0.1.0.md
        // Below are the SF actions to add in the BatchCall:
        // - use expectedStartDate to compute offset between start of invoicing and start of streaming
        // - start fee streaming
        const streamPayOp = yield getStartStreamOp(sf, request);
        const batchCall = sf.batchCall([streamPayOp]);
        const operationStructArray = yield Promise.all(batchCall.getOperationStructArrayPromises);
        return batchCall.host.hostContract.interface.encodeFunctionData('batchCall', [
            operationStructArray,
        ]);
    });
}
exports.encodePayErc777StreamRequest = encodePayErc777StreamRequest;
/**
 * Prepare the transaction to pay a request through the ERC777 SuperFluid stream contract.
 * @param request the request to pay
 * @param provider the Web3 provider. Defaults to window.ethereum.
 */
function prepareErc777StreamPaymentTransaction(request, provider) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        (0, utils_1.validateRequest)(request, types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC777_STREAM);
        const sf = yield getSuperFluidFramework(request, provider);
        const encodedTx = yield encodePayErc777StreamRequest(request, sf);
        return {
            data: encodedTx,
            to: sf.host.hostContract.address,
            value: 0,
        };
    });
}
exports.prepareErc777StreamPaymentTransaction = prepareErc777StreamPaymentTransaction;
/**
 * Gets the future ERC777 balance of an address, based on the request currency information
 * @param request the request that contains currency information
 * @param address the address to check
 * @param timestamp the time to calculate the balance at
 * @param provider the web3 provider. Defaults to Etherscan
 */
function getErc777BalanceAt(request, address, timestamp, provider = (0, utils_1.getNetworkProvider)(request)) {
    var _a;
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const id = (_a = (0, payment_detection_1.getPaymentNetworkExtension)(request)) === null || _a === void 0 ? void 0 : _a.id;
        if (id !== types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC777_STREAM) {
            throw new Error('Not a supported ERC777 payment network request');
        }
        (0, utils_1.validateRequest)(request, types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC777_STREAM);
        const sf = yield getSuperFluidFramework(request, provider);
        const superToken = yield sf.loadSuperToken(request.currencyInfo.value);
        const realtimeBalance = yield superToken.realtimeBalanceOf({
            providerOrSigner: provider,
            account: address,
            timestamp,
        });
        return realtimeBalance.availableBalance;
    });
}
exports.getErc777BalanceAt = getErc777BalanceAt;
/**
 * Encode the transaction data for a one off payment of ERC777 Tokens
 * @param request to encode the payment for
 * @param amount the amount to be sent
 * @returns the encoded transaction data
 */
const encodeErc777OneOffPayment = (request, amount) => {
    var _a;
    const id = (_a = (0, payment_detection_1.getPaymentNetworkExtension)(request)) === null || _a === void 0 ? void 0 : _a.id;
    if (id !== types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC777_STREAM) {
        throw new Error('Not a supported ERC777 payment network request');
    }
    (0, utils_1.validateRequest)(request, types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC777_STREAM);
    const { paymentReference, paymentAddress } = (0, utils_1.getRequestPaymentValues)(request);
    const erc777 = ethers_1.ethers.ContractFactory.getInterface(erc777Artefact.abi);
    return erc777.encodeFunctionData('send', [paymentAddress, amount, `0x${paymentReference}`]);
};
exports.encodeErc777OneOffPayment = encodeErc777OneOffPayment;
/**
 * Prepare the transaction for a one payment for the user to sign
 * @param request to prepare the transaction for
 * @param amount the amount to be sent
 * @returns the prepared transaction
 */
const prepareErc777OneOffPayment = (request, amount) => {
    return {
        data: (0, exports.encodeErc777OneOffPayment)(request, amount),
        to: request.currencyInfo.value,
        value: 0,
    };
};
exports.prepareErc777OneOffPayment = prepareErc777OneOffPayment;
/**
 * Make an ERC777 payment
 * @param request associated to the payment
 * @param amount the amount to be sent
 * @param signer the transaction signer
 * @returns the transaction result
 */
const makeErc777OneOffPayment = (request, amount, signer, overrides) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    const preparedTx = (0, exports.prepareErc777OneOffPayment)(request, amount);
    return signer.sendTransaction(Object.assign(Object.assign({}, preparedTx), overrides));
});
exports.makeErc777OneOffPayment = makeErc777OneOffPayment;
//# sourceMappingURL=erc777-stream.js.map