"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareEthProxyPaymentTransaction = exports.encodePayEthProxyRequest = exports.payEthProxyRequest = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const types_2 = require("@requestnetwork/smart-contracts/types");
const utils_1 = require("./utils");
/**
 * Processes a transaction to pay an ETH Request with the proxy contract.
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param overrides optionally, override default transaction values, like gas.
 */
function payEthProxyRequest(request, signerOrProvider = (0, utils_1.getProvider)(), amount, overrides) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const signer = (0, utils_1.getSigner)(signerOrProvider);
        const { data, to, value } = prepareEthProxyPaymentTransaction(request, amount);
        return signer.sendTransaction(Object.assign({ data, to, value }, overrides));
    });
}
exports.payEthProxyRequest = payEthProxyRequest;
/**
 * Encodes the call to pay a request through the ETH proxy contract, can be used with a Multisig contract.
 * @param request request to pay
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 */
function encodePayEthProxyRequest(request) {
    (0, utils_1.validateRequest)(request, types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ETH_INPUT_DATA);
    const { paymentReference, paymentAddress } = (0, utils_1.getRequestPaymentValues)(request);
    const proxyContract = types_2.EthereumProxy__factory.createInterface();
    return proxyContract.encodeFunctionData('transferWithReference', [
        paymentAddress,
        `0x${paymentReference}`,
    ]);
}
exports.encodePayEthProxyRequest = encodePayEthProxyRequest;
function prepareEthProxyPaymentTransaction(request, amount) {
    (0, utils_1.validateRequest)(request, types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ETH_INPUT_DATA);
    const encodedTx = encodePayEthProxyRequest(request);
    const proxyAddress = (0, utils_1.getProxyAddress)(request, (network, version) => payment_detection_1.EthInputDataPaymentDetector.getDeploymentInformation(network, version));
    const amountToPay = (0, utils_1.getAmountToPay)(request, amount);
    return {
        data: encodedTx,
        to: proxyAddress,
        value: amountToPay,
    };
}
exports.prepareEthProxyPaymentTransaction = prepareEthProxyPaymentTransaction;
//# sourceMappingURL=eth-proxy.js.map