"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareErc20FeeProxyPaymentTransaction = exports._getErc20FeeProxyPaymentUrl = exports.encodePayErc20FeeRequest = exports.payErc20FeeProxyRequest = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const smart_contracts_1 = require("@requestnetwork/smart-contracts");
const types_1 = require("@requestnetwork/smart-contracts/types");
const types_2 = require("@requestnetwork/types");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const utils_1 = require("./utils");
/**
 * Processes a transaction to pay an ERC20 Request with fees.
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param feeAmount optionally, the fee amount to pay. Defaults to the fee amount.
 * @param overrides optionally, override default transaction values, like gas.
 */
function payErc20FeeProxyRequest(request, signerOrProvider = (0, utils_1.getProvider)(), amount, feeAmount, overrides) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const { data, to, value } = prepareErc20FeeProxyPaymentTransaction(request, amount, feeAmount);
        const signer = (0, utils_1.getSigner)(signerOrProvider);
        return signer.sendTransaction(Object.assign({ data, to, value }, overrides));
    });
}
exports.payErc20FeeProxyRequest = payErc20FeeProxyRequest;
/**
 * Encodes the call to pay a request through the ERC20 fee proxy contract, can be used with a Multisig contract.
 * @param request request to pay
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param feeAmountOverride optionally, the fee amount to pay. Defaults to the fee amount of the request.
 */
function encodePayErc20FeeRequest(request, amount, feeAmountOverride) {
    (0, utils_1.validateErc20FeeProxyRequest)(request, amount, feeAmountOverride);
    const tokenAddress = request.currencyInfo.value;
    const { paymentReference, paymentAddress, feeAddress, feeAmount } = (0, utils_1.getRequestPaymentValues)(request);
    const amountToPay = (0, utils_1.getAmountToPay)(request, amount);
    const feeToPay = ethers_1.BigNumber.from(feeAmountOverride || feeAmount || 0);
    const proxyContract = types_1.ERC20FeeProxy__factory.createInterface();
    return proxyContract.encodeFunctionData('transferFromWithReferenceAndFee', [
        tokenAddress,
        paymentAddress,
        amountToPay,
        `0x${paymentReference}`,
        feeToPay,
        feeAddress || ethers_1.constants.AddressZero,
    ]);
}
exports.encodePayErc20FeeRequest = encodePayErc20FeeRequest;
/**
 * Return the EIP-681 format URL with the transaction to pay an ERC20
 * Warning: this EIP isn't widely used, be sure to test compatibility yourself.
 *
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param feeAmountOverride optionally, the fee amount to pay. Defaults to the fee amount of the request.
 */
function _getErc20FeeProxyPaymentUrl(request, amount, feeAmountOverride) {
    (0, utils_1.validateRequest)(request, types_2.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT);
    const { paymentReference, paymentAddress, feeAddress, feeAmount, version } = (0, utils_1.getRequestPaymentValues)(request);
    const contractAddress = smart_contracts_1.erc20FeeProxyArtifact.getAddress(request.currencyInfo.network, version);
    const amountToPay = (0, utils_1.getAmountToPay)(request, amount);
    const feeToPay = feeAmountOverride || ethers_1.BigNumber.from(feeAmount || 0);
    const parameters = `transferFromWithReferenceAndFee?address=${request.currencyInfo.value}&address=${paymentAddress}&uint256=${amountToPay}&bytes=${paymentReference}&uint256=${feeToPay}&address=${feeAddress}`;
    return `ethereum:${contractAddress}/${parameters}`;
}
exports._getErc20FeeProxyPaymentUrl = _getErc20FeeProxyPaymentUrl;
/**
 * Prepate the transaction to pay a request through the ERC20 fee proxy contract, can be used with a Multisig contract.
 * @param request request to pay
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param feeAmountOverride optionally, the fee amount to pay. Defaults to the fee amount of the request.
 */
function prepareErc20FeeProxyPaymentTransaction(request, amount, feeAmountOverride) {
    (0, utils_1.validateErc20FeeProxyRequest)(request, amount, feeAmountOverride);
    const encodedTx = encodePayErc20FeeRequest(request, amount, feeAmountOverride);
    const pn = (0, payment_detection_1.getPaymentNetworkExtension)(request);
    const proxyAddress = smart_contracts_1.erc20FeeProxyArtifact.getAddress(request.currencyInfo.network, pn === null || pn === void 0 ? void 0 : pn.version);
    return {
        data: encodedTx,
        to: proxyAddress,
        value: 0,
    };
}
exports.prepareErc20FeeProxyPaymentTransaction = prepareErc20FeeProxyPaymentTransaction;
//# sourceMappingURL=erc20-fee-proxy.js.map