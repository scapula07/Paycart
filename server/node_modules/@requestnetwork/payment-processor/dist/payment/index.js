"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._getPaymentUrl = exports.canSwapToPay = exports.isSolvent = exports.hasSufficientFunds = exports.swapToPayRequest = exports.encodeRequestApprovalAndPayment = exports.payRequest = exports.UnsupportedPaymentChain = exports.UnsupportedNetworkError = exports.noConversionNetworks = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const types_1 = require("@requestnetwork/types");
const btc_address_based_1 = require("./btc-address-based");
const erc20_1 = require("./erc20");
const erc20_2 = require("./erc20");
const erc777_stream_1 = require("./erc777-stream");
const eth_input_data_1 = require("./eth-input-data");
const eth_fee_proxy_1 = require("./eth-fee-proxy");
const utils_1 = require("./utils");
const any_to_erc20_proxy_1 = require("./any-to-erc20-proxy");
const any_to_eth_proxy_1 = require("./any-to-eth-proxy");
const utils_near_1 = require("./utils-near");
const encoder_approval_1 = require("./encoder-approval");
const encoder_payment_1 = require("./encoder-payment");
exports.noConversionNetworks = [
    types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC777_STREAM,
    types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_PROXY_CONTRACT,
    types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT,
    types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ETH_INPUT_DATA,
    types_1.ExtensionTypes.PAYMENT_NETWORK_ID.NATIVE_TOKEN,
];
const getPaymentNetwork = (request) => {
    var _a;
    // eslint-disable-next-line
    const id = (_a = Object.values(request.extensions).find((x) => x.type === 'payment-network')) === null || _a === void 0 ? void 0 : _a.id;
    if (types_1.TypesUtils.isPaymentNetworkId(id)) {
        return id;
    }
};
/**
 * Error thrown when the network is not supported.
 */
class UnsupportedNetworkError extends Error {
    constructor(networkName) {
        super(`Payment network ${networkName} is not supported`);
        this.networkName = networkName;
    }
}
exports.UnsupportedNetworkError = UnsupportedNetworkError;
/**
 * Error thrown when the payment currency network is not supported.
 */
class UnsupportedPaymentChain extends Error {
    constructor(currencyNetworkName) {
        super(`Payment currency network ${currencyNetworkName} is not supported`);
        this.currencyNetworkName = currencyNetworkName;
    }
}
exports.UnsupportedPaymentChain = UnsupportedPaymentChain;
/**
 * Processes a transaction to pay a Request.
 * Supported networks:
 * - ERC20_PROXY_CONTRACT
 * - ETH_INPUT_DATA
 * - ERC20_FEE_PROXY_CONTRACT
 * - ANY_TO_ERC20_PROXY
 * - ERC777_STREAM
 *
 * @throws UnsupportedNetworkError if network isn't supported for swap or payment.
 * @throws UnsupportedPaymentChain if the currency network is not supported (eg Near)
 * @param request the request to pay.
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param overrides optionally, override default transaction values, like gas.
 */
function payRequest(request, signerOrProvider = (0, utils_1.getProvider)(), amount, overrides, paymentSettings) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        throwIfNotWeb3(request);
        const signer = (0, utils_1.getSigner)(signerOrProvider);
        const paymentNetwork = getPaymentNetwork(request);
        switch (paymentNetwork) {
            case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_PROXY_CONTRACT:
            case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT:
                return (0, erc20_2.payErc20Request)(request, signer, amount, undefined, overrides);
            case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC777_STREAM:
                return (0, erc777_stream_1.payErc777StreamRequest)(request, signer);
            case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY: {
                if (!paymentSettings) {
                    throw new Error('Missing payment settings for a payment with conversion');
                }
                return (0, any_to_erc20_proxy_1.payAnyToErc20ProxyRequest)(request, signer, paymentSettings, amount, undefined, overrides);
            }
            case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ETH_PROXY: {
                if (!paymentSettings) {
                    throw new Error('Missing payment settings for a payment with conversion');
                }
                return (0, any_to_eth_proxy_1.payAnyToEthProxyRequest)(request, signer, paymentSettings, amount, undefined, overrides);
            }
            case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ETH_INPUT_DATA:
                return (0, eth_input_data_1.payEthInputDataRequest)(request, signer, amount, overrides);
            case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ETH_FEE_PROXY_CONTRACT:
                return (0, eth_fee_proxy_1.payEthFeeProxyRequest)(request, signer, amount, undefined, overrides);
            default:
                throw new UnsupportedNetworkError(paymentNetwork);
        }
    });
}
exports.payRequest = payRequest;
/**
 * Encode the transactions associated to a request
 * @param request the request to pay.
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param options encoding options
 * @returns
 */
function encodeRequestApprovalAndPayment(request, signerOrProvider, options) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const preparedTransactions = [];
        const approvalTx = yield (0, encoder_approval_1.encodeRequestErc20Approval)(request, signerOrProvider, options);
        if (approvalTx) {
            preparedTransactions.push(approvalTx);
        }
        preparedTransactions.push((0, encoder_payment_1.encodeRequestPayment)(request, signerOrProvider, options));
        return preparedTransactions;
    });
}
exports.encodeRequestApprovalAndPayment = encodeRequestApprovalAndPayment;
/**
 * Processes a transaction to pay a Request with a swap
 * Supported payment networks: ERC20_PROXY_CONTRACT, ETH_INPUT_DATA, ERC20_FEE_PROXY_CONTRACT
 *
 * @throws UnsupportedNetworkError if network isn't supported for swap or payment.
 * @throws UnsupportedPaymentChain if the currency network is not supported (eg Near)
 * @param request the request to pay.
 * @param swapSettings the information of how to swap from another payment token.
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param amount optionally, the amount to pay in request currency. Defaults to remaining amount of the request.
 * @param overrides optionally, override default transaction values, like gas.
 */
function swapToPayRequest(request, swapSettings, signerOrProvider = (0, utils_1.getProvider)(), amount, overrides) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        throwIfNotWeb3(request);
        const signer = (0, utils_1.getSigner)(signerOrProvider);
        const paymentNetwork = getPaymentNetwork(request);
        if (!canSwapToPay(request)) {
            throw new UnsupportedNetworkError(paymentNetwork);
        }
        return (0, erc20_2.payErc20Request)(request, signer, amount, undefined, overrides, swapSettings);
    });
}
exports.swapToPayRequest = swapToPayRequest;
/**
 * Verifies the address has enough funds to pay the request in its currency.
 * Only supports networks with no (on-chain) conversion.
 *
 * @throws UnsupportedNetworkError if network isn't supported
 * @param request the request to verify.
 * @param address the address holding the funds
 * @param providerOptions.provider the Web3 provider. Defaults to getDefaultProvider.
 * @param providerOptions.nearWalletConnection the Near WalletConnection
 */
function hasSufficientFunds(request, address, providerOptions) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const paymentNetwork = getPaymentNetwork(request);
        if (!paymentNetwork || !exports.noConversionNetworks.includes(paymentNetwork)) {
            throw new UnsupportedNetworkError(paymentNetwork);
        }
        if (!(providerOptions === null || providerOptions === void 0 ? void 0 : providerOptions.nearWalletConnection) && !(providerOptions === null || providerOptions === void 0 ? void 0 : providerOptions.provider)) {
            providerOptions = { provider: (0, utils_1.getNetworkProvider)(request) };
        }
        let feeAmount = 0;
        if (paymentNetwork === types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT) {
            feeAmount = request.extensions[paymentNetwork].values.feeAmount || 0;
        }
        return isSolvent(address, request.currencyInfo, ethers_1.BigNumber.from(request.expectedAmount).add(feeAmount), providerOptions);
    });
}
exports.hasSufficientFunds = hasSufficientFunds;
/**
 * Verifies the address has enough funds to pay an amount in a given currency.
 * Supported chains: EVMs and Near.
 *
 * @param fromAddress the address willing to pay
 * @param providerOptions.provider the Web3 provider. Defaults to getDefaultProvider.
 * @param providerOptions.nearWalletConnection the Near WalletConnection
 * @throws UnsupportedNetworkError if network isn't supported
 */
function isSolvent(fromAddress, currency, amount, providerOptions) {
    var _a, _b, _c, _d, _e, _f, _g;
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        // Near case
        if ((0, utils_near_1.isNearNetwork)(currency.network) && (providerOptions === null || providerOptions === void 0 ? void 0 : providerOptions.nearWalletConnection)) {
            return (0, utils_near_1.isNearAccountSolvent)(amount, providerOptions.nearWalletConnection);
        }
        // Main case (web3)
        if (!(providerOptions === null || providerOptions === void 0 ? void 0 : providerOptions.provider)) {
            throw new Error('provider missing');
        }
        const provider = providerOptions.provider;
        const ethBalance = yield provider.getBalance(fromAddress);
        const needsGas = !((_c = (_b = (_a = provider) === null || _a === void 0 ? void 0 : _a.provider) === null || _b === void 0 ? void 0 : _b.safe) === null || _c === void 0 ? void 0 : _c.safeAddress) &&
            !['Safe Multisig WalletConnect', 'Gnosis Safe Multisig'].includes((_g = (_f = (_e = (_d = provider) === null || _d === void 0 ? void 0 : _d.provider) === null || _e === void 0 ? void 0 : _e.wc) === null || _f === void 0 ? void 0 : _f._peerMeta) === null || _g === void 0 ? void 0 : _g.name);
        if (currency.type === 'ETH') {
            return ethBalance.gt(amount);
        }
        else {
            const balance = yield getCurrencyBalance(fromAddress, currency, provider);
            return (ethBalance.gt(0) || !needsGas) && ethers_1.BigNumber.from(balance).gte(amount);
        }
    });
}
exports.isSolvent = isSolvent;
/**
 * Returns the balance of a given address in a given currency.
 * @param address the address holding the funds
 * @param paymentCurrency if different from the requested currency
 * @param provider the Web3 provider. Defaults to Etherscan.
 * @throws UnsupportedNetworkError if the currency is not implemented.
 */
function getCurrencyBalance(address, paymentCurrency, provider) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        switch (paymentCurrency.type) {
            case 'ETH': {
                return provider.getBalance(address);
            }
            case 'ERC777':
            case 'ERC20': {
                return (0, erc20_1.getAnyErc20Balance)(paymentCurrency.value, address, provider);
            }
            default:
                throw new UnsupportedNetworkError(paymentCurrency.network);
        }
    });
}
/**
 * Given a request, the function gives whether swap is supported for its payment network.
 * @param request the request that accepts or not swap to payment
 */
function canSwapToPay(request) {
    const paymentNetwork = getPaymentNetwork(request);
    return (paymentNetwork !== undefined &&
        paymentNetwork === types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT);
}
exports.canSwapToPay = canSwapToPay;
/**
 * Get a payment URL, if applicable to the payment network, for a request.
 * BTC: BIP21.
 * ERC20: EIP-681. (Warning, not widely used. Some wallets may not be able to pay.)
 * ETH: EIP-681. (Warning, not widely used. Some wallets may not be able to pay.)
 * @throws UnsupportedNetworkError if the network is not supported.
 * @param request the request to pay
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 */
function _getPaymentUrl(request, amount) {
    const paymentNetwork = getPaymentNetwork(request);
    switch (paymentNetwork) {
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_PROXY_CONTRACT:
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT:
            return (0, erc20_1._getErc20PaymentUrl)(request, amount);
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ETH_INPUT_DATA:
            return (0, eth_input_data_1._getEthPaymentUrl)(request, amount);
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.BITCOIN_ADDRESS_BASED:
        case types_1.ExtensionTypes.PAYMENT_NETWORK_ID.TESTNET_BITCOIN_ADDRESS_BASED:
            return (0, btc_address_based_1.getBtcPaymentUrl)(request, amount);
        default:
            throw new UnsupportedNetworkError(paymentNetwork);
    }
}
exports._getPaymentUrl = _getPaymentUrl;
// FIXME: should also compare the signer.chainId with the request.currencyInfo.network...
const throwIfNotWeb3 = (request) => {
    var _a;
    // FIXME: there is a near web3Provider equivalent: https://github.com/aurora-is-near/near-web3-provider
    if (((_a = request.currencyInfo) === null || _a === void 0 ? void 0 : _a.network) && (0, utils_near_1.isNearNetwork)(request.currencyInfo.network)) {
        throw new UnsupportedPaymentChain(request.currencyInfo.network);
    }
};
//# sourceMappingURL=index.js.map