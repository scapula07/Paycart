import { ContractTransaction, Signer, BigNumberish, providers } from 'ethers';
import { ClientTypes, ExtensionTypes } from '@requestnetwork/types';
import { ITransactionOverrides } from './transaction-overrides';
import { ISwapSettings } from './swap-erc20-fee-proxy';
import { RequestLogicTypes } from '@requestnetwork/types';
import { WalletConnection } from 'near-api-js';
import { ICurrencyManager } from '@requestnetwork/currency';
import { IPreparedTransaction } from './prepared-transaction';
import { IRequestPaymentOptions } from './settings';
export { INearTransactionCallback } from './utils-near';
export declare const noConversionNetworks: ExtensionTypes.PAYMENT_NETWORK_ID[];
export interface IConversionPaymentSettings {
    currency?: RequestLogicTypes.ICurrency;
    maxToSpend: BigNumberish;
    currencyManager?: ICurrencyManager;
}
/**
 * Error thrown when the network is not supported.
 */
export declare class UnsupportedNetworkError extends Error {
    networkName?: string | undefined;
    constructor(networkName?: string | undefined);
}
/**
 * Error thrown when the payment currency network is not supported.
 */
export declare class UnsupportedPaymentChain extends Error {
    currencyNetworkName?: string | undefined;
    constructor(currencyNetworkName?: string | undefined);
}
/**
 * Processes a transaction to pay a Request.
 * Supported networks:
 * - ERC20_PROXY_CONTRACT
 * - ETH_INPUT_DATA
 * - ERC20_FEE_PROXY_CONTRACT
 * - ANY_TO_ERC20_PROXY
 * - ERC777_STREAM
 *
 * @throws UnsupportedNetworkError if network isn't supported for swap or payment.
 * @throws UnsupportedPaymentChain if the currency network is not supported (eg Near)
 * @param request the request to pay.
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param overrides optionally, override default transaction values, like gas.
 */
export declare function payRequest(request: ClientTypes.IRequestData, signerOrProvider?: providers.Web3Provider | Signer, amount?: BigNumberish, overrides?: ITransactionOverrides, paymentSettings?: IConversionPaymentSettings): Promise<ContractTransaction>;
/**
 * Encode the transactions associated to a request
 * @param request the request to pay.
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param options encoding options
 * @returns
 */
export declare function encodeRequestApprovalAndPayment(request: ClientTypes.IRequestData, signerOrProvider: providers.Provider, options?: IRequestPaymentOptions): Promise<IPreparedTransaction[]>;
/**
 * Processes a transaction to pay a Request with a swap
 * Supported payment networks: ERC20_PROXY_CONTRACT, ETH_INPUT_DATA, ERC20_FEE_PROXY_CONTRACT
 *
 * @throws UnsupportedNetworkError if network isn't supported for swap or payment.
 * @throws UnsupportedPaymentChain if the currency network is not supported (eg Near)
 * @param request the request to pay.
 * @param swapSettings the information of how to swap from another payment token.
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param amount optionally, the amount to pay in request currency. Defaults to remaining amount of the request.
 * @param overrides optionally, override default transaction values, like gas.
 */
export declare function swapToPayRequest(request: ClientTypes.IRequestData, swapSettings: ISwapSettings, signerOrProvider?: providers.Web3Provider | Signer, amount?: BigNumberish, overrides?: ITransactionOverrides): Promise<ContractTransaction>;
/**
 * Verifies the address has enough funds to pay the request in its currency.
 * Only supports networks with no (on-chain) conversion.
 *
 * @throws UnsupportedNetworkError if network isn't supported
 * @param request the request to verify.
 * @param address the address holding the funds
 * @param providerOptions.provider the Web3 provider. Defaults to getDefaultProvider.
 * @param providerOptions.nearWalletConnection the Near WalletConnection
 */
export declare function hasSufficientFunds(request: ClientTypes.IRequestData, address: string, providerOptions?: {
    provider?: providers.Provider;
    nearWalletConnection?: WalletConnection;
}): Promise<boolean>;
/**
 * Verifies the address has enough funds to pay an amount in a given currency.
 * Supported chains: EVMs and Near.
 *
 * @param fromAddress the address willing to pay
 * @param providerOptions.provider the Web3 provider. Defaults to getDefaultProvider.
 * @param providerOptions.nearWalletConnection the Near WalletConnection
 * @throws UnsupportedNetworkError if network isn't supported
 */
export declare function isSolvent(fromAddress: string, currency: RequestLogicTypes.ICurrency, amount: BigNumberish, providerOptions?: {
    provider?: providers.Provider;
    nearWalletConnection?: WalletConnection;
}): Promise<boolean>;
/**
 * Given a request, the function gives whether swap is supported for its payment network.
 * @param request the request that accepts or not swap to payment
 */
export declare function canSwapToPay(request: ClientTypes.IRequestData): boolean;
/**
 * Get a payment URL, if applicable to the payment network, for a request.
 * BTC: BIP21.
 * ERC20: EIP-681. (Warning, not widely used. Some wallets may not be able to pay.)
 * ETH: EIP-681. (Warning, not widely used. Some wallets may not be able to pay.)
 * @throws UnsupportedNetworkError if the network is not supported.
 * @param request the request to pay
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 */
export declare function _getPaymentUrl(request: ClientTypes.IRequestData, amount?: BigNumberish): string;
/**
 * Input of batch conversion payment processor
 * It contains requests, paymentSettings, amount and feeAmount.
 * Currently, these requests must have the same PN, version, and batchFee
 * @dev next step: paymentNetworkId could get more values options to pay Native tokens.
 */
export interface EnrichedRequest {
    paymentNetworkId: ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY | ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT;
    request: ClientTypes.IRequestData;
    paymentSettings: IConversionPaymentSettings;
    amount?: BigNumberish;
    feeAmount?: BigNumberish;
}
//# sourceMappingURL=index.d.ts.map