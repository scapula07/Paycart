"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeApproveErc20Batch = exports.prepareApproveErc20Batch = exports.approveErc20Batch = exports.hasErc20BatchApproval = exports.approveErc20BatchIfNeeded = exports.getBatchProxyAddress = exports.getBatchArgs = exports.encodePayBatchRequest = exports.prepareBatchPaymentTransaction = exports.payBatchProxyRequest = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const smart_contracts_1 = require("@requestnetwork/smart-contracts");
const types_1 = require("@requestnetwork/smart-contracts/types");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const utils_1 = require("./utils");
const eth_fee_proxy_1 = require("./eth-fee-proxy");
const erc20_1 = require("./erc20");
/**
 * ERC20 Batch Proxy payment details:
 *   batch of request with the same payment network type: ERC20
 *   batch of request with the same payment network version
 *   2 modes available: single token or multi tokens
 * It requires batch proxy's approval
 *
 * Eth Batch Proxy payment details:
 *   batch of request with the same payment network type
 *   batch of request with the same payment network version
 * -> Eth batch proxy accepts requests with 2 id: ethProxy and ethFeeProxy
 *    but only call ethFeeProxy. It can impact payment detection
 */
/**
 * Processes a transaction to pay a batch of ETH Requests with fees.
 * Requests paymentType must be "ETH" or "ERC20"
 * @param requests List of requests
 * @param version The version version of the batch proxy, which can be different from request pn version
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param batchFee Only for batch ETH: additional fee applied to a batch, between 0 and 1000, default value = 10
 * @param overrides optionally, override default transaction values, like gas.
 */
function payBatchProxyRequest(requests, version, signerOrProvider = (0, utils_1.getProvider)(), batchFee, overrides) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const { data, to, value } = prepareBatchPaymentTransaction(requests, version, batchFee);
        const signer = (0, utils_1.getSigner)(signerOrProvider);
        return signer.sendTransaction(Object.assign({ data, to, value }, overrides));
    });
}
exports.payBatchProxyRequest = payBatchProxyRequest;
/**
 * Prepate the transaction to pay a batch of requests through the batch proxy contract, can be used with a Multisig contract.
 * Requests paymentType must be "ETH" or "ERC20"
 * @param requests list of ETH requests to pay
 * @param version The version version of the batch proxy, which can be different from request pn version
 * @param batchFee additional fee applied to a batch
 */
function prepareBatchPaymentTransaction(requests, version, batchFee) {
    const encodedTx = encodePayBatchRequest(requests);
    const proxyAddress = getBatchProxyAddress(requests[0], version);
    let totalAmount = 0;
    if (requests[0].currencyInfo.type === 'ETH') {
        const { amountsToPay, feesToPay } = getBatchArgs(requests);
        const amountToPay = amountsToPay.reduce((sum, current) => sum.add(current), ethers_1.BigNumber.from(0));
        const batchFeeToPay = ethers_1.BigNumber.from(amountToPay).mul(batchFee).div(1000);
        const feeToPay = feesToPay.reduce((sum, current) => sum.add(current), ethers_1.BigNumber.from(batchFeeToPay));
        totalAmount = amountToPay.add(feeToPay).toNumber();
    }
    return {
        data: encodedTx,
        to: proxyAddress,
        value: totalAmount,
    };
}
exports.prepareBatchPaymentTransaction = prepareBatchPaymentTransaction;
/**
 * Encodes the call to pay a batch of requests through the ERC20Bacth or ETHBatch proxy contract,
 * can be used with a Multisig contract.
 * @param requests list of ECR20 requests to pay
 * @dev pn version of the requests is checked to avoid paying with two differents proxies (e.g: erc20proxy v1 and v2)
 */
function encodePayBatchRequest(requests) {
    const { tokenAddresses, paymentAddresses, amountsToPay, paymentReferences, feesToPay, feeAddressUsed, } = getBatchArgs(requests);
    const proxyContract = types_1.BatchPayments__factory.createInterface();
    if (requests[0].currencyInfo.type === 'ERC20') {
        let isMultiTokens = false;
        for (let i = 0; tokenAddresses.length; i++) {
            if (tokenAddresses[0] !== tokenAddresses[i]) {
                isMultiTokens = true;
                break;
            }
        }
        const pn = (0, payment_detection_1.getPaymentNetworkExtension)(requests[0]);
        for (let i = 0; i < requests.length; i++) {
            (0, utils_1.validateErc20FeeProxyRequest)(requests[i]);
            (0, utils_1.comparePnTypeAndVersion)(pn, requests[i]);
        }
        if (isMultiTokens) {
            return proxyContract.encodeFunctionData('batchERC20PaymentsMultiTokensWithReference', [
                tokenAddresses,
                paymentAddresses,
                amountsToPay,
                paymentReferences,
                feesToPay,
                feeAddressUsed,
            ]);
        }
        else {
            return proxyContract.encodeFunctionData('batchERC20PaymentsWithReference', [
                tokenAddresses[0],
                paymentAddresses,
                amountsToPay,
                paymentReferences,
                feesToPay,
                feeAddressUsed,
            ]);
        }
    }
    else {
        tokenAddresses;
        return proxyContract.encodeFunctionData('batchEthPaymentsWithReference', [
            paymentAddresses,
            amountsToPay,
            paymentReferences,
            feesToPay,
            feeAddressUsed,
        ]);
    }
}
exports.encodePayBatchRequest = encodePayBatchRequest;
/**
 * Get batch arguments
 * @param requests List of requests
 * @param forcedPaymentType It force to considere the request as an ETH or an ERC20 payment
 * @returns List with the args required by batch Eth and Erc20 functions,
 * @dev tokenAddresses returned is for batch Erc20 functions
 */
function getBatchArgs(requests, forcedPaymentType) {
    const tokenAddresses = [];
    const paymentAddresses = [];
    const amountsToPay = [];
    const paymentReferences = [];
    const feesToPay = [];
    let feeAddressUsed = ethers_1.constants.AddressZero;
    const paymentType = forcedPaymentType !== null && forcedPaymentType !== void 0 ? forcedPaymentType : requests[0].currencyInfo.type;
    for (let i = 0; i < requests.length; i++) {
        if (paymentType === 'ETH') {
            (0, eth_fee_proxy_1.validateEthFeeProxyRequest)(requests[i]);
        }
        else if (paymentType === 'ERC20') {
            (0, utils_1.validateErc20FeeProxyRequest)(requests[i]);
        }
        else {
            throw new Error(`paymentType ${paymentType} is not supported for batch payment`);
        }
        const tokenAddress = requests[i].currencyInfo.value;
        const { paymentReference, paymentAddress, feeAddress, feeAmount } = (0, utils_1.getRequestPaymentValues)(requests[i]);
        tokenAddresses.push(tokenAddress);
        paymentAddresses.push(paymentAddress);
        amountsToPay.push((0, utils_1.getAmountToPay)(requests[i]));
        paymentReferences.push(`0x${paymentReference}`);
        feesToPay.push(ethers_1.BigNumber.from(feeAmount || 0));
        feeAddressUsed = feeAddress || ethers_1.constants.AddressZero;
    }
    return {
        tokenAddresses,
        paymentAddresses,
        amountsToPay,
        paymentReferences,
        feesToPay,
        feeAddressUsed,
    };
}
exports.getBatchArgs = getBatchArgs;
/**
 * Get Batch contract Address
 * @param request The request to pay
 * @param version The version version of the batch proxy, which can be different from request pn version
 */
function getBatchProxyAddress(request, version) {
    const pn = (0, payment_detection_1.getPaymentNetworkExtension)(request);
    const pnId = pn === null || pn === void 0 ? void 0 : pn.id;
    if (!pnId) {
        throw new Error('No payment network Id');
    }
    if (!request.currencyInfo.network) {
        throw new Error('No currency network');
    }
    const proxyAddress = smart_contracts_1.batchPaymentsArtifact.getAddress(request.currencyInfo.network, version);
    if (!proxyAddress) {
        throw new Error(`No deployment found for network ${pn}, version ${pn === null || pn === void 0 ? void 0 : pn.version}`);
    }
    return proxyAddress;
}
exports.getBatchProxyAddress = getBatchProxyAddress;
/**
 * ERC20 Batch proxy approvals methods
 */
/**
 * Processes the approval transaction of the targeted ERC20 with batch proxy.
 * @param request The request to pay
 * @param account The account that will be used to pay the request
 * @param version The version version of the batch proxy, which can be different from request pn version
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param overrides optionally, override default transaction values, like gas.
 */
function approveErc20BatchIfNeeded(request, account, version, signerOrProvider = (0, utils_1.getProvider)(), overrides) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        if (!(yield hasErc20BatchApproval(request, account, version, signerOrProvider))) {
            return approveErc20Batch(request, version, (0, utils_1.getSigner)(signerOrProvider), overrides);
        }
    });
}
exports.approveErc20BatchIfNeeded = approveErc20BatchIfNeeded;
/**
 * Checks if the batch proxy has the necessary allowance from a given account
 * to pay a given request with ERC20 batch
 * @param request The request to pay
 * @param account The account that will be used to pay the request
 * @param version The version version of the batch proxy, which can be different from request pn version
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 */
function hasErc20BatchApproval(request, account, version, signerOrProvider = (0, utils_1.getProvider)()) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        return (0, erc20_1.checkErc20Allowance)(account, getBatchProxyAddress(request, version), signerOrProvider, request.currencyInfo.value, request.expectedAmount);
    });
}
exports.hasErc20BatchApproval = hasErc20BatchApproval;
/**
 * Processes the transaction to approve the batch proxy to spend signer's tokens to pay
 * the request in its payment currency. Can be used with a Multisig contract.
 * @param request The request to pay
 * @param version The version version of the batch proxy, which can be different from request pn version
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param overrides optionally, override default transaction values, like gas.
 */
function approveErc20Batch(request, version, signerOrProvider = (0, utils_1.getProvider)(), overrides) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const preparedTx = prepareApproveErc20Batch(request, version, signerOrProvider, overrides);
        const signer = (0, utils_1.getSigner)(signerOrProvider);
        const tx = yield signer.sendTransaction(preparedTx);
        return tx;
    });
}
exports.approveErc20Batch = approveErc20Batch;
/**
 * Prepare the transaction to approve the proxy to spend signer's tokens to pay
 * the request in its payment currency. Can be used with a Multisig contract.
 * @param request The request to pay
 * @param version The version version of the batch proxy, which can be different from request pn version
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param overrides optionally, override default transaction values, like gas.
 */
function prepareApproveErc20Batch(request, version, signerOrProvider = (0, utils_1.getProvider)(), overrides) {
    const encodedTx = encodeApproveErc20Batch(request, version, signerOrProvider);
    const tokenAddress = request.currencyInfo.value;
    return Object.assign({ data: encodedTx, to: tokenAddress, value: 0 }, overrides);
}
exports.prepareApproveErc20Batch = prepareApproveErc20Batch;
/**
 * Encodes the transaction to approve the batch proxy to spend signer's tokens to pay
 * the request in its payment currency. Can be used with a Multisig contract.
 * @param request The request to pay
 * @param version The version version of the batch proxy, which can be different from request pn version
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 */
function encodeApproveErc20Batch(request, version, signerOrProvider = (0, utils_1.getProvider)()) {
    const proxyAddress = getBatchProxyAddress(request, version);
    return (0, erc20_1.encodeApproveAnyErc20)(request.currencyInfo.value, proxyAddress, (0, utils_1.getSigner)(signerOrProvider));
}
exports.encodeApproveErc20Batch = encodeApproveErc20Batch;
//# sourceMappingURL=batch-proxy.js.map