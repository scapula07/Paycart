"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeApproveErc20BatchConversion = exports.prepareApproveErc20BatchConversion = exports.approveErc20BatchConversion = exports.hasErc20BatchConversionApproval = exports.approveErc20BatchConversionIfNeeded = exports.getBatchConversionProxyAddress = exports.prepareBatchConversionPaymentTransaction = exports.payBatchConversionProxyRequest = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const smart_contracts_1 = require("@requestnetwork/smart-contracts");
const types_1 = require("@requestnetwork/smart-contracts/types");
const types_2 = require("@requestnetwork/types");
const utils_1 = require("./utils");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const any_to_erc20_proxy_1 = require("./any-to-erc20-proxy");
const erc20_1 = require("./erc20");
const CURRENCY = types_2.RequestLogicTypes.CURRENCY;
/**
 * Processes a transaction to pay a batch of requests with an ERC20 currency
 * that can be different from the request currency (eg. fiat)
 * The payment is made through ERC20 or ERC20Conversion proxies
 * It can be used with a Multisig contract
 * @param enrichedRequests List of EnrichedRequests to pay.
 * @param signerOrProvider The Web3 provider, or signer. Defaults to window.ethereum.
 * @param options It contains 3 paramaters required to do a batch payments:
 *  - conversion: It must contains the currencyManager.
 *  - skipFeeUSDLimit: It checks the value of batchFeeAmountUSDLimit of the batch proxy deployed.
 * Setting the value to true skips the USD fee limit, and reduces gas consumption.
 *  - version: The version of the batch conversion proxy.
 * @param overrides Optionally, override default transaction values, like gas.
 * @dev We only implement batchPayments using two ERC20 functions:
 *      batchMultiERC20ConversionPayments, and batchMultiERC20Payments.
 */
function payBatchConversionProxyRequest(enrichedRequests, signerOrProvider = (0, utils_1.getProvider)(), options, overrides) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const { data, to, value } = prepareBatchConversionPaymentTransaction(enrichedRequests, options);
        const signer = (0, utils_1.getSigner)(signerOrProvider);
        return signer.sendTransaction(Object.assign({ data, to, value }, overrides));
    });
}
exports.payBatchConversionProxyRequest = payBatchConversionProxyRequest;
/**
 * Prepares a transaction to pay a batch of requests with an ERC20 currency
 * that can be different from the request currency (eg. fiat).
 * It can be used with a Multisig contract.
 * @param enrichedRequests List of EnrichedRequests to pay.
 * @param options It contains 3 paramaters required to prepare a batch payments:
 *  - conversion: It must contains the currencyManager.
 *  - skipFeeUSDLimit: It checks the value of batchFeeAmountUSDLimit of the batch proxy deployed.
 * Setting the value to true skips the USD fee limit, and reduces gas consumption.
 *  - version: The version of the batch conversion proxy.
 */
function prepareBatchConversionPaymentTransaction(enrichedRequests, options) {
    const encodedTx = encodePayBatchConversionRequest(enrichedRequests, options.skipFeeUSDLimit, options.conversion);
    const proxyAddress = getBatchConversionProxyAddress(enrichedRequests[0].request, options.version);
    return {
        data: encodedTx,
        to: proxyAddress,
        value: 0,
    };
}
exports.prepareBatchConversionPaymentTransaction = prepareBatchConversionPaymentTransaction;
/**
 * Encodes a transaction to pay a batch of requests with an ERC20 currency
 * that can be different from the request currency (eg. fiat).
 * It can be used with a Multisig contract.
 * @param enrichedRequests List of EnrichedRequests to pay.
 * @param skipFeeUSDLimit It checks the value of batchFeeAmountUSDLimit of the batch proxy deployed.
 * Setting the value to true skips the USD fee limit, and reduces gas consumption.
 */
function encodePayBatchConversionRequest(enrichedRequests, skipFeeUSDLimit = false, conversion) {
    if (!(conversion && conversion.currencyManager)) {
        throw 'the conversion object or the currencyManager is undefined';
    }
    const { feeAddress } = (0, utils_1.getRequestPaymentValues)(enrichedRequests[0].request);
    const { network } = (0, utils_1.getPnAndNetwork)(enrichedRequests[0].request);
    let firstConversionRequestExtension;
    let firstNoConversionRequestExtension;
    const ERC20NoConversionRequestDetails = [];
    const ERC20ConversionRequestDetails = [];
    // fill ERC20ConversionRequestDetails and ERC20NoConversionRequestDetails lists
    for (const enrichedRequest of enrichedRequests) {
        const request = enrichedRequest.request;
        if (enrichedRequest.paymentNetworkId === types_2.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY) {
            enrichedRequest.paymentSettings.currencyManager = conversion.currencyManager;
            firstConversionRequestExtension =
                firstConversionRequestExtension !== null && firstConversionRequestExtension !== void 0 ? firstConversionRequestExtension : (0, payment_detection_1.getPaymentNetworkExtension)(request);
            (0, utils_1.comparePnTypeAndVersion)(firstConversionRequestExtension, request);
            if (![CURRENCY.ERC20, CURRENCY.ISO4217].includes(request.currencyInfo.type)) {
                throw new Error(`wrong request currencyInfo type`);
            }
            ERC20ConversionRequestDetails.push(getInputERC20ConversionRequestDetail(enrichedRequest));
        }
        else if (enrichedRequest.paymentNetworkId ===
            types_2.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT) {
            firstNoConversionRequestExtension =
                firstNoConversionRequestExtension !== null && firstNoConversionRequestExtension !== void 0 ? firstNoConversionRequestExtension : (0, payment_detection_1.getPaymentNetworkExtension)(request);
            // isERC20Currency is checked within getBatchArgs function
            (0, utils_1.comparePnTypeAndVersion)(firstNoConversionRequestExtension, request);
            if (!(request.currencyInfo.type === CURRENCY.ERC20)) {
                throw new Error(`wrong request currencyInfo type`);
            }
            ERC20NoConversionRequestDetails.push(getInputERC20NoConversionRequestDetail(request));
        }
        if (network !== (0, utils_1.getPnAndNetwork)(request).network)
            throw new Error('All the requests must have the same network');
    }
    const metaDetails = [];
    if (ERC20ConversionRequestDetails.length > 0) {
        // Add ERC20 conversion payments
        metaDetails.push({
            paymentNetworkId: types_2.PaymentTypes.BATCH_PAYMENT_NETWORK_ID.BATCH_MULTI_ERC20_CONVERSION_PAYMENTS,
            requestDetails: ERC20ConversionRequestDetails,
        });
    }
    if (ERC20NoConversionRequestDetails.length > 0) {
        // Add multi ERC20 no-conversion payments
        metaDetails.push({
            paymentNetworkId: types_2.PaymentTypes.BATCH_PAYMENT_NETWORK_ID.BATCH_MULTI_ERC20_PAYMENTS,
            requestDetails: ERC20NoConversionRequestDetails,
        });
    }
    const pathsToUSD = getUSDPathsForFeeLimit([...ERC20ConversionRequestDetails, ...ERC20NoConversionRequestDetails], network, skipFeeUSDLimit, conversion.currencyManager);
    const proxyContract = types_1.BatchConversionPayments__factory.createInterface();
    return proxyContract.encodeFunctionData('batchPayments', [
        metaDetails,
        pathsToUSD,
        feeAddress || ethers_1.constants.AddressZero,
    ]);
}
/**
 * Get the ERC20 no conversion input requestDetail from a request, that can be used by the batch contract.
 * @param request The request to pay.
 */
function getInputERC20NoConversionRequestDetail(request) {
    (0, utils_1.validateErc20FeeProxyRequest)(request);
    const tokenAddress = request.currencyInfo.value;
    const { paymentReference, paymentAddress, feeAmount } = (0, utils_1.getRequestPaymentValues)(request);
    return {
        recipient: paymentAddress,
        requestAmount: (0, utils_1.getAmountToPay)(request).toString(),
        path: [tokenAddress],
        paymentReference: `0x${paymentReference}`,
        feeAmount: (feeAmount === null || feeAmount === void 0 ? void 0 : feeAmount.toString()) || '0',
        maxToSpend: '0',
        maxRateTimespan: '0',
    };
}
/**
 * Get the ERC20 conversion input requestDetail from an enriched request, that can be used by the batch contract.
 * @param enrichedRequest The enrichedRequest to pay.
 */
function getInputERC20ConversionRequestDetail(enrichedRequest) {
    var _a;
    const { path, requestCurrency } = (0, any_to_erc20_proxy_1.checkRequestAndGetPathAndCurrency)(enrichedRequest.request, enrichedRequest.paymentSettings);
    const { paymentReference, paymentAddress, feeAmount, maxRateTimespan } = (0, utils_1.getRequestPaymentValues)(enrichedRequest.request);
    const requestAmount = ethers_1.BigNumber.from(enrichedRequest.request.expectedAmount).sub(((_a = enrichedRequest.request.balance) === null || _a === void 0 ? void 0 : _a.balance) || 0);
    const padRequestAmount = (0, payment_detection_1.padAmountForChainlink)(requestAmount, requestCurrency);
    const padFeeAmount = (0, payment_detection_1.padAmountForChainlink)(feeAmount || 0, requestCurrency);
    return {
        recipient: paymentAddress,
        requestAmount: padRequestAmount.toString(),
        path: path,
        paymentReference: `0x${paymentReference}`,
        feeAmount: padFeeAmount.toString(),
        maxToSpend: enrichedRequest.paymentSettings.maxToSpend.toString(),
        maxRateTimespan: maxRateTimespan || '0',
    };
}
/**
 * Get the list of conversion paths from tokens to the USD address through currencyManager.
 * If there is no path to USD for a token, it goes to the next token.
 * @param requestDetails List of ERC20 requests to pay.
 * @param network The network targeted.
 * @param skipFeeUSDLimit Setting the value to true skips the USD fee limit, it skips the path calculation.
 * @param currencyManager The currencyManager used to get token conversion paths to USD.
 */
function getUSDPathsForFeeLimit(requestDetails, network, skipFeeUSDLimit, currencyManager) {
    if (skipFeeUSDLimit)
        return [];
    const USDCurrency = currencyManager.fromSymbol('USD');
    if (!USDCurrency)
        throw 'Cannot find the USD currency information';
    // get a list of unique token addresses
    const tokenAddresses = requestDetails
        .map((rd) => rd.path[rd.path.length - 1])
        .filter((value, index, self) => self.indexOf(value) === index);
    // get the token currencies and keep the one that are defined
    const tokenCurrencies = tokenAddresses
        .map((token) => currencyManager.fromAddress(token, network))
        .filter((value) => !!value);
    // get all the conversion paths to USD when it exists and return it
    return tokenCurrencies
        .map((t) => currencyManager.getConversionPath(t, USDCurrency, network))
        .filter((value) => !!value);
}
/**
 * @param network The network targeted.
 * @param version The version of the batch conversion proxy, the last one by default.
 * @returns
 */
function getBatchDeploymentInformation(network, version) {
    return { address: smart_contracts_1.batchConversionPaymentsArtifact.getAddress(network, version) };
}
/**
 * Gets batch conversion contract Address.
 * @param request The request for an ERC20 payment with/out conversion.
 * @param version The version of the batch conversion proxy.
 */
function getBatchConversionProxyAddress(request, version) {
    return (0, utils_1.getProxyAddress)(request, getBatchDeploymentInformation, version);
}
exports.getBatchConversionProxyAddress = getBatchConversionProxyAddress;
/**
 * ERC20 Batch conversion proxy approvals methods
 */
/**
 * Processes the approval transaction of the targeted ERC20 with batch conversion proxy.
 * @param request The request for an ERC20 payment with/out conversion.
 * @param account The account that will be used to pay the request
 * @param signerOrProvider The Web3 provider, or signer. Defaults to window.ethereum.
 * @param paymentSettings The payment settings are necessary for conversion payment approval.
 * @param version The version of the batch conversion proxy, which can be different from request pn version.
 * @param overrides Optionally, override default transaction values, like gas.
 */
function approveErc20BatchConversionIfNeeded(request, account, signerOrProvider = (0, utils_1.getProvider)(), paymentSettings, version, overrides) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        if (!(yield hasErc20BatchConversionApproval(request, account, signerOrProvider, paymentSettings, version))) {
            return approveErc20BatchConversion(request, (0, utils_1.getSigner)(signerOrProvider), paymentSettings, version, overrides);
        }
    });
}
exports.approveErc20BatchConversionIfNeeded = approveErc20BatchConversionIfNeeded;
/**
 * Checks if the batch conversion proxy has the necessary allowance from a given account
 * to pay a given request with ERC20 batch conversion proxy
 * @param request The request for an ERC20 payment with/out conversion.
 * @param account The account that will be used to pay the request
 * @param signerOrProvider The Web3 provider, or signer. Defaults to window.ethereum.
 * @param paymentSettings The payment settings are necessary for conversion payment approval.
 * @param version The version of the batch conversion proxy.
 */
function hasErc20BatchConversionApproval(request, account, signerOrProvider = (0, utils_1.getProvider)(), paymentSettings, version) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        return (0, erc20_1.checkErc20Allowance)(account, getBatchConversionProxyAddress(request, version), signerOrProvider, getTokenAddress(request, paymentSettings), request.expectedAmount);
    });
}
exports.hasErc20BatchConversionApproval = hasErc20BatchConversionApproval;
/**
 * Processes the transaction to approve the batch conversion proxy to spend signer's tokens to pay
 * the request in its payment currency. Can be used with a Multisig contract.
 * @param request The request for an ERC20 payment with/out conversion.
 * @param signerOrProvider The Web3 provider, or signer. Defaults to window.ethereum.
 * @param paymentSettings The payment settings are necessary for conversion payment approval.
 * @param version The version of the batch conversion proxy, which can be different from request pn version.
 * @param overrides Optionally, override default transaction values, like gas.
 */
function approveErc20BatchConversion(request, signerOrProvider = (0, utils_1.getProvider)(), paymentSettings, version, overrides) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const preparedTx = prepareApproveErc20BatchConversion(request, signerOrProvider, paymentSettings, version, overrides);
        const signer = (0, utils_1.getSigner)(signerOrProvider);
        const tx = yield signer.sendTransaction(preparedTx);
        return tx;
    });
}
exports.approveErc20BatchConversion = approveErc20BatchConversion;
/**
 * Prepare the transaction to approve the proxy to spend signer's tokens to pay
 * the request in its payment currency. Can be used with a Multisig contract.
 * @param request The request for an ERC20 payment with/out conversion.
 * @param signerOrProvider The Web3 provider, or signer. Defaults to window.ethereum.
 * @param paymentSettings The payment settings are necessary for conversion payment approval.
 * @param version The version of the batch conversion proxy.
 * @param overrides Optionally, override default transaction values, like gas.
 */
function prepareApproveErc20BatchConversion(request, signerOrProvider = (0, utils_1.getProvider)(), paymentSettings, version, overrides) {
    const encodedTx = encodeApproveErc20BatchConversion(request, signerOrProvider, paymentSettings, version);
    return Object.assign({ data: encodedTx, to: getTokenAddress(request, paymentSettings), value: 0 }, overrides);
}
exports.prepareApproveErc20BatchConversion = prepareApproveErc20BatchConversion;
/**
 * Encodes the transaction to approve the batch conversion proxy to spend signer's tokens to pay
 * the request in its payment currency. Can be used with a Multisig contract.
 * @param request The request for an ERC20 payment with/out conversion.
 * @param signerOrProvider The Web3 provider, or signer. Defaults to window.ethereum.
 * @param paymentSettings The payment settings are necessary for conversion payment approval.
 * @param version The version of the batch conversion proxy.
 */
function encodeApproveErc20BatchConversion(request, signerOrProvider = (0, utils_1.getProvider)(), paymentSettings, version) {
    const proxyAddress = getBatchConversionProxyAddress(request, version);
    return (0, erc20_1.encodeApproveAnyErc20)(getTokenAddress(request, paymentSettings), proxyAddress, (0, utils_1.getSigner)(signerOrProvider));
}
exports.encodeApproveErc20BatchConversion = encodeApproveErc20BatchConversion;
/**
 * Get the address of the token to interact with,
 * if it is a conversion payment, the info is inside paymentSettings
 * @param request The request for an ERC20 payment with/out conversion.
 * @param paymentSettings The payment settings are necessary for conversion payment
 * */
function getTokenAddress(request, paymentSettings) {
    if (paymentSettings) {
        if (!paymentSettings.currency)
            throw 'paymentSetting must have a currency';
        return paymentSettings.currency.value;
    }
    return request.currencyInfo.value;
}
//# sourceMappingURL=batch-conversion-proxy.js.map