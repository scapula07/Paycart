"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.revokeErc20Approval = exports.comparePnTypeAndVersion = exports.getAmountToPay = exports.validateConversionFeeProxyRequest = exports.validateErc20FeeProxyRequest = exports.validateRequest = exports.getProxyAddress = exports.getPnAndNetwork = exports.getProxyNetwork = exports.getPaymentExtensionVersion = exports.getRequestPaymentValues = exports.getSigner = exports.getNetworkProvider = exports.getProvider = exports.UnsupportedCurrencyNetwork = exports.MAX_ALLOWANCE = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const types_1 = require("@requestnetwork/types");
const currency_1 = require("@requestnetwork/currency");
const types_2 = require("@requestnetwork/smart-contracts/types");
const payment_detection_2 = require("@requestnetwork/payment-detection");
/** @constant MAX_ALLOWANCE set to the max uint256 value */
exports.MAX_ALLOWANCE = ethers_1.BigNumber.from(2).pow(256).sub(1);
/**
 * Thrown when the library does not support a payment blockchain network.
 */
class UnsupportedCurrencyNetwork extends Error {
    constructor(networkName) {
        super(`Currency network ${networkName} is not supported`);
        this.networkName = networkName;
    }
}
exports.UnsupportedCurrencyNetwork = UnsupportedCurrencyNetwork;
/**
 * Utility to get the default window.ethereum provider, or throws an error.
 */
function getProvider() {
    if (typeof window !== 'undefined' && 'ethereum' in window) {
        return new ethers_1.ethers.providers.Web3Provider(window.ethereum);
    }
    throw new Error('ethereum not found, you must pass your own web3 provider');
}
exports.getProvider = getProvider;
/**
 * Utility to get a network provider, depending on the request's currency network.
 * Will throw an error if the network isn't mainnet, rinkeby, or goerli
 */
function getNetworkProvider(request) {
    return (0, payment_detection_1.getDefaultProvider)(request.currencyInfo.network);
}
exports.getNetworkProvider = getNetworkProvider;
/**
 * Utility to return a signer from a provider.
 * @param signerOrProvider the provider, or signer. If Signer, it will simply be returned directly
 * @param address optionally, the address to retrieve the signer for.
 */
function getSigner(signerOrProvider, address) {
    if (!signerOrProvider) {
        signerOrProvider = getProvider();
    }
    if (ethers_1.Signer.isSigner(signerOrProvider)) {
        return signerOrProvider;
    }
    if (ethers_1.providers.Web3Provider.isProvider(signerOrProvider) &&
        signerOrProvider.getSigner) {
        return signerOrProvider.getSigner(address);
    }
    throw new Error('cannot get signer');
}
exports.getSigner = getSigner;
/**
 * Utility to access the payment address, reference,
 * and optional feeAmount, feeAddress, expectedFlowRate, expectedStartDate
 * of a Request.
 */
function getRequestPaymentValues(request) {
    const extension = (0, payment_detection_2.getPaymentNetworkExtension)(request);
    if (!extension) {
        throw new Error('no payment network found');
    }
    const { paymentAddress, feeAmount, feeAddress, expectedFlowRate, expectedStartDate, tokensAccepted, maxRateTimespan, network, } = extension.values;
    const paymentReference = (0, payment_detection_1.getPaymentReference)(request);
    return {
        paymentAddress,
        paymentReference,
        feeAmount,
        feeAddress,
        expectedFlowRate,
        expectedStartDate,
        tokensAccepted,
        maxRateTimespan,
        network,
        version: extension.version,
    };
}
exports.getRequestPaymentValues = getRequestPaymentValues;
function getPaymentExtensionVersion(request) {
    const extension = (0, payment_detection_2.getPaymentNetworkExtension)(request);
    if (!extension) {
        throw new Error('no payment network found');
    }
    return extension.version;
}
exports.getPaymentExtensionVersion = getPaymentExtensionVersion;
/**
 * @param pn It contains the payment network extension
 * @param currency It contains the currency information
 */
const getProxyNetwork = (pn, currency) => {
    if (pn.values.network) {
        return pn.values.network;
    }
    if (currency.network) {
        return currency.network;
    }
    throw new Error('Payment currency must have a network');
};
exports.getProxyNetwork = getProxyNetwork;
/**
 * @param request The request to pay
 * @return An object that contains the payment network extension and the currency information
 */
function getPnAndNetwork(request) {
    const pn = (0, payment_detection_2.getPaymentNetworkExtension)(request);
    if (!pn) {
        throw new Error('PaymentNetwork not found');
    }
    return { paymentNetwork: pn, network: (0, exports.getProxyNetwork)(pn, request.currencyInfo) };
}
exports.getPnAndNetwork = getPnAndNetwork;
/**
 * @param request The request to pay
 * @param getDeploymentInformation The function to get the proxy address
 * @param version The version has to be set to get batch conversion proxy
 */
const getProxyAddress = (request, getDeploymentInformation, version) => {
    const { paymentNetwork, network } = getPnAndNetwork(request);
    const deploymentInfo = getDeploymentInformation(network, version || paymentNetwork.version);
    if (!deploymentInfo) {
        throw new Error(`No deployment found for network ${network}, version ${version || paymentNetwork.version}`);
    }
    return deploymentInfo.address;
};
exports.getProxyAddress = getProxyAddress;
const { ERC777_STREAM, ERC20_PROXY_CONTRACT, ETH_INPUT_DATA, ETH_FEE_PROXY_CONTRACT, ERC20_FEE_PROXY_CONTRACT, ANY_TO_ERC20_PROXY, NATIVE_TOKEN, } = types_1.ExtensionTypes.PAYMENT_NETWORK_ID;
const currenciesMap = {
    [ERC777_STREAM]: types_1.RequestLogicTypes.CURRENCY.ERC777,
    [ERC20_PROXY_CONTRACT]: types_1.RequestLogicTypes.CURRENCY.ERC20,
    [ERC20_FEE_PROXY_CONTRACT]: types_1.RequestLogicTypes.CURRENCY.ERC20,
    [ETH_INPUT_DATA]: types_1.RequestLogicTypes.CURRENCY.ETH,
    [ETH_FEE_PROXY_CONTRACT]: types_1.RequestLogicTypes.CURRENCY.ETH,
    [NATIVE_TOKEN]: types_1.RequestLogicTypes.CURRENCY.ETH,
};
/**
 * Utility to validate a request currency and payment details against a paymentNetwork.
 */
function validateRequest(request, paymentNetworkId) {
    var _a, _b;
    const { feeAmount, feeAddress, expectedFlowRate, expectedStartDate } = getRequestPaymentValues(request);
    let extension = request.extensions[paymentNetworkId];
    // FIXME: updating the extension: not needed anymore when "invoicing" will use only ethFeeProxy
    if (paymentNetworkId === types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ETH_FEE_PROXY_CONTRACT && !extension) {
        extension = request.extensions[types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ETH_INPUT_DATA];
    }
    // Compatibility of the request currency type with the payment network
    const expectedCurrencyType = currenciesMap[paymentNetworkId];
    const validCurrencyType = [
        types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY,
        types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_NATIVE_TOKEN,
        types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ETH_PROXY,
    ].includes(paymentNetworkId)
        ? // Any currency type is valid with Any to ERC20 / ETH / Native conversion
            true
        : expectedCurrencyType &&
            request.currencyInfo.type === expectedCurrencyType &&
            request.currencyInfo.network;
    // ERC20 based payment networks are only valid if the request currency has a value
    const validCurrencyValue = ![ERC20_PROXY_CONTRACT, ERC20_FEE_PROXY_CONTRACT, ERC777_STREAM].includes(paymentNetworkId) ||
        request.currencyInfo.value;
    // Payment network with fees should have both or none of fee address and fee amount
    const validFeeParams = (paymentNetworkId !== ANY_TO_ERC20_PROXY && paymentNetworkId !== ERC20_FEE_PROXY_CONTRACT) ||
        !!feeAddress === !!feeAmount;
    if (!validFeeParams) {
        throw new Error('Both fee address and fee amount have to be declared, or both left empty');
    }
    // Payment network with stream should have both or none of stream flow rate and stream start date
    const validStreamParams = paymentNetworkId !== ERC777_STREAM || (!!expectedFlowRate && !!expectedStartDate);
    if (!validStreamParams) {
        throw new Error('Both stream flow rate and stream start date have to be declared, or both left empty');
    }
    if (!validCurrencyType ||
        !validCurrencyValue ||
        !((_a = extension === null || extension === void 0 ? void 0 : extension.values) === null || _a === void 0 ? void 0 : _a.salt) ||
        !((_b = extension === null || extension === void 0 ? void 0 : extension.values) === null || _b === void 0 ? void 0 : _b.paymentAddress)) {
        throw new Error(`request cannot be processed, or is not an ${paymentNetworkId} request`);
    }
}
exports.validateRequest = validateRequest;
/**
 * Validates the amount and fee parameters for an ERC20 Fee Proxy based request.
 * @param request to validate
 * @param amount optionally, the custom amount to pay
 * @param feeAmountOverride optionally, the custom fee amount
 * @param paymentNetwork defaults to ERC20 Fee Proxy contract
 */
function validateErc20FeeProxyRequest(request, amount, feeAmountOverride, paymentNetwork = types_1.ExtensionTypes.PAYMENT_NETWORK_ID
    .ERC20_FEE_PROXY_CONTRACT) {
    validateRequest(request, paymentNetwork);
    const { feeAmount } = getRequestPaymentValues(request);
    const amountToPay = getAmountToPay(request, amount);
    const feeToPay = ethers_1.BigNumber.from(feeAmountOverride || feeAmount || 0);
    if (amountToPay.isZero() && feeToPay.isZero()) {
        throw new Error('Request payment amount and fee are 0');
    }
}
exports.validateErc20FeeProxyRequest = validateErc20FeeProxyRequest;
/**
 * Validates the parameters for an ERC20 Fee Proxy payment.
 * @param request to validate
 * @param tokenAddress token address to pay with
 * @param amount optionally, the custom amount to pay
 * @param feeAmountOverride optionally, the custom fee amount
 */
function validateConversionFeeProxyRequest(request, path, amount, feeAmountOverride) {
    validateErc20FeeProxyRequest(request, amount, feeAmountOverride, types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY);
    const { tokensAccepted } = getRequestPaymentValues(request);
    const requestCurrencyHash = path[0];
    if (requestCurrencyHash.toLowerCase() !== (0, currency_1.getCurrencyHash)(request.currencyInfo).toLowerCase()) {
        throw new Error(`The first entry of the path does not match the request currency`);
    }
    const tokenAddress = path[path.length - 1];
    if (tokensAccepted &&
        !(tokensAccepted === null || tokensAccepted === void 0 ? void 0 : tokensAccepted.map((t) => t.toLowerCase()).includes(tokenAddress.toLowerCase()))) {
        throw new Error(`The token ${tokenAddress} is not accepted to pay this request`);
    }
}
exports.validateConversionFeeProxyRequest = validateConversionFeeProxyRequest;
/**
 * Computes the amount to pay.
 * If `amount` is specified, it will return it.
 * Otherwise, it will return the amount left to pay in the request.
 *
 * @param request the request to pay
 * @param amount the optional amount to pay.
 */
function getAmountToPay(request, amount) {
    var _a;
    const amountToPay = amount === undefined
        ? ethers_1.BigNumber.from(request.expectedAmount).sub(((_a = request.balance) === null || _a === void 0 ? void 0 : _a.balance) || 0)
        : ethers_1.BigNumber.from(amount);
    if (amountToPay.lt(0)) {
        throw new Error('cannot pay a negative amount');
    }
    if (amountToPay.isZero()) {
        throw new Error('cannot pay a null amount');
    }
    return amountToPay;
}
exports.getAmountToPay = getAmountToPay;
/**
 * Compare 2 payment networks type and version in request's extension
 * and throw an exception if they are different
 * @param pn The payment network extension
 * @param request The request to pay
 */
function comparePnTypeAndVersion(pn, request) {
    const extension = (0, payment_detection_2.getPaymentNetworkExtension)(request);
    if (!extension) {
        throw new Error('no payment network found');
    }
    if (!((pn === null || pn === void 0 ? void 0 : pn.type) === extension.type && (pn === null || pn === void 0 ? void 0 : pn.version) === extension.version)) {
        throw new Error(`Every payment network type and version must be identical`);
    }
}
exports.comparePnTypeAndVersion = comparePnTypeAndVersion;
/**
 * Revoke ERC20 approval of a token for a given `spenderAddress`
 */
function revokeErc20Approval(spenderAddress, paymentTokenAddress, signerOrProvider = getProvider()) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const erc20interface = types_2.ERC20__factory.connect(paymentTokenAddress, signerOrProvider).interface;
        const encodedTx = erc20interface.encodeFunctionData('approve', [
            spenderAddress,
            ethers_1.BigNumber.from(0),
        ]);
        const preparedTx = {
            data: encodedTx,
            to: paymentTokenAddress,
            value: 0,
        };
        const signer = getSigner(signerOrProvider);
        const tx = yield signer.sendTransaction(preparedTx);
        return tx;
    });
}
exports.revokeErc20Approval = revokeErc20Approval;
//# sourceMappingURL=utils.js.map