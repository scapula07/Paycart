"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.payNearConversionRequest = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const utils_1 = require("./utils");
const utils_near_1 = require("./utils-near");
const currency_1 = require("@requestnetwork/currency");
/**
 * Processes the transaction to pay a request in NEAR with on-chain conversion.
 * @param request the request to pay
 * @param walletConnection the Web3 provider, or signer. Defaults to window.ethereum.
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 */
function payNearConversionRequest(request, walletConnection, paymentSettings, amount, callback) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        (0, utils_1.validateRequest)(request, types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_NATIVE_TOKEN);
        const currencyManager = paymentSettings.currencyManager || currency_1.CurrencyManager.getDefault();
        const { paymentReference, paymentAddress, feeAddress, feeAmount, maxRateTimespan, network } = (0, utils_1.getRequestPaymentValues)(request);
        const requestCurrency = currencyManager.fromStorageCurrency(request.currencyInfo);
        if (!requestCurrency) {
            throw new currency_1.UnsupportedCurrencyError(request.currencyInfo);
        }
        if (!paymentReference) {
            throw new Error('Cannot pay without a paymentReference');
        }
        if (!network || !(0, utils_near_1.isNearNetwork)(network)) {
            throw new Error('Should be a Near network');
        }
        const amountToPay = (0, utils_1.getAmountToPay)(request, amount).toString();
        const version = (0, utils_1.getPaymentExtensionVersion)(request);
        return (0, utils_near_1.processNearPaymentWithConversion)(walletConnection, network, amountToPay, paymentAddress, paymentReference, getTicker(request.currencyInfo), feeAddress || '0x', feeAmount || 0, paymentSettings.maxToSpend, maxRateTimespan || '0', version, callback);
    });
}
exports.payNearConversionRequest = payNearConversionRequest;
const getTicker = (currency) => {
    switch (currency.type) {
        case types_1.RequestLogicTypes.CURRENCY.ISO4217:
            return currency.value;
        default:
            // FIXME: Flux oracles are compatible with ERC20 identified by tickers. Ex: USDT, DAI.
            // Warning: although Flux oracles are compatible with ETH and BTC, the request contract
            // for native payments and conversions only handles 2 decimals, not suited for cryptos.
            throw new Error('Near payment with conversion only implemented for fiat denominations.');
    }
};
//# sourceMappingURL=near-conversion.js.map