"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unwrapSuperToken = exports.prepareUnwrapSuperToken = exports.wrapUnderlyingToken = exports.prepareWrapUnderlyingToken = exports.approveUnderlyingToken = exports.getWrapUnderlyingTokenOp = exports.prepareApproveUnderlyingToken = exports.checkSuperTokenUnderlyingAllowance = exports.hasEnoughUnderlyingToken = exports.getUnderlyingTokenBalanceOf = exports.getRequestUnderlyingToken = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const utils_1 = require("./utils");
const erc777_stream_1 = require("./erc777-stream");
const erc20_1 = require("./erc20");
/**
 * Gets the underlying token address of an ERC777 currency based request
 * @param request the request that contains currency information
 * @param provider the web3 provider. Defaults to Etherscan
 */
function getRequestUnderlyingToken(request, provider = (0, utils_1.getNetworkProvider)(request)) {
    var _a;
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const id = (_a = (0, payment_detection_1.getPaymentNetworkExtension)(request)) === null || _a === void 0 ? void 0 : _a.id;
        if (id !== types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC777_STREAM) {
            throw new Error('Not a supported ERC777 payment network request');
        }
        (0, utils_1.validateRequest)(request, types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC777_STREAM);
        const sf = yield (0, erc777_stream_1.getSuperFluidFramework)(request, provider);
        const superToken = yield sf.loadSuperToken(request.currencyInfo.value);
        return superToken.underlyingToken;
    });
}
exports.getRequestUnderlyingToken = getRequestUnderlyingToken;
/**
 * Gets the underlying token address of an ERC777 currency based request
 * @param request the request that contains currency information
 * @param provider the web3 provider. Defaults to Etherscan
 */
function getUnderlyingTokenBalanceOf(request, address, provider = (0, utils_1.getNetworkProvider)(request)) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const underlyingToken = yield getRequestUnderlyingToken(request, provider);
        return (0, erc20_1.getAnyErc20Balance)(underlyingToken.address, address, provider);
    });
}
exports.getUnderlyingTokenBalanceOf = getUnderlyingTokenBalanceOf;
/**
 * Check if the user has the specified amount of underlying token
 * @param request the request that contains currency information
 * @param address token owner
 * @param provider the web3 provider. Defaults to Etherscan
 * @param amount the required amount
 */
function hasEnoughUnderlyingToken(request, address, provider = (0, utils_1.getNetworkProvider)(request), amount) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const balance = yield getUnderlyingTokenBalanceOf(request, address, provider);
        return amount.lte(balance);
    });
}
exports.hasEnoughUnderlyingToken = hasEnoughUnderlyingToken;
/**
 * Determine whether or not the supertoken has enough allowance
 * @param request the request that contains currency information
 * @param address token owner
 * @param provider the web3 provider. Defaults to Etherscan
 * @param amount of token required
 */
function checkSuperTokenUnderlyingAllowance(request, address, provider = (0, utils_1.getNetworkProvider)(request), amount = utils_1.MAX_ALLOWANCE) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const underlyingToken = yield getRequestUnderlyingToken(request, provider);
        return (0, erc20_1.checkErc20Allowance)(address, request.currencyInfo.value, provider, underlyingToken.address, amount);
    });
}
exports.checkSuperTokenUnderlyingAllowance = checkSuperTokenUnderlyingAllowance;
/**
 * Get the SF operation to approve the supertoken to spend underlying tokens
 * @param request the request that contains currency information
 * @param provider the web3 provider. Defaults to Etherscan
 * @param amount to allow, defalts to max allowance
 */
function prepareApproveUnderlyingToken(request, provider = (0, utils_1.getNetworkProvider)(request), amount = utils_1.MAX_ALLOWANCE) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const underlyingToken = yield getRequestUnderlyingToken(request, provider);
        return {
            data: (0, erc20_1.encodeApproveAnyErc20)(underlyingToken.address, request.currencyInfo.value, provider, amount),
            to: underlyingToken.address,
            value: 0,
        };
    });
}
exports.prepareApproveUnderlyingToken = prepareApproveUnderlyingToken;
/**
 * Get the SF operation to Wrap the underlying asset into supertoken
 * @param request the request that contains currency information
 * @param address the user address
 * @param provider the web3 provider
 * @param amount to allow, defalts to max allowance
 */
function getWrapUnderlyingTokenOp(request, provider = (0, utils_1.getNetworkProvider)(request), amount) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const sf = yield (0, erc777_stream_1.getSuperFluidFramework)(request, provider);
        const superToken = yield sf.loadSuperToken(request.currencyInfo.value);
        return superToken.upgrade({
            amount: amount.toString(),
        });
    });
}
exports.getWrapUnderlyingTokenOp = getWrapUnderlyingTokenOp;
/**
 * Approve the supertoken to spend the speicified amount of underlying token
 * @param request the request that contains currency information
 * @param signer the web3 signer
 * @param amount to allow, defaults to max allowance
 * @returns
 */
function approveUnderlyingToken(request, signer, amount = utils_1.MAX_ALLOWANCE) {
    var _a, _b;
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        if (!(yield hasEnoughUnderlyingToken(request, yield signer.getAddress(), (_a = signer.provider) !== null && _a !== void 0 ? _a : (0, utils_1.getProvider)(), amount))) {
            throw new Error('Sender does not have enough underlying token');
        }
        const preparedTx = yield prepareApproveUnderlyingToken(request, (_b = signer.provider) !== null && _b !== void 0 ? _b : (0, utils_1.getProvider)(), amount);
        return signer.sendTransaction(preparedTx);
    });
}
exports.approveUnderlyingToken = approveUnderlyingToken;
/**
 * Prepare the wrap transaction of the specified amount of underlying token into supertoken
 * @param request the request that contains currency information
 * @param provider the web3 provider
 * @param amount to allow, defaults to max allowance
 * @returns
 */
function prepareWrapUnderlyingToken(request, provider = (0, utils_1.getNetworkProvider)(request), amount = utils_1.MAX_ALLOWANCE) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const wrapOp = yield getWrapUnderlyingTokenOp(request, provider, amount);
        return (yield wrapOp.populateTransactionPromise);
    });
}
exports.prepareWrapUnderlyingToken = prepareWrapUnderlyingToken;
/**
 * Wrap the speicified amount of underlying token into supertokens
 * @param request the request that contains currency information
 * @param signer the web3 signer
 * @param amount to allow, defaults to max allowance
 * @returns
 */
function wrapUnderlyingToken(request, signer, amount = utils_1.MAX_ALLOWANCE) {
    var _a, _b;
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const senderAddress = yield signer.getAddress();
        const provider = (_a = signer.provider) !== null && _a !== void 0 ? _a : (0, utils_1.getProvider)();
        if (!(yield checkSuperTokenUnderlyingAllowance(request, senderAddress, provider, amount))) {
            throw new Error('Supertoken not allowed to wrap this amount of underlying');
        }
        if (!(yield hasEnoughUnderlyingToken(request, senderAddress, provider, amount))) {
            throw new Error('Sender does not have enough underlying token');
        }
        const preparedTx = yield prepareWrapUnderlyingToken(request, (_b = signer.provider) !== null && _b !== void 0 ? _b : (0, utils_1.getProvider)(), amount);
        return signer.sendTransaction(preparedTx);
    });
}
exports.wrapUnderlyingToken = wrapUnderlyingToken;
/**
 * Prepare the unwrapping transaction of the supertoken (ERC777) into underlying asset (ERC20)
 * @param request the request that contains currency information
 * @param provider the web3 provider
 * @param amount to unwrap
 */
function prepareUnwrapSuperToken(request, provider = (0, utils_1.getNetworkProvider)(request), amount) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const sf = yield (0, erc777_stream_1.getSuperFluidFramework)(request, provider);
        const superToken = yield sf.loadSuperToken(request.currencyInfo.value);
        const underlyingToken = yield getRequestUnderlyingToken(request, provider);
        if (underlyingToken.address === superToken.address) {
            throw new Error('This is a native super token');
        }
        const downgradeOp = superToken.downgrade({
            amount: amount.toString(),
        });
        return (yield downgradeOp.populateTransactionPromise);
    });
}
exports.prepareUnwrapSuperToken = prepareUnwrapSuperToken;
/**
 * Unwrap the supertoken (ERC777) into underlying asset (ERC20)
 * @param request the request that contains currency information
 * @param signer the web3 signer
 * @param amount to unwrap
 */
function unwrapSuperToken(request, signer, amount) {
    var _a, _b, _c;
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const sf = yield (0, erc777_stream_1.getSuperFluidFramework)(request, (_a = signer.provider) !== null && _a !== void 0 ? _a : (0, utils_1.getProvider)());
        const superToken = yield sf.loadSuperToken(request.currencyInfo.value);
        const userAddress = yield signer.getAddress();
        const userBalance = yield superToken.balanceOf({
            account: userAddress,
            providerOrSigner: (_b = signer.provider) !== null && _b !== void 0 ? _b : (0, utils_1.getProvider)(),
        });
        if (amount.gt(userBalance)) {
            throw new Error('Sender does not have enough supertoken');
        }
        const preparedTx = yield prepareUnwrapSuperToken(request, (_c = signer.provider) !== null && _c !== void 0 ? _c : (0, utils_1.getProvider)(), amount);
        return signer.sendTransaction(preparedTx);
    });
}
exports.unwrapSuperToken = unwrapSuperToken;
//# sourceMappingURL=erc777-utils.js.map