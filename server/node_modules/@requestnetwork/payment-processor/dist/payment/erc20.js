"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._getErc20PaymentUrl = exports.getAnyErc20Balance = exports.getErc20Balance = exports.encodeApproveAnyErc20 = exports.encodeApproveErc20 = exports.prepareApproveErc20 = exports.approveErc20 = exports.approveErc20IfNeeded = exports.checkErc20Allowance = exports.hasErc20Approval = exports.payErc20Request = void 0;
const tslib_1 = require("tslib");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const types_1 = require("@requestnetwork/smart-contracts/types");
const types_2 = require("@requestnetwork/types");
const erc20_fee_proxy_1 = require("./erc20-fee-proxy");
const swap_erc20_fee_proxy_1 = require("./swap-erc20-fee-proxy");
const erc20_proxy_1 = require("./erc20-proxy");
const utils_1 = require("./utils");
/**
 * Processes a transaction to pay an ERC20 Request.
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param feeAmount optionally, the fee amount to pay. Only applicable to ERC20 Fee Payment network. Defaults to the fee amount.
 * @param overrides optionally, override default transaction values, like gas.
 * @param swapSettings optionally, the settings to swap a maximum amount of currency, through a swap path, before a deadline, to pay
 */
function payErc20Request(request, signerOrProvider, amount, feeAmount, overrides, swapSettings) {
    var _a;
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const id = (_a = (0, payment_detection_1.getPaymentNetworkExtension)(request)) === null || _a === void 0 ? void 0 : _a.id;
        if (swapSettings && id !== types_2.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT) {
            throw new Error(`ExtensionType: ${id} is not supported by swapToPay contract`);
        }
        if (id === types_2.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_PROXY_CONTRACT) {
            return (0, erc20_proxy_1.payErc20ProxyRequest)(request, signerOrProvider, amount, overrides);
        }
        if (id === types_2.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT) {
            if (swapSettings) {
                return (0, swap_erc20_fee_proxy_1.swapErc20FeeProxyRequest)(request, signerOrProvider, swapSettings, {
                    amount,
                    feeAmount,
                    overrides,
                });
            }
            else {
                return (0, erc20_fee_proxy_1.payErc20FeeProxyRequest)(request, signerOrProvider, amount, feeAmount, overrides);
            }
        }
        throw new Error('Not a supported ERC20 proxy payment network request');
    });
}
exports.payErc20Request = payErc20Request;
/**
 * Checks if the proxy has the necessary allowance from a given account to pay a given request with ERC20
 * @param request request to pay
 * @param account account that will be used to pay the request
 * @param provider the web3 provider. Defaults to Etherscan.
 */
function hasErc20Approval(request, account, signerOrProvider = (0, utils_1.getNetworkProvider)(request)) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        return checkErc20Allowance(account, getProxyAddress(request), signerOrProvider, request.currencyInfo.value, request.expectedAmount);
    });
}
exports.hasErc20Approval = hasErc20Approval;
/**
 * Checks if a spender has enough allowance from an ERC20 token owner to pay an amount.
 * @param ownerAddress address of the owner
 * @param spenderAddress address of the spender
 * @param provider the web3 provider. Defaults to Etherscan.
 * @param paymentCurrency ERC20 currency
 */
function checkErc20Allowance(ownerAddress, spenderAddress, signerOrProvider, tokenAddress, amount) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const erc20Contract = types_1.ERC20__factory.connect(tokenAddress, signerOrProvider);
        const allowance = yield erc20Contract.allowance(ownerAddress, spenderAddress);
        return allowance.gte(amount);
    });
}
exports.checkErc20Allowance = checkErc20Allowance;
/**
 * Processes the approval transaction of the targeted ERC20.
 * @param request request to pay
 * @param provider the web3 provider. Defaults to Etherscan.
 * @param overrides optionally, override default transaction values, like gas.
 */
function approveErc20IfNeeded(request, account, signerOrProvider = (0, utils_1.getNetworkProvider)(request), overrides, amount = utils_1.MAX_ALLOWANCE) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        if (!(yield hasErc20Approval(request, account, signerOrProvider))) {
            return approveErc20(request, (0, utils_1.getSigner)(signerOrProvider), overrides, amount);
        }
    });
}
exports.approveErc20IfNeeded = approveErc20IfNeeded;
/**
 * Processes the transaction to approve the proxy to spend signer's tokens to pay
 * the request in its payment currency. Can be used with a Multisig contract.
 * @param request request to pay
 * @param provider the web3 provider. Defaults to Etherscan.
 * @param overrides optionally, override default transaction values, like gas.
 */
function approveErc20(request, signerOrProvider = (0, utils_1.getProvider)(), overrides, amount = utils_1.MAX_ALLOWANCE) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const preparedTx = prepareApproveErc20(request, signerOrProvider, overrides, amount);
        const signer = (0, utils_1.getSigner)(signerOrProvider);
        const tx = yield signer.sendTransaction(preparedTx);
        return tx;
    });
}
exports.approveErc20 = approveErc20;
/**
 * Prepare the transaction to approve the proxy to spend signer's tokens to pay
 * the request in its payment currency. Can be used with a Multisig contract.
 * @param request request to pay
 * @param provider the web3 provider. Defaults to Etherscan.
 * @param overrides optionally, override default transaction values, like gas.
 */
function prepareApproveErc20(request, signerOrProvider = (0, utils_1.getProvider)(), overrides, amount = utils_1.MAX_ALLOWANCE) {
    const encodedTx = encodeApproveErc20(request, signerOrProvider, amount);
    const tokenAddress = request.currencyInfo.value;
    return Object.assign({ data: encodedTx, to: tokenAddress, value: 0 }, overrides);
}
exports.prepareApproveErc20 = prepareApproveErc20;
/**
 * Encodes the transaction to approve the proxy to spend signer's tokens to pay
 * the request in its payment currency. Can be used with a Multisig contract.
 * @param request the request to pay
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 */
function encodeApproveErc20(request, signerOrProvider = (0, utils_1.getProvider)(), amount = utils_1.MAX_ALLOWANCE) {
    var _a;
    const paymentNetworkId = (_a = (0, payment_detection_1.getPaymentNetworkExtension)(request)) === null || _a === void 0 ? void 0 : _a.id;
    if (!paymentNetworkId) {
        throw new Error('No payment network Id');
    }
    (0, utils_1.validateRequest)(request, paymentNetworkId);
    return encodeApproveAnyErc20(request.currencyInfo.value, getProxyAddress(request), (0, utils_1.getSigner)(signerOrProvider), amount);
}
exports.encodeApproveErc20 = encodeApproveErc20;
/**
 * Encodes the approval call to approve any erc20 token to be spent, with no limit.
 * @param tokenAddress the ERC20 token address to approve
 * @param spenderAddress the address granted the approval
 * @param signerOrProvider the signer who owns ERC20 tokens
 * @param amount default to max allowance
 */
function encodeApproveAnyErc20(tokenAddress, spenderAddress, signerOrProvider = (0, utils_1.getProvider)(), amount = utils_1.MAX_ALLOWANCE) {
    if (amount.gt(utils_1.MAX_ALLOWANCE)) {
        throw new Error('Invalid amount');
    }
    const erc20interface = types_1.ERC20__factory.connect(tokenAddress, signerOrProvider).interface;
    return erc20interface.encodeFunctionData('approve', [spenderAddress, amount]);
}
exports.encodeApproveAnyErc20 = encodeApproveAnyErc20;
/**
 * Gets ERC20 balance of an address, based on the request currency information
 * @param request the request that contains currency information
 * @param address the address to check
 * @param provider the web3 provider. Defaults to Etherscan
 */
function getErc20Balance(request, address, provider = (0, utils_1.getNetworkProvider)(request)) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        return getAnyErc20Balance(request.currencyInfo.value, address, provider);
    });
}
exports.getErc20Balance = getErc20Balance;
/**
 * Gets any ERC20 balance of an address
 * @param anyErc20Address the currency address
 * @param address the address to check
 * @param provider the web3 provider. Defaults to Etherscan
 */
function getAnyErc20Balance(anyErc20Address, address, provider) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const erc20Contract = types_1.ERC20__factory.connect(anyErc20Address, provider);
        return erc20Contract.balanceOf(address);
    });
}
exports.getAnyErc20Balance = getAnyErc20Balance;
/**
 * Return the EIP-681 format URL with the transaction to pay an ERC20
 * Warning: this EIP isn't widely used, be sure to test compatibility yourself.
 *
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 */
function _getErc20PaymentUrl(request, amount) {
    var _a;
    const id = (_a = (0, payment_detection_1.getPaymentNetworkExtension)(request)) === null || _a === void 0 ? void 0 : _a.id;
    if (id === types_2.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_PROXY_CONTRACT) {
        return (0, erc20_proxy_1._getErc20ProxyPaymentUrl)(request, amount);
    }
    if (id === types_2.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT) {
        return (0, erc20_fee_proxy_1._getErc20FeeProxyPaymentUrl)(request, amount);
    }
    throw new Error('Not a supported ERC20 proxy payment network request');
}
exports._getErc20PaymentUrl = _getErc20PaymentUrl;
/**
 * Get the request payment network proxy address
 * @returns the payment network proxy address
 */
function getProxyAddress(request) {
    const pn = (0, payment_detection_1.getPaymentNetworkExtension)(request);
    const id = pn === null || pn === void 0 ? void 0 : pn.id;
    if (id === types_2.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_ADDRESS_BASED) {
        throw new Error(`ERC20 address based payment network doesn't need approval`);
    }
    if (id === types_2.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_PROXY_CONTRACT) {
        return (0, utils_1.getProxyAddress)(request, payment_detection_1.Erc20PaymentNetwork.ERC20ProxyPaymentDetector.getDeploymentInformation);
    }
    if (id === types_2.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT) {
        return (0, utils_1.getProxyAddress)(request, payment_detection_1.Erc20PaymentNetwork.ERC20FeeProxyPaymentDetector.getDeploymentInformation);
    }
    throw new Error(`Unsupported payment network: ${id}`);
}
//# sourceMappingURL=erc20.js.map