"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeSwapToPayAnyToErc20Request = exports.prepareSwapToPayAnyToErc20Request = exports.swapToPayAnyToErc20Request = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const smart_contracts_1 = require("@requestnetwork/smart-contracts");
const types_1 = require("@requestnetwork/smart-contracts/types");
const types_2 = require("@requestnetwork/types");
const utils_1 = require("./utils");
const currency_1 = require("@requestnetwork/currency");
/**
 * Processes a transaction to swap tokens and pay an ERC20 Request through a proxy with fees.
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param options to override amount, feeAmount and transaction parameters
 */
function swapToPayAnyToErc20Request(request, signerOrProvider = (0, utils_1.getProvider)(), options) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const preparedTx = prepareSwapToPayAnyToErc20Request(request, signerOrProvider, options);
        const signer = (0, utils_1.getSigner)(signerOrProvider);
        const tx = yield signer.sendTransaction(preparedTx);
        return tx;
    });
}
exports.swapToPayAnyToErc20Request = swapToPayAnyToErc20Request;
/**
 * Processes a transaction to swap tokens and pay an ERC20 Request through a proxy with fees.
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param options to override amount, feeAmount and transaction parameters
 */
function prepareSwapToPayAnyToErc20Request(request, signerOrProvider = (0, utils_1.getProvider)(), options) {
    if (!request.extensions[types_2.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY]) {
        throw new Error(`The request must have the payment network any-to-erc20-proxy`);
    }
    const network = request.extensions[types_2.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY].values.network;
    if (!network) {
        throw new Error(`Payment network currency must have a network`);
    }
    const encodedTx = encodeSwapToPayAnyToErc20Request(request, signerOrProvider, options);
    const proxyAddress = smart_contracts_1.erc20SwapConversionArtifact.getAddress(network);
    return Object.assign({ data: encodedTx, to: proxyAddress, value: 0 }, options === null || options === void 0 ? void 0 : options.overrides);
}
exports.prepareSwapToPayAnyToErc20Request = prepareSwapToPayAnyToErc20Request;
/**
 * Encodes the call to pay a request through the ERC20 fee proxy contract, can be used with a Multisig contract.
 * @param request request to pay
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum
 * @param options to override amount, feeAmount and transaction parameters
 */
function encodeSwapToPayAnyToErc20Request(request, signerOrProvider = (0, utils_1.getProvider)(), options) {
    var _a, _b;
    const conversionSettings = options === null || options === void 0 ? void 0 : options.conversion;
    const swapSettings = options === null || options === void 0 ? void 0 : options.swap;
    if (!conversionSettings) {
        throw new Error(`Conversion Settings are required`);
    }
    if (!swapSettings) {
        throw new Error(`Swap Settings are required`);
    }
    const currencyManager = conversionSettings.currencyManager || currency_1.CurrencyManager.getDefault();
    const network = (_a = conversionSettings.currency) === null || _a === void 0 ? void 0 : _a.network;
    if (!network) {
        throw new Error(`Currency in conversion settings must have a network`);
    }
    const requestCurrency = currencyManager.fromStorageCurrency(request.currencyInfo);
    if (!requestCurrency) {
        throw new currency_1.UnsupportedCurrencyError(request.currencyInfo);
    }
    const paymentCurrency = currencyManager.fromStorageCurrency(conversionSettings.currency);
    if (!paymentCurrency) {
        throw new currency_1.UnsupportedCurrencyError(conversionSettings.currency);
    }
    /** On Chain conversion preparation */
    // check if conversion currency is accepted
    if (!request.extensions[types_2.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY].values.acceptedTokens.includes(conversionSettings.currency.value)) {
        throw new Error(`The conversion currency is not an accepted token`);
    }
    // Compute the path automatically
    const path = currencyManager.getConversionPath(requestCurrency, paymentCurrency, network);
    if (!path) {
        throw new Error(`Impossible to find a conversion path between from ${requestCurrency.symbol} (${requestCurrency.hash}) to ${paymentCurrency.symbol} (${paymentCurrency.hash})`);
    }
    (0, utils_1.validateConversionFeeProxyRequest)(request, path);
    const signer = (0, utils_1.getSigner)(signerOrProvider);
    const paymentNetworkTokenAddress = conversionSettings.currency.value;
    const { paymentReference, paymentAddress, feeAddress, feeAmount } = (0, utils_1.getRequestPaymentValues)(request);
    const chainlinkDecimal = 8;
    const decimals = (_b = currencyManager.fromStorageCurrency(request.currencyInfo)) === null || _b === void 0 ? void 0 : _b.decimals;
    if (!decimals) {
        throw new Error(`Could not find currency decimals for  ${request.currencyInfo.value}`);
    }
    const decimalPadding = Math.max(chainlinkDecimal - decimals, 0);
    const amountToPay = (0, utils_1.getAmountToPay)(request, options === null || options === void 0 ? void 0 : options.amount).mul(Math.pow(10, decimalPadding));
    const feeToPay = ethers_1.BigNumber.from((options === null || options === void 0 ? void 0 : options.feeAmount) || feeAmount || 0).mul(Math.pow(10, decimalPadding));
    if (swapSettings.path[swapSettings.path.length - 1].toLowerCase() !==
        paymentNetworkTokenAddress.toLowerCase()) {
        throw new Error('Last item of the path should be the payment currency');
    }
    // eslint-disable-next-line no-magic-numbers
    if (Date.now() > swapSettings.deadline * 1000) {
        throw new Error('A swap with a past deadline will fail, the transaction will not be pushed');
    }
    const conversionProxyAddress = (0, utils_1.getProxyAddress)(request, payment_detection_1.AnyToERC20PaymentDetector.getDeploymentInformation);
    const contractAddress = smart_contracts_1.erc20SwapConversionArtifact.getAddress(network);
    const swapToPayContract = types_1.ERC20SwapToConversion__factory.connect(contractAddress, signer);
    return swapToPayContract.interface.encodeFunctionData('swapTransferWithReference', [
        conversionProxyAddress,
        paymentAddress,
        amountToPay,
        swapSettings.maxInputAmount,
        swapSettings.path,
        path,
        `0x${paymentReference}`,
        feeToPay,
        feeAddress || ethers_1.constants.AddressZero,
        Math.round(swapSettings.deadline / 1000),
        0, // _chainlinkMaxRateTimespan: BigNumberish,
    ]);
}
exports.encodeSwapToPayAnyToErc20Request = encodeSwapToPayAnyToErc20Request;
//# sourceMappingURL=swap-any-to-erc20.js.map