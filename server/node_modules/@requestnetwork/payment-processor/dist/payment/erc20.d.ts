import { ContractTransaction, Signer, BigNumber, BigNumberish, providers } from 'ethers';
import { ClientTypes } from '@requestnetwork/types';
import { ISwapSettings } from './swap-erc20-fee-proxy';
import { ITransactionOverrides } from './transaction-overrides';
import { IPreparedTransaction } from './prepared-transaction';
/**
 * Processes a transaction to pay an ERC20 Request.
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param feeAmount optionally, the fee amount to pay. Only applicable to ERC20 Fee Payment network. Defaults to the fee amount.
 * @param overrides optionally, override default transaction values, like gas.
 * @param swapSettings optionally, the settings to swap a maximum amount of currency, through a swap path, before a deadline, to pay
 */
export declare function payErc20Request(request: ClientTypes.IRequestData, signerOrProvider?: providers.Provider | Signer, amount?: BigNumberish, feeAmount?: BigNumberish, overrides?: ITransactionOverrides, swapSettings?: ISwapSettings): Promise<ContractTransaction>;
/**
 * Checks if the proxy has the necessary allowance from a given account to pay a given request with ERC20
 * @param request request to pay
 * @param account account that will be used to pay the request
 * @param provider the web3 provider. Defaults to Etherscan.
 */
export declare function hasErc20Approval(request: ClientTypes.IRequestData, account: string, signerOrProvider?: providers.Provider | Signer): Promise<boolean>;
/**
 * Checks if a spender has enough allowance from an ERC20 token owner to pay an amount.
 * @param ownerAddress address of the owner
 * @param spenderAddress address of the spender
 * @param provider the web3 provider. Defaults to Etherscan.
 * @param paymentCurrency ERC20 currency
 */
export declare function checkErc20Allowance(ownerAddress: string, spenderAddress: string, signerOrProvider: providers.Provider | Signer, tokenAddress: string, amount: BigNumberish): Promise<boolean>;
/**
 * Processes the approval transaction of the targeted ERC20.
 * @param request request to pay
 * @param provider the web3 provider. Defaults to Etherscan.
 * @param overrides optionally, override default transaction values, like gas.
 */
export declare function approveErc20IfNeeded(request: ClientTypes.IRequestData, account: string, signerOrProvider?: providers.Provider | Signer, overrides?: ITransactionOverrides, amount?: BigNumber): Promise<ContractTransaction | void>;
/**
 * Processes the transaction to approve the proxy to spend signer's tokens to pay
 * the request in its payment currency. Can be used with a Multisig contract.
 * @param request request to pay
 * @param provider the web3 provider. Defaults to Etherscan.
 * @param overrides optionally, override default transaction values, like gas.
 */
export declare function approveErc20(request: ClientTypes.IRequestData, signerOrProvider?: providers.Provider | Signer, overrides?: ITransactionOverrides, amount?: BigNumber): Promise<ContractTransaction>;
/**
 * Prepare the transaction to approve the proxy to spend signer's tokens to pay
 * the request in its payment currency. Can be used with a Multisig contract.
 * @param request request to pay
 * @param provider the web3 provider. Defaults to Etherscan.
 * @param overrides optionally, override default transaction values, like gas.
 */
export declare function prepareApproveErc20(request: ClientTypes.IRequestData, signerOrProvider?: providers.Provider | Signer, overrides?: ITransactionOverrides, amount?: BigNumber): IPreparedTransaction;
/**
 * Encodes the transaction to approve the proxy to spend signer's tokens to pay
 * the request in its payment currency. Can be used with a Multisig contract.
 * @param request the request to pay
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 */
export declare function encodeApproveErc20(request: ClientTypes.IRequestData, signerOrProvider?: providers.Provider | Signer, amount?: BigNumber): string;
/**
 * Encodes the approval call to approve any erc20 token to be spent, with no limit.
 * @param tokenAddress the ERC20 token address to approve
 * @param spenderAddress the address granted the approval
 * @param signerOrProvider the signer who owns ERC20 tokens
 * @param amount default to max allowance
 */
export declare function encodeApproveAnyErc20(tokenAddress: string, spenderAddress: string, signerOrProvider?: providers.Provider | Signer, amount?: BigNumber): string;
/**
 * Gets ERC20 balance of an address, based on the request currency information
 * @param request the request that contains currency information
 * @param address the address to check
 * @param provider the web3 provider. Defaults to Etherscan
 */
export declare function getErc20Balance(request: ClientTypes.IRequestData, address: string, provider?: providers.Provider): Promise<BigNumberish>;
/**
 * Gets any ERC20 balance of an address
 * @param anyErc20Address the currency address
 * @param address the address to check
 * @param provider the web3 provider. Defaults to Etherscan
 */
export declare function getAnyErc20Balance(anyErc20Address: string, address: string, provider: providers.Provider): Promise<BigNumberish>;
/**
 * Return the EIP-681 format URL with the transaction to pay an ERC20
 * Warning: this EIP isn't widely used, be sure to test compatibility yourself.
 *
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 */
export declare function _getErc20PaymentUrl(request: ClientTypes.IRequestData, amount?: BigNumberish): string;
//# sourceMappingURL=erc20.d.ts.map