"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareApprovalErc20ForSwapWithConversionToPay = exports.approveErc20ForSwapWithConversionToPay = exports.hasErc20ApprovalForSwapWithConversion = exports.approveErc20ForSwapWithConversionIfNeeded = void 0;
const tslib_1 = require("tslib");
const smart_contracts_1 = require("@requestnetwork/smart-contracts");
const types_1 = require("@requestnetwork/types");
const utils_1 = require("./utils");
const erc20_1 = require("./erc20");
/**
 * Processes the approval transaction of a given payment ERC20 to be spent by the swap router,
 * if the current approval is missing or not sufficient.
 * @param request request to pay, used to know the network
 * @param ownerAddress address of the payer
 * @param paymentTokenAddress ERC20 currency used for the swap
 * @param signerOrProvider the web3 provider. Defaults to Etherscan.
 * @param minAmount ensures the approved amount is sufficient to pay this amount
 * @param overrides optionally, override default transaction values, like gas.
 */
function approveErc20ForSwapWithConversionIfNeeded(request, ownerAddress, paymentTokenAddress, signerOrProvider = (0, utils_1.getProvider)(), minAmount, overrides) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        if (!(yield hasErc20ApprovalForSwapWithConversion(request, ownerAddress, paymentTokenAddress, signerOrProvider, minAmount))) {
            return approveErc20ForSwapWithConversionToPay(request, paymentTokenAddress, signerOrProvider, overrides);
        }
    });
}
exports.approveErc20ForSwapWithConversionIfNeeded = approveErc20ForSwapWithConversionIfNeeded;
/**
 * Verify if a given payment ERC20 to be spent by the swap router
 * @param request request to pay, used to know the network
 * @param ownerAddress address of the payer
 * @param paymentTokenAddress ERC20 currency used for the swap
 * @param signerOrProvider the web3 provider. Defaults to Etherscan.
 * @param minAmount ensures the approved amount is sufficient to pay this amount
 * @param overrides optionally, override default transaction values, like gas.
 */
function hasErc20ApprovalForSwapWithConversion(request, ownerAddress, paymentTokenAddress, signerOrProvider = (0, utils_1.getProvider)(), minAmount) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        if (!request.extensions[types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY]) {
            throw new Error(`The request must have the payment network any-to-erc20-proxy`);
        }
        const network = request.extensions[types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY].values.network;
        return yield (0, erc20_1.checkErc20Allowance)(ownerAddress, smart_contracts_1.erc20SwapConversionArtifact.getAddress(network), signerOrProvider, paymentTokenAddress, minAmount);
    });
}
exports.hasErc20ApprovalForSwapWithConversion = hasErc20ApprovalForSwapWithConversion;
/**
 * Processes the approval transaction of the payment ERC20 to be spent by the swap router.
 * @param request request to pay, used to know the network
 * @param paymentTokenAddress picked currency for the swap to pay
 * @param signerOrProvider the web3 provider. Defaults to Etherscan.
 * @param overrides optionally, override default transaction values, like gas.
 */
function approveErc20ForSwapWithConversionToPay(request, paymentTokenAddress, signerOrProvider = (0, utils_1.getProvider)(), overrides) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const network = request.extensions[types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY].values.network;
        if (!network) {
            throw new Error(`Payment network currency must have a network`);
        }
        const preparedTx = prepareApprovalErc20ForSwapWithConversionToPay(request, paymentTokenAddress, signerOrProvider, overrides);
        const signer = (0, utils_1.getSigner)(signerOrProvider);
        const tx = yield signer.sendTransaction(preparedTx);
        return tx;
    });
}
exports.approveErc20ForSwapWithConversionToPay = approveErc20ForSwapWithConversionToPay;
/**
 * Prepare the approval transaction of the payment ERC20 to be spent by the swap router.
 * @param request request to pay, used to know the network
 * @param paymentTokenAddress picked currency for the swap to pay
 * @param signerOrProvider the web3 provider. Defaults to Etherscan.
 * @param overrides optionally, override default transaction values, like gas.
 */
function prepareApprovalErc20ForSwapWithConversionToPay(request, paymentTokenAddress, signerOrProvider = (0, utils_1.getProvider)(), overrides, amount) {
    const network = request.extensions[types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY].values.network;
    if (!network) {
        throw new Error(`Payment network currency must have a network`);
    }
    const encodedTx = (0, erc20_1.encodeApproveAnyErc20)(paymentTokenAddress, smart_contracts_1.erc20SwapConversionArtifact.getAddress(network), signerOrProvider, amount);
    return Object.assign({ data: encodedTx, to: paymentTokenAddress, value: 0 }, overrides);
}
exports.prepareApprovalErc20ForSwapWithConversionToPay = prepareApprovalErc20ForSwapWithConversionToPay;
//# sourceMappingURL=swap-conversion-erc20.js.map