"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processNearPaymentWithConversion = exports.processNearPayment = exports.isNearAccountSolvent = exports.isNearNetwork = exports.isValidNearAddress = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const near_api_js_1 = require("near-api-js");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const isValidNearAddress = (nearNetwork, address) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    try {
        yield nearNetwork.connection.provider.query(`account/${address}`, '');
        return true;
    }
    catch (e) {
        return false;
    }
});
exports.isValidNearAddress = isValidNearAddress;
const isNearNetwork = (network) => {
    return (!!network &&
        (network === 'near-testnet' || network === 'aurora-testnet' || network === 'aurora'));
};
exports.isNearNetwork = isNearNetwork;
const isNearAccountSolvent = (amount, nearWalletConnection) => {
    return nearWalletConnection
        .account()
        .state()
        .then((state) => {
        var _a;
        const balance = ethers_1.BigNumber.from((_a = state === null || state === void 0 ? void 0 : state.amount) !== null && _a !== void 0 ? _a : '0');
        return balance.gte(amount);
    });
};
exports.isNearAccountSolvent = isNearAccountSolvent;
const GAS_LIMIT_IN_TGAS = 50;
const GAS_LIMIT = ethers_1.ethers.utils.parseUnits(GAS_LIMIT_IN_TGAS.toString(), 12);
const GAS_LIMIT_NATIVE = GAS_LIMIT.toString();
const GAS_LIMIT_CONVERSION_TO_NATIVE = GAS_LIMIT.mul(2).toString();
const processNearPayment = (walletConnection, network, amount, to, paymentReference, version = '0.2.0', callback = undefined) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    if (version !== '0.2.0') {
        if (version === '0.1.0') {
            throw new Error('Native Token payments on Near with extension v0.1.0 are not supported anymore');
        }
        throw new Error('Native Token payments on Near only support v0.2.0 extensions');
    }
    if (!(yield (0, exports.isValidNearAddress)(walletConnection._near, to))) {
        throw new Error(`Invalid NEAR payment address: ${to}`);
    }
    try {
        const contract = new near_api_js_1.Contract(walletConnection.account(), payment_detection_1.NearNativeTokenPaymentDetector.getContractName(network, version), {
            changeMethods: ['transfer_with_reference'],
            viewMethods: [],
        });
        yield contract.transfer_with_reference(Object.assign({ args: {
                to,
                payment_reference: paymentReference,
            }, gas: GAS_LIMIT_NATIVE, amount: amount.toString() }, callback));
        return;
    }
    catch (e) {
        throw new Error(`Could not pay Near request. Got ${e.message}`);
    }
});
exports.processNearPayment = processNearPayment;
/**
 * Processes a payment in Near native token, with conversion.
 *
 * @param amount is defined with 2 decimals, denominated in `currency`
 * @param currency is a currency ticker (e.g. "ETH" or "USD")
 * @param maxRateTimespan accepts any kind rate's age if '0'
 */
const processNearPaymentWithConversion = (walletConnection, network, amount, to, paymentReference, currency, feeAddress, feeAmount, maxToSpend, maxRateTimespan = '0', version = '0.1.0', callback = undefined) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    if (version !== '0.1.0') {
        throw new Error('Native Token with conversion payments on Near only support v0.1.0 extensions');
    }
    if (!(yield (0, exports.isValidNearAddress)(walletConnection._near, to))) {
        throw new Error(`Invalid NEAR payment address: ${to}`);
    }
    if (!(yield (0, exports.isValidNearAddress)(walletConnection._near, feeAddress))) {
        throw new Error(`Invalid NEAR fee address: ${feeAddress}`);
    }
    try {
        const contract = new near_api_js_1.Contract(walletConnection.account(), payment_detection_1.NearConversionNativeTokenPaymentDetector.getContractName(network, version), {
            changeMethods: ['transfer_with_reference'],
            viewMethods: [],
        });
        yield contract.transfer_with_reference(Object.assign({ args: {
                payment_reference: paymentReference,
                to,
                amount,
                currency,
                fee_address: feeAddress,
                fee_amount: feeAmount,
                max_rate_timespan: maxRateTimespan,
            }, gas: GAS_LIMIT_CONVERSION_TO_NATIVE, amount: maxToSpend.toString() }, callback));
        return;
    }
    catch (e) {
        throw new Error(`Could not pay Near request. Got ${e.message}`);
    }
});
exports.processNearPaymentWithConversion = processNearPaymentWithConversion;
//# sourceMappingURL=utils-near.js.map