"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareApproveErc20ForProxyConversion = exports.approveErc20ForProxyConversion = exports.hasErc20ApprovalForProxyConversion = exports.approveErc20ForProxyConversionIfNeeded = void 0;
const tslib_1 = require("tslib");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const utils_1 = require("./utils");
const erc20_1 = require("./erc20");
/**
 * Processes the approval transaction of a given payment ERC20 to be spent by the conversion proxy,
 * if the current approval is missing or not sufficient.
 * @param request request to pay, used to know the network
 * @param ownerAddress address of the payer
 * @param paymentTokenAddress ERC20 currency used to pay
 * @param signerOrProvider the web3 provider. Defaults to Etherscan.
 * @param minAmount ensures the approved amount is sufficient to pay this amount
 * @param overrides optionally, override default transaction values, like gas.
 */
function approveErc20ForProxyConversionIfNeeded(request, ownerAddress, paymentTokenAddress, signerOrProvider = (0, utils_1.getProvider)(), minAmount, overrides) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        if (!(yield hasErc20ApprovalForProxyConversion(request, ownerAddress, paymentTokenAddress, signerOrProvider, minAmount))) {
            return approveErc20ForProxyConversion(request, paymentTokenAddress, signerOrProvider, overrides);
        }
    });
}
exports.approveErc20ForProxyConversionIfNeeded = approveErc20ForProxyConversionIfNeeded;
/**
 * Verify if a given payment ERC20 can be spent by the conversion proxy,
 * @param request request to pay, used to know the network
 * @param ownerAddress address of the payer
 * @param paymentTokenAddress ERC20 currency used to pay
 * @param signerOrProvider the web3 provider. Defaults to Etherscan.
 * @param minAmount ensures the approved amount is sufficient to pay this amount
 */
function hasErc20ApprovalForProxyConversion(request, ownerAddress, paymentTokenAddress, signerOrProvider = (0, utils_1.getProvider)(), minAmount) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const proxyAddress = (0, utils_1.getProxyAddress)(request, payment_detection_1.AnyToERC20PaymentDetector.getDeploymentInformation);
        return (0, erc20_1.checkErc20Allowance)(ownerAddress, proxyAddress, signerOrProvider, paymentTokenAddress, minAmount);
    });
}
exports.hasErc20ApprovalForProxyConversion = hasErc20ApprovalForProxyConversion;
/**
 * Processes the approval transaction of the payment ERC20 to be spent by the conversion proxy,
 * during the fee proxy delegate call.
 * @param request request to pay, used to know the network
 * @param paymentTokenAddress picked currency to pay
 * @param signerOrProvider the web3 provider. Defaults to Etherscan.
 * @param overrides optionally, override default transaction values, like gas.
 */
function approveErc20ForProxyConversion(request, paymentTokenAddress, signerOrProvider = (0, utils_1.getProvider)(), overrides) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const preparedTx = prepareApproveErc20ForProxyConversion(request, paymentTokenAddress, signerOrProvider, overrides);
        const signer = (0, utils_1.getSigner)(signerOrProvider);
        const tx = yield signer.sendTransaction(preparedTx);
        return tx;
    });
}
exports.approveErc20ForProxyConversion = approveErc20ForProxyConversion;
/**
 * Prepare the approval transaction of the payment ERC20 to be spent by the conversion proxy,
 * during the fee proxy delegate call.
 * @param request request to pay, used to know the network
 * @param paymentTokenAddress picked currency to pay
 * @param signerOrProvider the web3 provider. Defaults to Etherscan.
 * @param overrides optionally, override default transaction values, like gas.
 */
function prepareApproveErc20ForProxyConversion(request, paymentTokenAddress, signerOrProvider = (0, utils_1.getProvider)(), overrides, amount) {
    const proxyAddress = (0, utils_1.getProxyAddress)(request, payment_detection_1.AnyToERC20PaymentDetector.getDeploymentInformation);
    const encodedTx = (0, erc20_1.encodeApproveAnyErc20)(paymentTokenAddress, proxyAddress, signerOrProvider, amount);
    return Object.assign({ data: encodedTx, to: paymentTokenAddress, value: 0 }, overrides);
}
exports.prepareApproveErc20ForProxyConversion = prepareApproveErc20ForProxyConversion;
//# sourceMappingURL=conversion-erc20.js.map