"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareAnyToEthProxyPaymentTransaction = exports.encodePayAnyToEthProxyRequest = exports.payAnyToEthProxyRequest = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const currency_1 = require("@requestnetwork/currency");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const types_1 = require("@requestnetwork/smart-contracts/types");
const types_2 = require("@requestnetwork/types");
const utils_1 = require("./utils");
const payment_detection_2 = require("@requestnetwork/payment-detection");
const utils_2 = require("./utils");
/**
 * Processes a transaction to pay a request with a native token when the request is denominated in another currency
 * The payment is made by the ETH fee proxy contract.
 * @param request the request to pay
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param paymentSettings payment settings
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param feeAmount optionally, the fee amount to pay. Defaults to the fee amount.
 * @param overrides optionally, override default transaction values, like gas.
 */
function payAnyToEthProxyRequest(request, signerOrProvider = (0, utils_1.getProvider)(), paymentSettings, amount, feeAmount, overrides) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const { data, to, value } = prepareAnyToEthProxyPaymentTransaction(request, paymentSettings, amount, feeAmount);
        const signer = (0, utils_1.getSigner)(signerOrProvider);
        return signer.sendTransaction(Object.assign({ data, to, value }, overrides));
    });
}
exports.payAnyToEthProxyRequest = payAnyToEthProxyRequest;
/**
 * Encodes the call to pay a request with a native token when the request currency is different. The payment is made by the ETH fee proxy contract.
 * @param request request to pay
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param paymentSettings payment settings
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param feeAmountOverride optionally, the fee amount to pay. Defaults to the fee amount of the request.
 */
function encodePayAnyToEthProxyRequest(request, paymentSettings, amount, feeAmountOverride) {
    const currencyManager = paymentSettings.currencyManager || currency_1.CurrencyManager.getDefault();
    if (!request.currencyInfo) {
        throw new Error(`currency not specified`);
    }
    const requestCurrency = currencyManager.fromStorageCurrency(request.currencyInfo);
    if (!requestCurrency) {
        throw new currency_1.UnsupportedCurrencyError(request.currencyInfo);
    }
    const { paymentReference, paymentAddress, feeAddress, feeAmount, maxRateTimespan, network } = (0, utils_1.getRequestPaymentValues)(request);
    if (!network) {
        throw new Error(`missing network`);
    }
    const paymentCurrency = currencyManager.getNativeCurrency(types_2.RequestLogicTypes.CURRENCY.ETH, network);
    if (!paymentCurrency) {
        throw new currency_1.UnsupportedCurrencyError({ value: 'ETH', network });
    }
    // Compute the path automatically
    const path = currencyManager.getConversionPath(requestCurrency, paymentCurrency, network);
    if (!path) {
        throw new Error(`Impossible to find a conversion path between from ${requestCurrency.symbol} (${requestCurrency.hash}) to ${paymentCurrency.symbol} (${paymentCurrency.hash})`);
    }
    const amountToPay = (0, payment_detection_2.padAmountForChainlink)((0, utils_1.getAmountToPay)(request, amount), requestCurrency);
    const feeToPay = (0, payment_detection_2.padAmountForChainlink)(feeAmountOverride || feeAmount || 0, requestCurrency);
    const proxyContract = types_1.EthConversionProxy__factory.createInterface();
    return proxyContract.encodeFunctionData('transferWithReferenceAndFee', [
        paymentAddress,
        amountToPay,
        path,
        `0x${paymentReference}`,
        feeToPay,
        feeAddress || ethers_1.constants.AddressZero,
        maxRateTimespan || 0,
    ]);
}
exports.encodePayAnyToEthProxyRequest = encodePayAnyToEthProxyRequest;
function prepareAnyToEthProxyPaymentTransaction(request, paymentSettings, amount, feeAmount) {
    if (!paymentSettings.maxToSpend) {
        throw Error('paymentSettings.maxToSpend is required');
    }
    const encodedTx = encodePayAnyToEthProxyRequest(request, paymentSettings, amount, feeAmount);
    const proxyAddress = (0, utils_2.getProxyAddress)(request, payment_detection_1.AnyToEthFeeProxyPaymentDetector.getDeploymentInformation);
    return {
        data: encodedTx,
        to: proxyAddress,
        value: ethers_1.BigNumber.from(paymentSettings.maxToSpend),
    };
}
exports.prepareAnyToEthProxyPaymentTransaction = prepareAnyToEthProxyPaymentTransaction;
//# sourceMappingURL=any-to-eth-proxy.js.map