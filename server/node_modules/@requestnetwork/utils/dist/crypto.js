"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const ethers_1 = require("ethers");
const crypto_wrapper_1 = require("./crypto/crypto-wrapper");
const ec_utils_1 = require("./crypto/ec-utils");
const utils_1 = require("./utils");
/**
 * manages crypto functions
 */
exports.default = {
    CryptoWrapper: crypto_wrapper_1.default,
    EcUtils: ec_utils_1.default,
    generate32BufferKey,
    generate8randomBytes,
    keccak256Hash,
    last20bytesOfNormalizedKeccak256Hash,
    normalize,
    normalizeKeccak256Hash,
};
/**
 * Hashes with the keccak256 algorithm with a normalization before and formats it
 *
 * @notice It will sort the object by keys before hashing
 *
 * @param data The data to hash
 * @returns The hashed data multi-formatted
 */
function normalizeKeccak256Hash(data) {
    return {
        type: types_1.MultiFormatTypes.HashTypes.TYPE.KECCAK256,
        value: keccak256Hash(normalize(data)),
    };
}
/**
 * Normalizes data: sorts the object by keys and convert it in string
 *
 * @param data The data to normalize
 * @returns The normalized data
 */
function normalize(data) {
    if (data === undefined) {
        return 'undefined';
    }
    // deeply sort data keys
    const sortedData = utils_1.default.deepSort(data);
    // convert to string and lowerCase it, to be case insensitive (e.g: avoid ethereum address casing checksum)
    return JSON.stringify(sortedData).toLowerCase();
}
/**
 * Hashes with the keccak256 algorithm
 *
 * @param data The string to hash
 * @returns The hashed data multi-formatted
 */
function keccak256Hash(data) {
    return ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(data));
}
/**
 * Hashes with the keccak256 algorithm with a normalization before and formats it
 *
 * @notice It will sort the object by keys before hashing
 *
 * @param data The data to hash
 * @returns The hashed data multi-formatted
 */
function last20bytesOfNormalizedKeccak256Hash(data) {
    const hash = keccak256Hash(normalize(data));
    // eslint-disable-next-line no-magic-numbers
    return `0x${hash.slice(-40)}`;
}
/**
 * Generates a 32 bytes key in a base64 string
 *
 * @returns a random buffer of 32 bytes in a base64 string
 */
function generate32BufferKey() {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        return (yield crypto_wrapper_1.default.random32Bytes()).toString('base64');
    });
}
/**
 * Generate 8 random bytes and return as a hexadecimal string.
 * Used for salt in ETH input data.
 * Example: 'ea3bc7caf64110ca'
 *
 * @returns a string of 8 random bytes
 */
function generate8randomBytes() {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const random32Bytes = yield crypto_wrapper_1.default.random32Bytes();
        return random32Bytes.slice(0, 8).toString('hex');
    });
}
//# sourceMappingURL=crypto.js.map