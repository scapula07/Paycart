"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const crypto_1 = require("./crypto");
/**
 * Functions to manage encryption
 */
exports.default = {
    decrypt,
    encrypt,
    getIdentityFromEncryptionParams,
};
/**
 * Function to get the identity from the encryption parameters
 *
 * @param encryptionParams encryption parameters
 *
 * @returns the identity behind the encryption parameters
 */
function getIdentityFromEncryptionParams(encryptionParams) {
    if (encryptionParams.method === types_1.EncryptionTypes.METHOD.ECIES) {
        return {
            type: types_1.IdentityTypes.TYPE.ETHEREUM_ADDRESS,
            value: crypto_1.default.EcUtils.getAddressFromPublicKey(encryptionParams.key),
        };
    }
    throw new Error('encryptionParams.method not supported');
}
/**
 * Encrypts data using encryption parameters
 *
 * @param data the data to sign
 * @param encryptionParams Encryption parameters
 * @returns the encrypted data
 */
function encrypt(data, encryptionParams) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        if (encryptionParams.method === types_1.EncryptionTypes.METHOD.ECIES) {
            const encryptedData = yield crypto_1.default.EcUtils.encrypt(encryptionParams.key, data);
            return {
                type: types_1.EncryptionTypes.METHOD.ECIES,
                value: encryptedData,
            };
        }
        if (encryptionParams.method === types_1.EncryptionTypes.METHOD.AES256_CBC) {
            const encryptedDataBuffer = yield crypto_1.default.CryptoWrapper.encryptWithAes256cbc(Buffer.from(data, 'utf-8'), Buffer.from(encryptionParams.key, 'base64'));
            return {
                type: types_1.EncryptionTypes.METHOD.AES256_CBC,
                value: encryptedDataBuffer.toString('base64'),
            };
        }
        if (encryptionParams.method === types_1.EncryptionTypes.METHOD.AES256_GCM) {
            const encryptedDataBuffer = yield crypto_1.default.CryptoWrapper.encryptWithAes256gcm(Buffer.from(data, 'utf-8'), Buffer.from(encryptionParams.key, 'base64'));
            return {
                type: types_1.EncryptionTypes.METHOD.AES256_GCM,
                value: encryptedDataBuffer.toString('base64'),
            };
        }
        throw new Error('encryptionParams.method not supported');
    });
}
/**
 * Decrypt data using decryption parameters
 *
 * IMPORTANT: This must be used for test purpose only. An decryption provider must be used in production.
 *
 * @param encryptedData the encrypted data
 * @param key the decryption parameters
 * @returns the decrypted data
 */
function decrypt(encryptedData, decryptionParams) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        if (encryptedData.type === types_1.EncryptionTypes.METHOD.ECIES) {
            if (decryptionParams.method !== types_1.EncryptionTypes.METHOD.ECIES) {
                throw new Error(`decryptionParams.method should be ${types_1.EncryptionTypes.METHOD.ECIES}`);
            }
            return crypto_1.default.EcUtils.decrypt(decryptionParams.key, encryptedData.value);
        }
        if (encryptedData.type === types_1.EncryptionTypes.METHOD.AES256_CBC) {
            if (decryptionParams.method !== types_1.EncryptionTypes.METHOD.AES256_CBC) {
                throw new Error(`decryptionParams.method should be ${types_1.EncryptionTypes.METHOD.AES256_CBC}`);
            }
            const dataBuffer = yield crypto_1.default.CryptoWrapper.decryptWithAes256cbc(
            // remove the multi-format padding and decode from the base64 to a buffer
            Buffer.from(encryptedData.value, 'base64'), Buffer.from(decryptionParams.key, 'base64'));
            return dataBuffer.toString();
        }
        if (encryptedData.type === types_1.EncryptionTypes.METHOD.AES256_GCM) {
            if (decryptionParams.method !== types_1.EncryptionTypes.METHOD.AES256_GCM) {
                throw new Error(`decryptionParams.method should be ${types_1.EncryptionTypes.METHOD.AES256_GCM}`);
            }
            const dataBuffer = yield crypto_1.default.CryptoWrapper.decryptWithAes256gcm(
            // remove the multi-format padding and decode from the base64 to a buffer
            Buffer.from(encryptedData.value, 'base64'), Buffer.from(decryptionParams.key, 'base64'));
            return dataBuffer.toString();
        }
        throw new Error('encryptedData method not supported');
    });
}
//# sourceMappingURL=encryption.js.map