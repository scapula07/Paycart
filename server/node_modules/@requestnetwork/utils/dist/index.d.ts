/// <reference types="node" />
import SimpleLogger from './simple-logger';
declare const _default: {
    deepCopy: <T>(variable: T) => T;
    deepSort: (nestedObject: any) => any;
    flatten2DimensionsArray: <T_1>(twoDimensionsArray: T_1[][]) => T_1[];
    getCurrentTimestampInSecond: () => number;
    isString: (variable: any) => boolean;
    timeoutPromise: <T_2>(promise: Promise<T_2>, timeout: number, message: string) => Promise<T_2>;
    unique: <T_3>(array: T_3[]) => {
        uniqueItems: T_3[];
        duplicates: T_3[];
    };
    uniqueByProperty: <T_4>(array: T_4[], property: keyof T_4) => {
        uniqueItems: T_4[];
        duplicates: T_4[];
    };
    notNull: <T_5>(x: T_5 | null | undefined) => x is T_5;
    setProviderFactory: (providerFactory?: ((network: string | undefined, defaultFactory: (network: string | undefined) => string | import("@ethersproject/abstract-provider").Provider) => string | import("@ethersproject/abstract-provider").Provider) | undefined) => void;
    initPaymentDetectionApiKeys: (defaultProviderOptions?: Record<string, string | (() => string)> | undefined) => void;
    getDefaultProvider: (network?: string | undefined) => import("@ethersproject/abstract-provider").Provider;
    getCeloProvider: () => import("@ethersproject/abstract-provider").Provider;
    networkRpcs: Record<string, string>;
    SimpleLogger: typeof SimpleLogger;
    amount: {
        add: (amount: import("types/dist/request-logic-types").Amount, delta: import("types/dist/request-logic-types").Amount) => string;
        isValid: (amount: import("types/dist/request-logic-types").Amount | import("ethers").BigNumber) => boolean;
        reduce: (amount: import("types/dist/request-logic-types").Amount, delta: import("types/dist/request-logic-types").Amount) => string;
    };
    cachedThrottle: <TParams extends unknown[], TReturn>(target: (...params: TParams) => Promise<TReturn>, minimumDelay: number) => (...params: TParams) => Promise<TReturn>;
    crypto: {
        CryptoWrapper: {
            decryptWithAes256cbc: (encryptedAndIv: Buffer, key: Buffer) => Promise<Buffer>;
            decryptWithAes256gcm: (encryptedAndIv: Buffer, key: Buffer) => Promise<Buffer>;
            encryptWithAes256cbc: (data: Buffer, key: Buffer) => Promise<Buffer>;
            encryptWithAes256gcm: (data: Buffer, key: Buffer) => Promise<Buffer>;
            random32Bytes: () => Promise<Buffer>;
        };
        EcUtils: {
            decrypt: (privateKey: string, encrypted: string) => Promise<string>;
            encrypt: (publicKey: string, data: string) => Promise<string>;
            getAddressFromPrivateKey: (privateKey: string) => string;
            getAddressFromPublicKey: (publicKey: string) => string;
            recover: (signature: string, data: string) => string;
            sign: (privateKey: string, data: string) => string;
        };
        generate32BufferKey: () => Promise<string>;
        generate8randomBytes: () => Promise<string>;
        keccak256Hash: (data: string) => string;
        /**
         * Collection of general purpose utility function
         */
        last20bytesOfNormalizedKeccak256Hash: (data: unknown) => string;
        normalize: (data: unknown) => string;
        normalizeKeccak256Hash: (data: unknown) => import("types/dist/multi-format/hash-types").IHash;
    };
    encryption: {
        decrypt: (encryptedData: import("types/dist/encryption-types").IEncryptedData, decryptionParams: import("types/dist/encryption-types").IDecryptionParameters) => Promise<string>;
        encrypt: (data: string, encryptionParams: import("types/dist/encryption-types").IEncryptionParameters) => Promise<import("types/dist/encryption-types").IEncryptedData>;
        getIdentityFromEncryptionParams: (encryptionParams: import("types/dist/encryption-types").IEncryptionParameters) => import("types/dist/identity-types").IIdentity;
    };
    identity: {
        areEqual: (id1?: import("types/dist/identity-types").IIdentity | undefined, id2?: import("types/dist/identity-types").IIdentity | undefined) => boolean;
        hasError: (id: import("types/dist/identity-types").IIdentity) => string | null;
        normalizeIdentityValue: (value: string) => string;
        supportedIdentities: import("types/dist/identity-types").TYPE[];
    };
    retry: <TParams_1 extends unknown[], TReturn_1>(target: (...params: TParams_1) => TReturn_1 | Promise<TReturn_1>, { context, maxRetries, retryDelay, }?: {
        context?: ThisParameterType<(...params: TParams_1) => Promise<TReturn_1>> | undefined;
        maxRetries?: number | undefined;
        retryDelay?: number | undefined;
    }) => (...params: TParams_1) => Promise<TReturn_1>;
    signature: {
        getIdentityFromSignatureParams: (signatureParams: import("types/dist/signature-types").ISignatureParameters) => import("types/dist/identity-types").IIdentity;
        recover: (signedData: import("types/dist/signature-types").ISignedData) => import("types/dist/identity-types").IIdentity;
        sign: (data: unknown, signatureParams: import("types/dist/signature-types").ISignatureParameters) => import("types/dist/signature-types").ISignedData;
    };
};
/**
 * Collection of general purpose utility function
 */
export default _default;
//# sourceMappingURL=index.d.ts.map