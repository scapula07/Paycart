"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updatePaymentEthFeeProxy = exports.updatePaymentErc20FeeProxy = exports.updateBatchPaymentFees = exports.updateRequestSwapFees = exports.updateSwapRouter = exports.updateChainlinkConversionPath = exports.BATCH_FEE = exports.REQUEST_SWAP_FEES = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("../../src/lib");
const utils_1 = require("../../scripts/utils");
const artifacts = require("../../src/lib");
// Fees: 0.5%
exports.REQUEST_SWAP_FEES = 5;
// Batch Fees: .3%
exports.BATCH_FEE = 3;
const updateChainlinkConversionPath = (contract, network, nonce, gasPrice) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    const currentChainlinkAddress = yield contract.chainlinkConversionPath();
    const chainlinkConversionPathAddress = lib_1.chainlinkConversionPath.getAddress(network, '0.1.0');
    if (currentChainlinkAddress !== chainlinkConversionPathAddress) {
        yield contract.updateConversionPathAddress(chainlinkConversionPathAddress, {
            nonce: nonce,
            gasPrice: gasPrice,
        });
    }
});
exports.updateChainlinkConversionPath = updateChainlinkConversionPath;
const updateSwapRouter = (contract, network, nonce, gasPrice) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    const currentSwapRouter = yield contract.swapRouter();
    if (currentSwapRouter !== utils_1.uniswapV2RouterAddresses[network]) {
        yield contract.setRouter(utils_1.uniswapV2RouterAddresses[network], {
            nonce: nonce,
            gasPrice: gasPrice,
        });
    }
});
exports.updateSwapRouter = updateSwapRouter;
const updateRequestSwapFees = (contract, nonce, gasPrice) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    const currentFees = yield contract.requestSwapFees();
    if (currentFees !== exports.REQUEST_SWAP_FEES) {
        yield contract.updateRequestSwapFees(exports.REQUEST_SWAP_FEES, { nonce: nonce, gasPrice: gasPrice });
    }
});
exports.updateRequestSwapFees = updateRequestSwapFees;
const updateBatchPaymentFees = (contract, nonce, gasPrice) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    const currentFees = yield contract.batchFee();
    if (currentFees !== exports.BATCH_FEE) {
        // Log is useful to have a direct view on was is being updated
        console.log(`currentFees: ${currentFees.toString()}, new fees: ${exports.BATCH_FEE}`);
        yield contract.setBatchFee(exports.BATCH_FEE, { nonce: nonce, gasPrice: gasPrice });
    }
});
exports.updateBatchPaymentFees = updateBatchPaymentFees;
const updatePaymentErc20FeeProxy = (contract, network, nonce, gasPrice) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    const erc20FeeProxy = artifacts.erc20FeeProxyArtifact;
    const erc20FeeProxyAddress = erc20FeeProxy.getAddress(network);
    const currentAddress = yield contract.paymentErc20FeeProxy();
    if (currentAddress !== erc20FeeProxyAddress) {
        yield contract.setPaymentErc20FeeProxy(erc20FeeProxyAddress, {
            nonce: nonce,
            gasPrice: gasPrice,
        });
    }
});
exports.updatePaymentErc20FeeProxy = updatePaymentErc20FeeProxy;
const updatePaymentEthFeeProxy = (contract, network, nonce, gasPrice) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    const ethereumFeeProxy = artifacts.ethereumFeeProxyArtifact;
    const ethereumFeeProxyAddress = ethereumFeeProxy.getAddress(network);
    const currentAddress = yield contract.paymentEthFeeProxy();
    if (currentAddress !== ethereumFeeProxyAddress) {
        yield contract.setPaymentEthFeeProxy(ethereumFeeProxyAddress, {
            nonce: nonce,
            gasPrice: gasPrice,
        });
    }
});
exports.updatePaymentEthFeeProxy = updatePaymentEthFeeProxy;
//# sourceMappingURL=adminTasks.js.map