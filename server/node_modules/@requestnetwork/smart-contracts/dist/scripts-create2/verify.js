"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VerifyCreate2FromList = exports.verifyOne = void 0;
const tslib_1 = require("tslib");
const compute_one_address_1 = require("./compute-one-address");
const constructor_args_1 = require("./constructor-args");
const utils_1 = require("./utils");
const verifyOne = (contractAddress, deploymentParams, hre) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    try {
        yield hre.run('verify:verify', {
            address: contractAddress,
            constructorArguments: deploymentParams.constructorArgs,
        });
    }
    catch (err) {
        console.log(err);
    }
});
exports.verifyOne = verifyOne;
function VerifyCreate2FromList(hre) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        try {
            let address;
            yield Promise.all(utils_1.create2ContractDeploymentList.map((contract) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                switch (contract) {
                    case 'EthereumProxy':
                    case 'EthereumFeeProxy':
                    case 'EthConversionProxy':
                    case 'ERC20FeeProxy':
                    case 'ERC20SwapToConversion':
                    case 'Erc20ConversionProxy': {
                        const constructorArgs = (0, constructor_args_1.getConstructorArgs)(contract);
                        address = yield (0, compute_one_address_1.computeCreate2DeploymentAddress)({ contract, constructorArgs }, hre);
                        yield (0, exports.verifyOne)(address, { contract, constructorArgs }, hre);
                        break;
                    }
                    case 'ERC20EscrowToPay': {
                        const network = hre.config.xdeploy.networks[0];
                        const constructorArgs = (0, constructor_args_1.getConstructorArgs)(contract, network);
                        address = yield (0, compute_one_address_1.computeCreate2DeploymentAddress)({ contract, constructorArgs }, hre);
                        yield (0, exports.verifyOne)(address, { contract, constructorArgs }, hre);
                        break;
                    }
                    case 'BatchPayments': {
                        const network = hre.config.xdeploy.networks[0];
                        const constructorArgs = (0, constructor_args_1.getConstructorArgs)(contract, network);
                        address = yield (0, compute_one_address_1.computeCreate2DeploymentAddress)({ contract, constructorArgs }, hre);
                        yield (0, exports.verifyOne)(address, { contract, constructorArgs }, hre);
                        break;
                    }
                    // Other cases to add when necessary
                    default:
                        throw new Error(`The contrat ${contract} is not to be deployed using the CREATE2 scheme`);
                }
            })));
        }
        catch (e) {
            console.error(e);
        }
    });
}
exports.VerifyCreate2FromList = VerifyCreate2FromList;
//# sourceMappingURL=verify.js.map