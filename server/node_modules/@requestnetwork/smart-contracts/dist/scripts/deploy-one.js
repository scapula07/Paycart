"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployOne = void 0;
const tslib_1 = require("tslib");
require("@nomiclabs/hardhat-ethers");
const SIMULATED_DEPLOYMENT = {
    address: 'simulated',
    contractName: '',
    instance: null,
    constructorArguments: [],
    type: 'simulated',
};
const SKIPPED_DEPLOYMENT = {
    address: 'skipped',
    contractName: '',
    instance: null,
    constructorArguments: [],
    type: 'skipped',
};
/**
 * Deploys contracts if they are not known by artifacts on the network.
 * Publishes the source when the deployment is made.
 * @options
 *  - options.verify: set false to prevent verification on live networks
 *  - options.nonceCondition: only proceeds with the deployment if the nonce matches
 *  - options.version: to deploy or map a version different from the last version
 * @returns a deployment result with address =
 *  - The address if the contract is deployed or attached
 *  - 'simulated' if args.simulate === true (no deployment/)
 *  - 'skipped' if the nonce condition is not met
 */
function deployOne(args, hre, contractName, options) {
    var _a;
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const [deployer] = yield hre.ethers.getSigners();
        let address = undefined;
        const factory = yield hre.ethers.getContractFactory(contractName, deployer);
        const constructorArguments = (_a = options === null || options === void 0 ? void 0 : options.constructorArguments) !== null && _a !== void 0 ? _a : [];
        if (options === null || options === void 0 ? void 0 : options.artifact) {
            try {
                address = options.artifact.getAddress(hre.network.name, options.version);
                const action = args.force ? '(forcing deployment)' : '(skipping)';
                console.log(`Found ${contractName}${options.version ? ` v${options.version}` : ''} on ${hre.network.name} at address: ${address} ${action}`);
                if (!args.force) {
                    return {
                        address,
                        contractName,
                        instance: factory.attach(address),
                        constructorArguments,
                        type: 'attached',
                    };
                }
            }
            catch (e) {
                // ignore error
            }
        }
        if (options === null || options === void 0 ? void 0 : options.nonceCondition) {
            const currentNonce = yield deployer.getTransactionCount();
            if (options.nonceCondition !== currentNonce) {
                if (!args.simulate) {
                    console.warn(`Warning: trying to deploy ${contractName} with nonce ${options.nonceCondition}, but nonce = ${currentNonce}`);
                    const result = Object.assign(Object.assign({}, SKIPPED_DEPLOYMENT), { instance: null, contractName, constructorArguments: constructorArguments });
                    return result;
                }
            }
        }
        if (args.simulate) {
            const result = Object.assign(Object.assign({}, SIMULATED_DEPLOYMENT), { instance: null, contractName, constructorArguments: constructorArguments });
            return result;
        }
        // Deployment and Verification
        try {
            // Deployment
            const instance = (yield factory.deploy(...constructorArguments));
            yield instance.deployed();
            address = instance.address;
            const block = instance.deployTransaction.blockNumber;
            // Verfication
            let verificationPromise = undefined;
            const publishSource = hre.network.name !== 'private' && !args.simulate && (options === null || options === void 0 ? void 0 : options.verify) !== false;
            if (publishSource) {
                verificationPromise = instance.deployTransaction.wait(10).then(() => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                    let verificationResult = true;
                    try {
                        yield hre.run('verify:verify', { address, constructorArguments });
                    }
                    catch (e) {
                        console.warn(`Failed verifying contract: ${contractName}`);
                        console.log(e);
                        verificationResult = false;
                    }
                    return verificationResult;
                }));
            }
            return {
                address,
                block,
                contractName,
                instance,
                constructorArguments,
                type: 'deployed',
                verificationPromise,
            };
        }
        catch (e) {
            throw new Error(`Failed deploying contract: ${contractName}. Error: ${e}`);
        }
    });
}
exports.deployOne = deployOne;
//# sourceMappingURL=deploy-one.js.map