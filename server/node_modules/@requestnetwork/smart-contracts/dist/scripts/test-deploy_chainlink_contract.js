"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.USDT_ETH_RATE = exports.DAI_USD_RATE = exports.ETH_USD_RATE = exports.EUR_USD_RATE = exports.PRECISION_RATE = void 0;
const tslib_1 = require("tslib");
require("@nomiclabs/hardhat-ethers");
const currency_1 = require("@requestnetwork/currency");
const conversion_proxy_1 = require("./conversion-proxy");
const erc20_swap_to_conversion_1 = require("./erc20-swap-to-conversion");
const deploy_one_1 = require("./deploy-one");
const ethers_1 = require("ethers");
exports.PRECISION_RATE = 100000000;
exports.EUR_USD_RATE = ethers_1.BigNumber.from(1.2 * exports.PRECISION_RATE);
exports.ETH_USD_RATE = ethers_1.BigNumber.from(500 * exports.PRECISION_RATE);
exports.DAI_USD_RATE = ethers_1.BigNumber.from(1.01 * exports.PRECISION_RATE);
exports.USDT_ETH_RATE = ethers_1.BigNumber.from(0.002 * 1000000000000000000);
function deploy(args, hre, mainPaymentAddresses) {
    var _a, _b;
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const [deployer] = yield hre.ethers.getSigners();
        const { address: AggDAI_USD_address } = yield (0, deploy_one_1.deployOne)(args, hre, 'AggregatorMock', {
            constructorArguments: [exports.DAI_USD_RATE, 8, 60],
        });
        const { address: AggETH_USD_address } = yield (0, deploy_one_1.deployOne)(args, hre, 'AggregatorMock', {
            constructorArguments: [exports.ETH_USD_RATE, 8, 60],
        });
        const { address: AggEUR_USD_address } = yield (0, deploy_one_1.deployOne)(args, hre, 'AggregatorMock', {
            constructorArguments: [exports.EUR_USD_RATE, 8, 60],
        });
        const { address: AggUSDT_ETH_address } = yield (0, deploy_one_1.deployOne)(args, hre, 'AggregatorMock', {
            constructorArguments: [exports.USDT_ETH_RATE, 18, 60],
        });
        const { address: USDT_fake_address } = yield (0, deploy_one_1.deployOne)(args, hre, 'UsdtFake');
        const currencyManager = currency_1.CurrencyManager.getDefault();
        // all these addresses are for test purposes
        const ETH_hash = currencyManager.fromSymbol('ETH').hash;
        const USD_hash = currencyManager.fromSymbol('USD').hash;
        const EUR_hash = currencyManager.fromSymbol('EUR').hash;
        // Cf. ERC20Alpha in TestERC20.sol
        const DAI_address = mainPaymentAddresses.DAIAddress;
        const USDT_address = USDT_fake_address;
        console.log(`USDT address: ${USDT_address}`);
        const conversionPathInstance = yield (yield hre.ethers.getContractFactory('ChainlinkConversionPath', deployer)).deploy(ETH_hash);
        // all these aggregators are for test purposes
        yield conversionPathInstance.updateAggregatorsList([DAI_address, EUR_hash, ETH_hash, USDT_address], [USD_hash, USD_hash, USD_hash, ETH_hash], [AggDAI_USD_address, AggEUR_USD_address, AggETH_USD_address, AggUSDT_ETH_address]);
        console.log('AggregatorsList updated.');
        // ERC20Conversion
        const ERC20Conversion = yield (0, conversion_proxy_1.deployERC20ConversionProxy)(Object.assign(Object.assign({}, args), { chainlinkConversionPathAddress: conversionPathInstance.address, erc20FeeProxyAddress: mainPaymentAddresses.ERC20FeeProxyAddress }), hre);
        if (!ERC20Conversion || !ERC20Conversion.address) {
            console.error('Deployment for ERC20Conversion failed.');
            return;
        }
        // ERC20SwapConversion
        const localSwapRouterAddress = '0x4E72770760c011647D4873f60A3CF6cDeA896CD8';
        const { address: erc20SwapConversionAddress, instance: erc20SwapConversion } = yield (0, erc20_swap_to_conversion_1.deploySwapConversion)(Object.assign(Object.assign({}, args), { conversionProxyAddress: ERC20Conversion.address, swapProxyAddress: localSwapRouterAddress }), hre);
        if (!erc20SwapConversion) {
            console.error('Deployment for erc20SwapConversion failed.');
            return;
        }
        // Admin tasks:
        yield erc20SwapConversion.setRouter(localSwapRouterAddress);
        yield erc20SwapConversion.updateRequestSwapFees(5);
        yield erc20SwapConversion.updateConversionPathAddress(conversionPathInstance.address);
        yield erc20SwapConversion.approvePaymentProxyToSpend(mainPaymentAddresses.DAIAddress, ERC20Conversion.address);
        yield erc20SwapConversion.approveRouterToSpend(mainPaymentAddresses.ERC20TestAddress);
        // EthConversion
        const ethConversionProxyAddress = (_b = (_a = (yield (0, conversion_proxy_1.deployEthConversionProxy)(Object.assign(Object.assign({}, args), { chainlinkConversionPathAddress: conversionPathInstance.address, ethFeeProxyAddress: mainPaymentAddresses.ETHFeeProxyAddress, nativeTokenHash: ETH_hash }), hre))) === null || _a === void 0 ? void 0 : _a.address) !== null && _b !== void 0 ? _b : '(missing)';
        // ----------------------------------
        console.log('Contracts deployed');
        console.log(`
    (fake) USDT:              ${USDT_address}
    AggDAI_USD:               ${AggDAI_USD_address}
    ChainlinkConversionPath:  ${conversionPathInstance.address}
    Erc20ConversionProxy:     ${ERC20Conversion.address}
    Erc20SwapConversionProxy: ${erc20SwapConversionAddress}
    EthConversionProxy:       ${ethConversionProxyAddress}
    `);
    });
}
exports.default = deploy;
//# sourceMappingURL=test-deploy_chainlink_contract.js.map