"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
require("@nomiclabs/hardhat-ethers");
const deploy_one_1 = require("../scripts/deploy-one");
// Deploys, set up the contracts
function deploy(args, hre) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        try {
            const [deployer] = yield hre.ethers.getSigners();
            console.log(`Deploying with the account: ${deployer.address} on the network ${hre.network.name} (${hre.network.config.chainId})`);
            const erc20Factory = yield hre.ethers.getContractFactory('TestERC20');
            // Deploy the ERC20 contract
            const testERC20Instance = yield erc20Factory.deploy('1000000000000000000000000000000');
            // Deploy ERC20 proxy contract
            const instanceRequestERC20Proxy = yield (yield hre.ethers.getContractFactory('ERC20Proxy')).deploy();
            console.log('ERC20Proxy Contract deployed: ' + instanceRequestERC20Proxy.address);
            // create some events for test purpose
            yield testERC20Instance.approve(instanceRequestERC20Proxy.address, 110);
            yield instanceRequestERC20Proxy.transferFromWithReference(testERC20Instance.address, '0x6330A553Fc93768F612722BB8c2eC78aC90B3bbc', 100, '0x7157f6ce9085a520');
            yield instanceRequestERC20Proxy.transferFromWithReference(testERC20Instance.address, '0x5AEDA56215b167893e80B4fE645BA6d5Bab767DE', 10, '0xdeea051f2e9120e0');
            // Deploy ETH proxy contract
            const { address: EthereumProxyAddress } = yield (0, deploy_one_1.deployOne)(args, hre, 'EthereumProxy');
            console.log('EthereumProxy Contract deployed: ' + EthereumProxyAddress);
            // Deploy ERC20 Fee proxy contract
            const { address: ERC20FeeProxyAddress } = yield (0, deploy_one_1.deployOne)(args, hre, 'ERC20FeeProxy');
            console.log('ERC20FeeProxy Contract deployed: ' + ERC20FeeProxyAddress);
            // Deploy the BadERC20 contract
            const { address: BadERC20Address } = yield (0, deploy_one_1.deployOne)(args, hre, 'BadERC20', {
                constructorArguments: [1000, 'BadERC20', 'BAD', 8],
            });
            console.log('BadERC20 Contract deployed: ' + BadERC20Address);
            // Deploy test ERC20 contracts
            const { address: ERC20TrueAddress } = yield (0, deploy_one_1.deployOne)(args, hre, 'ERC20True');
            console.log('ERC20True Contract deployed: ' + ERC20TrueAddress);
            const { address: ERC20FalseAddress } = yield (0, deploy_one_1.deployOne)(args, hre, 'ERC20False');
            console.log('ERC20False Contract deployed: ' + ERC20FalseAddress);
            const { address: ERC20NoReturnAddress } = yield (0, deploy_one_1.deployOne)(args, hre, 'ERC20NoReturn');
            console.log('ERC20NoReturn Contract deployed: ' + ERC20NoReturnAddress);
            const ERC20Revert = yield (yield hre.ethers.getContractFactory('ERC20Revert', deployer)).deploy();
            console.log('ERC20Revert Contract deployed: ' + ERC20Revert.address);
            // Swap-to-pay related contracts
            // Payment erc20: ALPHA
            const erc20AlphaInstance = yield erc20Factory.deploy('1000000000000000000000000000000000000');
            // Mock a swap router
            const { address: FakeSwapRouterAddress } = yield (0, deploy_one_1.deployOne)(args, hre, 'FakeSwapRouter');
            // 1 ERC20 = 2 ALPHA
            yield erc20AlphaInstance.transfer(FakeSwapRouterAddress, '20000000000000000000000000000');
            yield testERC20Instance.transfer(FakeSwapRouterAddress, '10000000000000000000000000000');
            // SwapToPay
            const { address: ERC20SwapToPayAddress } = yield (0, deploy_one_1.deployOne)(args, hre, 'ERC20SwapToPay', {
                constructorArguments: [FakeSwapRouterAddress, ERC20FeeProxyAddress],
            });
            // FIXME SwapToPay deployed without approbation for router and proxy
            console.log('SwapToPay Contract deployed: ' + ERC20SwapToPayAddress);
            // FIXME useless transaction to keep the same contract addresses
            yield testERC20Instance.transfer(deployer.address, '1');
            // Deploy ETH fee proxy contract
            const { address: EthereumFeeProxyAddress } = yield (0, deploy_one_1.deployOne)(args, hre, 'EthereumFeeProxy');
            console.log('EthereumFeeProxy Contract deployed: ' + EthereumFeeProxyAddress);
            // ----------------------------------
            console.log('Contracts deployed');
            console.log(`
      TestERC20:                ${testERC20Instance.address}
      ERC20Proxy:               ${instanceRequestERC20Proxy.address}
      EthereumProxy:            ${EthereumProxyAddress}
      EthereumFeeProxy:         ${EthereumFeeProxyAddress}
      ERC20FeeProxy:            ${ERC20FeeProxyAddress}
      BadERC20:                 ${BadERC20Address}
      ERC20True:                ${ERC20TrueAddress}
      ERC20False:               ${ERC20FalseAddress}
      ERC20NoReturn:            ${ERC20NoReturnAddress}
      ERC20Revert:              ${ERC20Revert.address}
      ERC20Alpha:               ${erc20AlphaInstance.address}
      FakeSwapRouter:           ${FakeSwapRouterAddress}
      SwapToPay:                ${ERC20SwapToPayAddress}
    `);
            return {
                DAIAddress: erc20AlphaInstance.address,
                ERC20FeeProxyAddress: ERC20FeeProxyAddress,
                ERC20TestAddress: testERC20Instance.address,
                ETHFeeProxyAddress: EthereumFeeProxyAddress,
            };
        }
        catch (e) {
            console.error(e);
        }
    });
}
exports.default = deploy;
//# sourceMappingURL=test-deploy-main-payments.js.map