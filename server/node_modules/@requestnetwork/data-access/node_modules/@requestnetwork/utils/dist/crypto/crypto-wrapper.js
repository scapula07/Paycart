"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.random32Bytes = exports.encryptWithAes256gcm = exports.encryptWithAes256cbc = exports.decryptWithAes256gcm = exports.decryptWithAes256cbc = void 0;
const tslib_1 = require("tslib");
const crypto_1 = require("crypto");
// Algorithm name used for aes256-cbc encryption with the package 'crypto'
const AES_256_CBC_ALGORITHM = 'aes-256-cbc';
// Algorithm name used for aes256-gcm encryption with the package 'crypto'
const AES_256_GCM_ALGORITHM = 'aes-256-gcm';
// Size of the initialization vector used for the aes256-cbc & aes256-gcm encryption
const INITIALIZATION_VECTOR_LENGTH = 16;
const AUTH_TAG_LENGTH = 16;
/**
 * Generates 32 cryptographically strong pseudo-random bytes
 *
 * @returns Promise resolving the 32 bytes generated
 */
function random32Bytes() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // eslint-disable-next-line no-magic-numbers
        return randomBytes(32);
    });
}
exports.random32Bytes = random32Bytes;
/**
 * Encrypts a buffer using AES-256-cbc plus a random Initialization Vector (IV)
 *
 * @param data the data to encrypt
 * @param key the key that will be used for the encryption
 *
 * @returns Promise resolving a buffer containing the IV and the encrypted data
 */
function encryptWithAes256cbc(data, key) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // Generate randomly the Initialization Vector
        const iv = yield randomBytes(INITIALIZATION_VECTOR_LENGTH);
        // Create the cipher object to encrypt data
        const cipher = (0, crypto_1.createCipheriv)(AES_256_CBC_ALGORITHM, key, iv);
        // Encrypt data
        const encrypted = cipher.update(data);
        // Concat the IV and the encrypted data, the call of final() makes the cipher not usable and flush the buffer
        return Buffer.concat([iv, encrypted, cipher.final()]);
    });
}
exports.encryptWithAes256cbc = encryptWithAes256cbc;
/**
 * Encrypts a buffer using AES-256-gcm plus a random Initialization Vector (IV)
 *
 * @param data the data to encrypt
 * @param key the key that will be used for the encryption
 *
 * @returns Promise resolving a buffer containing the IV and the encrypted data
 */
function encryptWithAes256gcm(data, key) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // Generate randomly the Initialization Vector
        const iv = yield randomBytes(INITIALIZATION_VECTOR_LENGTH);
        // Create the cipher object to encrypt data
        const cipher = (0, crypto_1.createCipheriv)(AES_256_GCM_ALGORITHM, key, iv);
        const encrypted = cipher.update(data);
        const final = cipher.final();
        const authTag = cipher.getAuthTag();
        // Concat the IV and the encrypted data, the call of final() makes the cipher not usable and flush the buffer
        return Buffer.concat([iv, authTag, encrypted, final]);
    });
}
exports.encryptWithAes256gcm = encryptWithAes256gcm;
/**
 * Decrypts an encrypted buffer using AES-256-cbc plus a random Initialization Vector (IV)
 *
 * @param encrypted the data to decrypt
 * @param key key of the encryption
 *
 * @returns Promise resolving a buffer containing the data decrypted
 */
function decryptWithAes256cbc(encryptedAndIv, key) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // Get the IV
        const iv = encryptedAndIv.slice(0, INITIALIZATION_VECTOR_LENGTH);
        // Get the encrypted data itself
        const encryptedData = encryptedAndIv.slice(INITIALIZATION_VECTOR_LENGTH);
        // Create the decipher object
        const decipher = (0, crypto_1.createDecipheriv)(AES_256_CBC_ALGORITHM, key, iv);
        // decipher.setAuthTag(authTag);
        // Return the buffer decrypted (the call of final() makes the decipher not usable and flush the buffer)
        return Buffer.concat([decipher.update(encryptedData), decipher.final()]);
    });
}
exports.decryptWithAes256cbc = decryptWithAes256cbc;
/**
 * Decrypts an encrypted buffer using AES-256-gcm plus a random Initialization Vector (IV)
 *
 * @param encrypted the data to decrypt
 * @param key key of the encryption
 *
 * @returns Promise resolving a buffer containing the data decrypted
 */
function decryptWithAes256gcm(encryptedAndIv, key) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // Get the IV
        const iv = encryptedAndIv.slice(0, INITIALIZATION_VECTOR_LENGTH);
        // Get the Auth tag
        const authTag = encryptedAndIv.slice(INITIALIZATION_VECTOR_LENGTH, INITIALIZATION_VECTOR_LENGTH + AUTH_TAG_LENGTH);
        // Get the encrypted data itself
        const encryptedData = encryptedAndIv.slice(INITIALIZATION_VECTOR_LENGTH + AUTH_TAG_LENGTH);
        // Create the decipher object
        const decipher = (0, crypto_1.createDecipheriv)(AES_256_GCM_ALGORITHM, key, iv);
        decipher.setAuthTag(authTag);
        // Return the buffer decrypted (the call of final() makes the decipher not usable and flush the buffer)
        return Buffer.concat([decipher.update(encryptedData), decipher.final()]);
    });
}
exports.decryptWithAes256gcm = decryptWithAes256gcm;
/**
 * Generates N cryptographically strong pseudo-random bytes
 *
 * @param n the number of bytes to generate
 *
 * @returns Promise resolving the N bytes generated
 */
function randomBytes(n) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            (0, crypto_1.randomBytes)(n, (error, buffer) => {
                if (error) {
                    return reject(`Error generating random bytes: ${error}`);
                }
                return resolve(buffer);
            });
        });
    });
}
//# sourceMappingURL=crypto-wrapper.js.map