"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.notNull = exports.uniqueByProperty = exports.unique = exports.timeoutPromise = exports.isString = exports.getCurrentTimestampInSecond = exports.flatten2DimensionsArray = exports.deepSort = exports.deepCopy = void 0;
const crypto_1 = require("./crypto");
const MILLISECOND_IN_SECOND = 1000;
/**
 * Function to check if a variable is a string
 *
 * @param any variable variable to check
 *
 * @returns boolean true, if variable is a string or a String
 */
function isString(variable) {
    return typeof variable === 'string' || variable instanceof String;
}
exports.isString = isString;
/**
 * Function return a deep copy of the parameter
 *
 * @param any variable variable to copy
 *
 * @returns any the deep copy
 */
function deepCopy(variable) {
    return JSON.parse(JSON.stringify(variable));
}
exports.deepCopy = deepCopy;
/**
 * Function return the object with keys deeply sorted
 *
 * @param any nestedObject the object to deeply sort
 *
 * @returns any the object deeply sorted
 */
function deepSort(nestedObject) {
    // sort objects in arrays
    if (nestedObject instanceof Array) {
        return nestedObject.map((i) => deepSort(i));
    }
    // sort data keys
    if (nestedObject instanceof Object) {
        return Object.keys(nestedObject)
            .sort()
            .reduce((sorted, key) => {
            sorted[key] = deepSort(nestedObject[key]);
            return sorted;
        }, {});
    }
    return nestedObject;
}
exports.deepSort = deepSort;
/**
 * Separates the duplicated object from an array
 * Two object are assumed identical if their normalized Keccak256 hashes are equal
 * Normalize here is a lowed case JSON stringify of the properties alphabetical sorted
 *
 * @param array the array to curate
 * @returns an object containing the array with only unique element and an object with the duplication
 */
function unique(array) {
    const result = array.reduce((accumulator, element) => {
        const hash = (0, crypto_1.normalizeKeccak256Hash)(element);
        if (accumulator.uniqueItemsHashes.includes(hash.value)) {
            // if already included, adds it to the array of duplicates
            accumulator.duplicates.push(element);
        }
        else {
            // if not already included, includes it and reports the hash
            accumulator.uniqueItems.push(element);
            accumulator.uniqueItemsHashes.push(hash.value);
        }
        return accumulator;
    }, { uniqueItems: [], duplicates: [], uniqueItemsHashes: [] });
    return { uniqueItems: result.uniqueItems, duplicates: result.duplicates };
}
exports.unique = unique;
/**
 * Separates the duplicated object from an array from a property
 * Two object are assumed identical if the value of the properties whose name is given in parameter have their normalized Keccak256 hashes equals
 * Normalize here is a lowed case JSON stringify of the properties alphabetical sorted
 *
 * @param array the array to curate
 * @returns an object containing the array with only unique element and an object with the duplication
 */
function uniqueByProperty(array, property) {
    const result = array.reduce((accumulator, element) => {
        const hash = (0, crypto_1.normalizeKeccak256Hash)(element[property]);
        if (accumulator.uniqueItemsHashes.includes(hash.value)) {
            // if already included, adds it to the array of duplicates
            accumulator.duplicates.push(element);
        }
        else {
            // if not already included, includes it and reports the hash
            accumulator.uniqueItems.push(element);
            accumulator.uniqueItemsHashes.push(hash.value);
        }
        return accumulator;
    }, { uniqueItems: [], duplicates: [], uniqueItemsHashes: [] });
    return { uniqueItems: result.uniqueItems, duplicates: result.duplicates };
}
exports.uniqueByProperty = uniqueByProperty;
/**
 * Function return the timestamp in second
 *
 * @returns number current timestamp in second
 */
function getCurrentTimestampInSecond() {
    return Math.floor(Date.now() / MILLISECOND_IN_SECOND);
}
exports.getCurrentTimestampInSecond = getCurrentTimestampInSecond;
/** Function return a two dimensions array flatten
 * @param any[] twoDimensionsArray the array to flatten
 *
 * @returns any[] the flat array
 */
function flatten2DimensionsArray(twoDimensionsArray) {
    return twoDimensionsArray.reduce((accumulator, current) => accumulator.concat(current), []);
}
exports.flatten2DimensionsArray = flatten2DimensionsArray;
/**
 * Function that returns a promise that rejects when the specified timeout is reached
 * @param timeout Timeout threshold to throw the error
 * @param message Timeout error message
 */
function timeoutPromise(promise, timeout, message) {
    const timeoutPromise = new Promise((_resolve, reject) => {
        setTimeout(() => reject(new Error(message)), timeout);
    });
    return Promise.race([timeoutPromise, promise]);
}
exports.timeoutPromise = timeoutPromise;
function notNull(x) {
    return x !== null && x !== undefined;
}
exports.notNull = notNull;
//# sourceMappingURL=utils.js.map