"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeKeccak256Hash = exports.normalize = exports.last20bytesOfNormalizedKeccak256Hash = exports.keccak256Hash = exports.generate8randomBytes = exports.generate32BufferKey = exports.ecSign = exports.ecRecover = exports.getAddressFromPublicKey = exports.getAddressFromPrivateKey = exports.ecEncrypt = exports.ecDecrypt = exports.random32Bytes = exports.encryptWithAes256gcm = exports.encryptWithAes256cbc = exports.decryptWithAes256gcm = exports.decryptWithAes256cbc = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const ethers_1 = require("ethers");
const crypto_wrapper_1 = require("./crypto/crypto-wrapper");
Object.defineProperty(exports, "decryptWithAes256cbc", { enumerable: true, get: function () { return crypto_wrapper_1.decryptWithAes256cbc; } });
Object.defineProperty(exports, "decryptWithAes256gcm", { enumerable: true, get: function () { return crypto_wrapper_1.decryptWithAes256gcm; } });
Object.defineProperty(exports, "encryptWithAes256cbc", { enumerable: true, get: function () { return crypto_wrapper_1.encryptWithAes256cbc; } });
Object.defineProperty(exports, "encryptWithAes256gcm", { enumerable: true, get: function () { return crypto_wrapper_1.encryptWithAes256gcm; } });
Object.defineProperty(exports, "random32Bytes", { enumerable: true, get: function () { return crypto_wrapper_1.random32Bytes; } });
const ec_utils_1 = require("./crypto/ec-utils");
Object.defineProperty(exports, "ecDecrypt", { enumerable: true, get: function () { return ec_utils_1.ecDecrypt; } });
Object.defineProperty(exports, "ecEncrypt", { enumerable: true, get: function () { return ec_utils_1.ecEncrypt; } });
Object.defineProperty(exports, "getAddressFromPrivateKey", { enumerable: true, get: function () { return ec_utils_1.getAddressFromPrivateKey; } });
Object.defineProperty(exports, "getAddressFromPublicKey", { enumerable: true, get: function () { return ec_utils_1.getAddressFromPublicKey; } });
Object.defineProperty(exports, "ecRecover", { enumerable: true, get: function () { return ec_utils_1.ecRecover; } });
Object.defineProperty(exports, "ecSign", { enumerable: true, get: function () { return ec_utils_1.ecSign; } });
const utils_1 = require("./utils");
/**
 * Hashes with the keccak256 algorithm with a normalization before and formats it
 *
 * @notice It will sort the object by keys before hashing
 *
 * @param data The data to hash
 * @returns The hashed data multi-formatted
 */
function normalizeKeccak256Hash(data) {
    return {
        type: types_1.MultiFormatTypes.HashTypes.TYPE.KECCAK256,
        value: keccak256Hash(normalize(data)),
    };
}
exports.normalizeKeccak256Hash = normalizeKeccak256Hash;
/**
 * Normalizes data: sorts the object by keys and convert it in string
 *
 * @param data The data to normalize
 * @returns The normalized data
 */
function normalize(data) {
    if (data === undefined) {
        return 'undefined';
    }
    // deeply sort data keys
    const sortedData = (0, utils_1.deepSort)(data);
    // convert to string and lowerCase it, to be case insensitive (e.g: avoid ethereum address casing checksum)
    return JSON.stringify(sortedData).toLowerCase();
}
exports.normalize = normalize;
/**
 * Hashes with the keccak256 algorithm
 *
 * @param data The string to hash
 * @returns The hashed data multi-formatted
 */
function keccak256Hash(data) {
    return ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(data));
}
exports.keccak256Hash = keccak256Hash;
/**
 * Hashes with the keccak256 algorithm with a normalization before and formats it
 *
 * @notice It will sort the object by keys before hashing
 *
 * @param data The data to hash
 * @returns The hashed data multi-formatted
 */
function last20bytesOfNormalizedKeccak256Hash(data) {
    const hash = keccak256Hash(normalize(data));
    // eslint-disable-next-line no-magic-numbers
    return `0x${hash.slice(-40)}`;
}
exports.last20bytesOfNormalizedKeccak256Hash = last20bytesOfNormalizedKeccak256Hash;
/**
 * Generates a 32 bytes key in a base64 string
 *
 * @returns a random buffer of 32 bytes in a base64 string
 */
function generate32BufferKey() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return (yield (0, crypto_wrapper_1.random32Bytes)()).toString('base64');
    });
}
exports.generate32BufferKey = generate32BufferKey;
/**
 * Generate 8 random bytes and return as a hexadecimal string.
 * Used for salt in ETH input data.
 * Example: 'ea3bc7caf64110ca'
 *
 * @returns a string of 8 random bytes
 */
function generate8randomBytes() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const random32BytesHex = yield (0, crypto_wrapper_1.random32Bytes)();
        return random32BytesHex.slice(0, 8).toString('hex');
    });
}
exports.generate8randomBytes = generate8randomBytes;
//# sourceMappingURL=crypto.js.map