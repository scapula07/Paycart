"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIdentityFromEncryptionParams = exports.encrypt = exports.decrypt = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const index_1 = require("./index");
/**
 * Function to get the identity from the encryption parameters
 *
 * @param encryptionParams encryption parameters
 *
 * @returns the identity behind the encryption parameters
 */
function getIdentityFromEncryptionParams(encryptionParams) {
    if (encryptionParams.method === types_1.EncryptionTypes.METHOD.ECIES) {
        return {
            type: types_1.IdentityTypes.TYPE.ETHEREUM_ADDRESS,
            value: (0, index_1.getAddressFromPublicKey)(encryptionParams.key),
        };
    }
    throw new Error('encryptionParams.method not supported');
}
exports.getIdentityFromEncryptionParams = getIdentityFromEncryptionParams;
/**
 * Encrypts data using encryption parameters
 *
 * @param data the data to sign
 * @param encryptionParams Encryption parameters
 * @returns the encrypted data
 */
function encrypt(data, encryptionParams) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (encryptionParams.method === types_1.EncryptionTypes.METHOD.ECIES) {
            const encryptedData = yield (0, index_1.ecEncrypt)(encryptionParams.key, data);
            return {
                type: types_1.EncryptionTypes.METHOD.ECIES,
                value: encryptedData,
            };
        }
        if (encryptionParams.method === types_1.EncryptionTypes.METHOD.AES256_CBC) {
            const encryptedDataBuffer = yield (0, index_1.encryptWithAes256cbc)(Buffer.from(data, 'utf-8'), Buffer.from(encryptionParams.key, 'base64'));
            return {
                type: types_1.EncryptionTypes.METHOD.AES256_CBC,
                value: encryptedDataBuffer.toString('base64'),
            };
        }
        if (encryptionParams.method === types_1.EncryptionTypes.METHOD.AES256_GCM) {
            const encryptedDataBuffer = yield (0, index_1.encryptWithAes256gcm)(Buffer.from(data, 'utf-8'), Buffer.from(encryptionParams.key, 'base64'));
            return {
                type: types_1.EncryptionTypes.METHOD.AES256_GCM,
                value: encryptedDataBuffer.toString('base64'),
            };
        }
        throw new Error('encryptionParams.method not supported');
    });
}
exports.encrypt = encrypt;
/**
 * Decrypt data using decryption parameters
 *
 * IMPORTANT: This must be used for test purpose only. An decryption provider must be used in production.
 *
 * @param encryptedData the encrypted data
 * @param key the decryption parameters
 * @returns the decrypted data
 */
function decrypt(encryptedData, decryptionParams) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (encryptedData.type === types_1.EncryptionTypes.METHOD.ECIES) {
            if (decryptionParams.method !== types_1.EncryptionTypes.METHOD.ECIES) {
                throw new Error(`decryptionParams.method should be ${types_1.EncryptionTypes.METHOD.ECIES}`);
            }
            return (0, index_1.ecDecrypt)(decryptionParams.key, encryptedData.value);
        }
        if (encryptedData.type === types_1.EncryptionTypes.METHOD.AES256_CBC) {
            if (decryptionParams.method !== types_1.EncryptionTypes.METHOD.AES256_CBC) {
                throw new Error(`decryptionParams.method should be ${types_1.EncryptionTypes.METHOD.AES256_CBC}`);
            }
            const dataBuffer = yield (0, index_1.decryptWithAes256cbc)(
            // remove the multi-format padding and decode from the base64 to a buffer
            Buffer.from(encryptedData.value, 'base64'), Buffer.from(decryptionParams.key, 'base64'));
            return dataBuffer.toString();
        }
        if (encryptedData.type === types_1.EncryptionTypes.METHOD.AES256_GCM) {
            if (decryptionParams.method !== types_1.EncryptionTypes.METHOD.AES256_GCM) {
                throw new Error(`decryptionParams.method should be ${types_1.EncryptionTypes.METHOD.AES256_GCM}`);
            }
            const dataBuffer = yield (0, index_1.decryptWithAes256gcm)(
            // remove the multi-format padding and decode from the base64 to a buffer
            Buffer.from(encryptedData.value, 'base64'), Buffer.from(decryptionParams.key, 'base64'));
            return dataBuffer.toString();
        }
        throw new Error('encryptedData method not supported');
    });
}
exports.decrypt = decrypt;
//# sourceMappingURL=encryption.js.map