import { DataAccessTypes, LogTypes, StorageTypes } from '@requestnetwork/types';
import IgnoredLocationIndex from './ignored-location';
/**
 * Options for the DataAccess initialization
 */
export interface IDataAccessOptions {
    /**
     * Logger instance
     */
    logger: LogTypes.ILogger;
    /**
     *  the transaction index, defaults to TransactionIndex if not set.
     */
    transactionIndex: DataAccessTypes.ITransactionIndex;
    /**
     * synchronizationIntervalTime Interval time between each synchronization
     * Defaults to DEFAULT_INTERVAL_TIME.
     */
    synchronizationIntervalTime: number;
    /**
     * Index of the ignored location with the reason
     */
    ignoredLocationIndex: IgnoredLocationIndex;
    /**
     * Specifies whether to start the synchronization on initialization
     */
    autoStartSynchronization: boolean;
}
/**
 * Implementation of Data-Access layer without encryption
 */
export default class DataAccess implements DataAccessTypes.IDataAccess {
    private transactionIndex;
    protected isInitialized: boolean;
    private storage;
    private ignoredLocationIndex;
    private synchronizationTimer;
    /**
     * Specifies whether to start the synchronization on initialization
     */
    private autoStartSynchronization;
    private lastSyncStorageTimestamp;
    /**
     * Logger instance
     */
    private logger;
    /**
     * Constructor DataAccess interface
     *
     * @param IStorage storage storage object
     */
    constructor(storage: StorageTypes.IStorage, options?: Partial<IDataAccessOptions>);
    /**
     * Function to initialize the dataId topic with the previous block
     */
    initialize(): Promise<void>;
    close(): Promise<void>;
    /**
     * Function to persist transaction and topic in storage
     * For now, we create a block for each transaction
     *
     * @param transaction transaction to persist
     * @param channelId string to identify a bunch of transaction
     * @param topics list of string to topic the transaction
     *
     * @returns string dataId where the transaction is stored
     */
    persistTransaction(transaction: DataAccessTypes.ITransaction, channelId: string, topics?: string[]): Promise<DataAccessTypes.IReturnPersistTransaction>;
    /**
     * Function to get a list of transactions indexed by channel id
     * if timestampBoundaries is given, the search will be restrict from timestamp 'from' to the timestamp 'to'.
     * if timestampBoundaries.from is not given, the search will be start from the very start
     * if timestampBoundaries.to is not given, the search will be stop at the current timestamp
     *
     * @param channelId channel id to retrieve the transaction from
     * @param timestampBoundaries timestamp boundaries of the transactions search
     *
     * @returns list of transactions in the channel
     */
    getTransactionsByChannelId(channelId: string, timestampBoundaries?: DataAccessTypes.ITimestampBoundaries): Promise<DataAccessTypes.IReturnGetTransactions>;
    /**
     * Function to get a list of channels indexed by topic
     *
     * @param topic topic to retrieve the channels from
     * @param updatedBetween filter the channels that have received new data within the time boundaries
     *
     * @returns list of channels indexed by topic
     */
    getChannelsByTopic(topic: string, updatedBetween?: DataAccessTypes.ITimestampBoundaries): Promise<DataAccessTypes.IReturnGetChannelsByTopic>;
    /**
     * Function to get a list of channels indexed by multiple topics
     *
     * @param topics topics to retrieve the channels from
     * @param updatedBetween filter the channels that have received new data within the time boundaries
     *
     * @returns list of channels indexed by topics
     */
    getChannelsByMultipleTopics(topics: string[], updatedBetween?: DataAccessTypes.ITimestampBoundaries): Promise<DataAccessTypes.IReturnGetChannelsByTopic>;
    /**
     * Function to synchronize with the new dataIds on the storage
     */
    synchronizeNewDataIds(): Promise<void>;
    /**
     * Start to synchronize with the storage automatically
     * Once called, synchronizeNewDataId function is called periodically
     */
    startAutoSynchronization(): void;
    /**
     * Stop to synchronize with the storage automatically
     */
    stopAutoSynchronization(): Promise<void>;
    /**
     * Gets information of the data indexed
     *
     * @param detailed if true get the list of the files hashes
     */
    _getStatus(detailed?: boolean): Promise<DataAccessTypes.IDataAccessStatus>;
    /**
     * Check the format of the data, extract the topics from it and push location indexed with the topics
     *
     * @private
     * @param entries data with meta from storage functions
     * @param locationByTopic LocationByTopic object to push location
     */
    private pushLocationsWithTopics;
    /**
     * Gets the blocks and their metadata from an array of storage location
     *
     * @param storageLocationList array of storage location
     * @returns the blocks and their metadata
     */
    private getBlockAndMetaFromStorageLocation;
    /**
     * Gets the transactions and their metadata from a block and an array of transaction positions
     *
     * @param transactionPositions transaction positions to retrieve
     * @param block the block
     * @param location location of the block
     * @param meta metadata of the block
     * @returns the transactions and their metadata
     */
    private getTransactionAndMetaFromPosition;
    /**
     * Throws an error if the data access isn't initialized
     */
    private checkInitialized;
}
//# sourceMappingURL=data-access.d.ts.map