"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const multi_format_1 = require("@requestnetwork/multi-format");
const types_1 = require("@requestnetwork/types");
const utils_1 = require("@requestnetwork/utils");
const Bluebird = require("bluebird");
const events_1 = require("events");
const block_1 = require("./block");
const ignored_location_1 = require("./ignored-location");
const interval_timer_1 = require("./interval-timer");
const transaction_index_1 = require("./transaction-index");
// Default interval time for auto synchronization
const DEFAULT_INTERVAL_TIME = 10000;
const emptyChannelsWithTopics = {
    meta: {
        storageMeta: {},
        transactionsStorageLocation: {},
    },
    result: { transactions: {} },
};
/**
 * Implementation of Data-Access layer without encryption
 */
class DataAccess {
    /**
     * Constructor DataAccess interface
     *
     * @param IStorage storage storage object
     */
    constructor(storage, options) {
        // boolean to store the initialization state
        this.isInitialized = false;
        const defaultOptions = {
            ignoredLocationIndex: new ignored_location_1.default(),
            logger: new utils_1.SimpleLogger(),
            synchronizationIntervalTime: DEFAULT_INTERVAL_TIME,
            transactionIndex: new transaction_index_1.default(),
            autoStartSynchronization: false,
        };
        const { ignoredLocationIndex, logger, synchronizationIntervalTime, transactionIndex, autoStartSynchronization, } = Object.assign(Object.assign({}, defaultOptions), options);
        this.storage = storage;
        this.lastSyncStorageTimestamp = 0;
        this.autoStartSynchronization = autoStartSynchronization;
        this.synchronizationTimer = new interval_timer_1.default(() => this.synchronizeNewDataIds(), synchronizationIntervalTime, logger, 5);
        this.transactionIndex = transactionIndex;
        this.ignoredLocationIndex = ignoredLocationIndex;
        this.logger = logger;
    }
    /**
     * Function to initialize the dataId topic with the previous block
     */
    initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.isInitialized) {
                throw new Error('already initialized');
            }
            yield this.transactionIndex.initialize();
            // initialize storage
            yield this.storage.initialize();
            // if transaction index already has data, then sync from the last available timestamp
            const lastSynced = yield this.transactionIndex.getLastTransactionTimestamp();
            const now = (0, utils_1.getCurrentTimestampInSecond)();
            // initialize the dataId topic with the previous block
            const allDataWithMeta = yield this.storage.getData(lastSynced
                ? {
                    from: lastSynced,
                    to: now,
                }
                : undefined);
            // The last synced timestamp is the latest one returned by storage
            this.lastSyncStorageTimestamp = allDataWithMeta.lastTimestamp;
            // check if the data returned by getData are correct
            // if yes, the dataIds are indexed with LocationByTopic
            yield this.pushLocationsWithTopics(allDataWithMeta.entries);
            this.isInitialized = true;
            if (this.autoStartSynchronization) {
                this.startAutoSynchronization();
            }
        });
    }
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.stopAutoSynchronization();
        });
    }
    /**
     * Function to persist transaction and topic in storage
     * For now, we create a block for each transaction
     *
     * @param transaction transaction to persist
     * @param channelId string to identify a bunch of transaction
     * @param topics list of string to topic the transaction
     *
     * @returns string dataId where the transaction is stored
     */
    persistTransaction(transaction, channelId, topics = []) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.checkInitialized();
            // get all the topics not well formatted
            const notFormattedTopics = topics.filter((topic) => !multi_format_1.default.hashFormat.isDeserializableString(topic));
            if (notFormattedTopics.length !== 0) {
                throw new Error(`The following topics are not well formatted: ${JSON.stringify(notFormattedTopics)}`);
            }
            // create a block and add the transaction in it
            const updatedBlock = block_1.default.pushTransaction(block_1.default.createEmptyBlock(), transaction, channelId, topics);
            // get the topic of the data in storage
            const resultAppend = yield this.storage.append(JSON.stringify(updatedBlock));
            const result = Object.assign(new events_1.EventEmitter(), {
                meta: {
                    storageMeta: resultAppend.meta,
                    topics,
                    transactionStorageLocation: resultAppend.id,
                },
                result: {},
            });
            // Store the data to the real storage
            resultAppend
                .on('confirmed', (resultAppendConfirmed) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                // update the timestamp with the confirmed one
                yield this.transactionIndex.updateTimestamp(resultAppendConfirmed.id, resultAppendConfirmed.meta.timestamp);
                const resultAfterConfirmation = {
                    meta: {
                        storageMeta: resultAppendConfirmed.meta,
                        topics,
                        transactionStorageLocation: resultAppendConfirmed.id,
                    },
                    result: {},
                };
                result.emit('confirmed', resultAfterConfirmation);
            }))
                .on('error', (error) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                result.emit('error', error);
            }));
            // adds this transaction to the index, to enable retrieving it later.
            yield this.transactionIndex.addTransaction(resultAppend.id, updatedBlock.header, resultAppend.meta.timestamp);
            return result;
        });
    }
    /**
     * Function to get a list of transactions indexed by channel id
     * if timestampBoundaries is given, the search will be restrict from timestamp 'from' to the timestamp 'to'.
     * if timestampBoundaries.from is not given, the search will be start from the very start
     * if timestampBoundaries.to is not given, the search will be stop at the current timestamp
     *
     * @param channelId channel id to retrieve the transaction from
     * @param timestampBoundaries timestamp boundaries of the transactions search
     *
     * @returns list of transactions in the channel
     */
    getTransactionsByChannelId(channelId, timestampBoundaries) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.checkInitialized();
            // Gets the list of locationStorage indexed by the channel id that are within the boundaries
            const storageLocationList = yield this.transactionIndex.getStorageLocationList(channelId, timestampBoundaries);
            // Gets the block and meta from the storage location
            const blockWithMetaList = yield this.getBlockAndMetaFromStorageLocation(storageLocationList);
            // Get the transactions (and the meta) indexed by channelIds in the blocks found
            const transactionsAndMetaPerBlocks = 
            // for all the blocks found
            blockWithMetaList.map((blockAndMeta) => {
                // Gets the list of positions of the transaction needed from the block
                const transactionPositions = block_1.default.getTransactionPositionFromChannelId(blockAndMeta.block, channelId);
                return this.getTransactionAndMetaFromPosition(transactionPositions, blockAndMeta.block, blockAndMeta.location, blockAndMeta.meta);
            });
            // Creates the result by concatenating the transactions and meta of every blocks
            return transactionsAndMetaPerBlocks.reduce((accumulator, elem) => ({
                meta: {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    storageMeta: accumulator.meta.storageMeta.concat(elem.storageMeta),
                    transactionsStorageLocation: accumulator.meta.transactionsStorageLocation.concat(elem.transactionsStorageLocation),
                },
                result: {
                    transactions: accumulator.result.transactions.concat(elem.transactions),
                },
            }), 
            // initial value is full of empty arrays
            {
                meta: { storageMeta: [], transactionsStorageLocation: [] },
                result: { transactions: [] },
            });
        });
    }
    /**
     * Function to get a list of channels indexed by topic
     *
     * @param topic topic to retrieve the channels from
     * @param updatedBetween filter the channels that have received new data within the time boundaries
     *
     * @returns list of channels indexed by topic
     */
    getChannelsByTopic(topic, updatedBetween) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.checkInitialized();
            // check if the topic is well formatted
            if (!multi_format_1.default.hashFormat.isDeserializableString(topic)) {
                throw new Error(`The topic is not well formatted: ${topic}`);
            }
            const channelIds = yield this.transactionIndex.getChannelIdsForTopic(topic, updatedBetween);
            // Gets the transactions per channel id
            const transactionsAndMeta = Bluebird.map(channelIds, (channelId) => this.getTransactionsByChannelId(channelId).then((transactionsWithMeta) => ({
                channelId,
                transactionsWithMeta,
            })));
            // Gather all the transactions in one object
            return transactionsAndMeta.reduce((finalResult, channelIdAndTransactions) => {
                const id = channelIdAndTransactions.channelId;
                // Adds the storage location of the channel's data
                finalResult.meta.transactionsStorageLocation[id] =
                    channelIdAndTransactions.transactionsWithMeta.meta.transactionsStorageLocation;
                // Adds the meta of the channel
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                finalResult.meta.storageMeta[id] =
                    channelIdAndTransactions.transactionsWithMeta.meta.storageMeta;
                // Adds the transaction of the channel
                finalResult.result.transactions[id] =
                    channelIdAndTransactions.transactionsWithMeta.result.transactions;
                return finalResult;
            }, (0, utils_1.deepCopy)(emptyChannelsWithTopics));
        });
    }
    /**
     * Function to get a list of channels indexed by multiple topics
     *
     * @param topics topics to retrieve the channels from
     * @param updatedBetween filter the channels that have received new data within the time boundaries
     *
     * @returns list of channels indexed by topics
     */
    getChannelsByMultipleTopics(topics, updatedBetween) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.checkInitialized();
            if (topics.some((topic) => !multi_format_1.default.hashFormat.isDeserializableString(topic))) {
                throw new Error(`The topics are not well formatted`);
            }
            const channelIds = yield this.transactionIndex.getChannelIdsForMultipleTopics(topics, updatedBetween);
            // Gets the transactions per channel id
            const transactionsAndMeta = Bluebird.map(channelIds, (channelId) => this.getTransactionsByChannelId(channelId).then((transactionsWithMeta) => ({
                channelId,
                transactionsWithMeta,
            })));
            // Gather all the transactions in one object
            return transactionsAndMeta.reduce((finalResult, channelIdAndTransactions) => {
                const id = channelIdAndTransactions.channelId;
                // Adds the storage location of the channel's data
                finalResult.meta.transactionsStorageLocation[id] =
                    channelIdAndTransactions.transactionsWithMeta.meta.transactionsStorageLocation;
                // Adds the meta of the channel
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                finalResult.meta.storageMeta[id] =
                    channelIdAndTransactions.transactionsWithMeta.meta.storageMeta;
                // Adds the transaction of the channel
                finalResult.result.transactions[id] =
                    channelIdAndTransactions.transactionsWithMeta.result.transactions;
                return finalResult;
            }, (0, utils_1.deepCopy)(emptyChannelsWithTopics));
        });
    }
    /**
     * Function to synchronize with the new dataIds on the storage
     */
    synchronizeNewDataIds() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.checkInitialized();
            const synchronizationTo = (0, utils_1.getCurrentTimestampInSecond)();
            // We increment lastSyncStorageTimestamp because the data located at lastSyncStorageTimestamp
            // 0 means it's the first synchronization
            let synchronizationFrom = 0;
            if (this.lastSyncStorageTimestamp > 0) {
                synchronizationFrom = this.lastSyncStorageTimestamp + 1;
            }
            // Read new data from storage
            const newDataWithMeta = yield this.storage.getData({
                from: synchronizationFrom,
                to: synchronizationTo,
            });
            // Try to get some data previously ignored
            const oldEntriesWithMeta = yield this.storage.getIgnoredData();
            // check if the data returned by getNewDataId are correct
            // if yes, the dataIds are indexed with LocationByTopic
            yield this.pushLocationsWithTopics(newDataWithMeta.entries.concat(oldEntriesWithMeta));
            // The last synced timestamp is the latest one returned by storage
            this.lastSyncStorageTimestamp = newDataWithMeta.lastTimestamp;
        });
    }
    /**
     * Start to synchronize with the storage automatically
     * Once called, synchronizeNewDataId function is called periodically
     */
    startAutoSynchronization() {
        this.checkInitialized();
        this.synchronizationTimer.start();
    }
    /**
     * Stop to synchronize with the storage automatically
     */
    stopAutoSynchronization() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.synchronizationTimer.isStarted) {
                yield this.synchronizationTimer.stop();
            }
        });
    }
    /**
     * Gets information of the data indexed
     *
     * @param detailed if true get the list of the files hashes
     */
    _getStatus(detailed = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.checkInitialized();
            // last transaction timestamp retrieved
            const lastLocationTimestamp = yield this.transactionIndex.getLastTransactionTimestamp();
            const listIndexedLocation = yield this.transactionIndex.getIndexedLocations();
            const listIgnoredLocationIndex = yield this.ignoredLocationIndex.getIgnoredLocations();
            const synchronizationConfig = this.synchronizationTimer.getConfig();
            return {
                filesIgnored: {
                    count: Object.keys(listIgnoredLocationIndex).length,
                    list: detailed ? listIgnoredLocationIndex : undefined,
                },
                filesRetrieved: {
                    count: listIndexedLocation.length,
                    lastTimestamp: lastLocationTimestamp,
                    list: detailed ? listIndexedLocation : undefined,
                },
                lastSynchronizationTimestamp: this.lastSyncStorageTimestamp,
                storage: yield this.storage._getStatus(detailed),
                synchronizationConfig,
            };
        });
    }
    /**
     * Check the format of the data, extract the topics from it and push location indexed with the topics
     *
     * @private
     * @param entries data with meta from storage functions
     * @param locationByTopic LocationByTopic object to push location
     */
    pushLocationsWithTopics(entries) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!entries) {
                throw Error(`data from storage do not follow the standard`);
            }
            let parsingErrorCount = 0;
            let proceedCount = 0;
            yield Bluebird.each(entries, (entry) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!entry.content || !entry.id) {
                    throw Error(`data from storage do not follow the standard`);
                }
                let block;
                const blockString = entry.content;
                try {
                    block = block_1.default.parseBlock(blockString);
                    proceedCount++;
                    // adds this transaction to the index, to enable retrieving it later.
                    yield this.transactionIndex.addTransaction(entry.id, block.header, entry.meta.timestamp);
                }
                catch (e) {
                    parsingErrorCount++;
                    // Index ignored Location
                    yield this.ignoredLocationIndex.pushReasonByLocation(entry.id, e.message);
                    this.logger.debug(`Error: can't parse content of the dataId (${entry.id}): ${e}`, [
                        'synchronization',
                    ]);
                }
            }));
            this.logger.info(`Synchronization: ${proceedCount} blocks synchronized, ${parsingErrorCount} ignored from parsing error`, ['synchronization']);
        });
    }
    /**
     * Gets the blocks and their metadata from an array of storage location
     *
     * @param storageLocationList array of storage location
     * @returns the blocks and their metadata
     */
    getBlockAndMetaFromStorageLocation(storageLocationList) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Gets blocks indexed by topic
            return Promise.all(storageLocationList.map((location) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const resultRead = yield this.storage.read(location);
                return {
                    block: block_1.default.parseBlock(resultRead.content),
                    location,
                    meta: resultRead.meta,
                };
            })));
        });
    }
    /**
     * Gets the transactions and their metadata from a block and an array of transaction positions
     *
     * @param transactionPositions transaction positions to retrieve
     * @param block the block
     * @param location location of the block
     * @param meta metadata of the block
     * @returns the transactions and their metadata
     */
    getTransactionAndMetaFromPosition(transactionPositions, block, location, meta) {
        // Gets the transaction from the positions
        const transactions = 
        // first remove de duplicates
        (0, utils_1.unique)(transactionPositions).uniqueItems.map(
        // Get the transaction from their position and add the timestamp
        (position) => ({
            state: meta.state === types_1.StorageTypes.ContentState.CONFIRMED
                ? types_1.DataAccessTypes.TransactionState.CONFIRMED
                : types_1.DataAccessTypes.TransactionState.PENDING,
            timestamp: meta.timestamp,
            transaction: block.transactions[position],
        }));
        // Gets the list of storage location of the transactions found
        const transactionsStorageLocation = Array(transactions.length).fill(location);
        // Gets the list of storage meta of the transactions found
        const storageMeta = transactions.map(() => meta);
        return { transactions, transactionsStorageLocation, storageMeta };
    }
    /**
     * Throws an error if the data access isn't initialized
     */
    checkInitialized() {
        if (!this.isInitialized) {
            throw new Error('DataAccess must be initialized');
        }
    }
}
exports.default = DataAccess;
//# sourceMappingURL=data-access.js.map