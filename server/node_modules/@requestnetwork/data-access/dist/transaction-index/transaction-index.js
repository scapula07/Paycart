"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const Bluebird = require("bluebird");
const Keyv = require("keyv");
const location_by_topic_1 = require("./location-by-topic");
const timestamp_by_location_1 = require("./timestamp-by-location");
/**
 * An in-memory implementation of the transaction index.
 */
class TransactionIndex {
    /**
     * Constructor of TransactionIndex
     * @param store a Keyv store to persist the index
     */
    constructor(store) {
        this.timestampByLocation = new timestamp_by_location_1.default(store);
        this.locationByTopic = new location_by_topic_1.default(store);
        this.indexedLocation = new Keyv({
            namespace: 'indexedLocation',
            store,
        });
    }
    // eslint-disable-next-line no-empty, @typescript-eslint/no-empty-function
    initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { });
    }
    /**
     * Get the last indexed timestamp
     */
    getLastTransactionTimestamp() {
        return this.timestampByLocation.getLastTransactionTimestamp();
    }
    /**
     * Adds a transaction to the index, for indexing by channel, topic and timestamp
     *
     * @param dataId the dataId to index
     * @param header the headers of the block (containing channels and topics)
     * @param timestamp the timestamp of the transaction
     */
    addTransaction(dataId, header, timestamp) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.locationByTopic) {
                throw new Error('TransactionIndex must be initialized');
            }
            // topic the dataId with block topic
            yield this.locationByTopic.pushStorageLocationIndexedWithBlockTopics(dataId, header);
            // add the timestamp in the index
            yield this.timestampByLocation.pushTimestampByLocation(dataId, timestamp);
            yield this.updateIndexedLocation(dataId);
        });
    }
    /**
     * Removes a transaction from the index
     *
     * @param dataId the dataId to remove
     */
    removeTransaction(dataId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.locationByTopic) {
                throw new Error('TransactionIndex must be initialized');
            }
            // remove the timestamp in the index
            yield this.timestampByLocation.removeIndexedDataId(dataId);
        });
    }
    /**
     * Update timestamp for a dataId
     *
     * @param dataId the dataId to index
     * @param timestamp the timestamp of the transaction
     */
    updateTimestamp(dataId, timestamp) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.timestampByLocation) {
                throw new Error('TransactionIndex must be initialized');
            }
            // update the timestamp in the index
            yield this.timestampByLocation.updateTimestampByLocation(dataId, timestamp);
        });
    }
    /**
     * Get a list of transactions indexed by channel id
     * @param channelId channel id to retrieve the transaction from
     * @param timestampBoundaries timestamp boundaries of the transactions search
     * @returns list of location of a channel
     */
    getStorageLocationList(channelId, timestampBoundaries) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.locationByTopic) {
                throw new Error('TransactionIndex must be initialized');
            }
            // get transaction locations for the given channel
            let storageLocationList = yield this.locationByTopic.getStorageLocationsFromChannelId(channelId);
            storageLocationList = yield Bluebird.filter(storageLocationList, (dataId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                // if the dataId has not been suppressed
                const exist = (yield this.timestampByLocation.getTimestampFromLocation(dataId)) !== null;
                // if boundaries are passed, only return locations of transaction within these boundaries
                const inTimeBoundaries = !timestampBoundaries ||
                    (yield this.timestampByLocation.isDataInBoundaries(dataId, timestampBoundaries));
                return exist && inTimeBoundaries;
            }));
            return storageLocationList;
        });
    }
    /**
     * Get a list of channels indexed by topic
     * @param topic topic to retrieve the channelIds from
     * @param timestampBoundaries timestamp boundaries of the transactions search
     * @returns list of location of the channels indexed by the topic
     */
    getChannelIdsForTopic(topic, timestampBoundaries) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.locationByTopic) {
                throw new Error('TransactionIndex must be initialized');
            }
            // get channels for given topic
            const channelIds = yield this.locationByTopic.getChannelIdsFromTopic(topic);
            // if boundaries are passed, only return channelIds with transactions within these boundaries
            if (timestampBoundaries) {
                const result = [];
                // check for each channel if one of its transactions occurred during the given boundaries
                for (const channelId of channelIds) {
                    const txLocations = yield this.locationByTopic.getStorageLocationsFromChannelId(channelId);
                    for (const txLocation of txLocations) {
                        const isInBoundaries = yield this.timestampByLocation.isDataInBoundaries(txLocation, timestampBoundaries);
                        if (isInBoundaries) {
                            result.push(channelId);
                            break;
                        }
                    }
                }
                return result;
            }
            else {
                return channelIds;
            }
        });
    }
    /**
     * Get a list of channels indexed by topics
     * @param topics topics to retrieve the channelIds from
     * @param timestampBoundaries timestamp boundaries of the transactions search
     * @returns list of location of the channels indexed by the topics
     */
    getChannelIdsForMultipleTopics(topics, timestampBoundaries) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.locationByTopic) {
                throw new Error('TransactionIndex must be initialized');
            }
            // get channels for given topics
            const channelIds = yield this.locationByTopic.getChannelIdsFromMultipleTopics(topics);
            // if boundaries are passed, only return channelIds with transactions within these boundaries
            if (timestampBoundaries) {
                const result = [];
                // check for each channel if one of its transactions occurred inside the given boundaries
                for (const channelId of channelIds) {
                    const txLocations = yield this.locationByTopic.getStorageLocationsFromChannelId(channelId);
                    for (const txLocation of txLocations) {
                        const isInBoundaries = yield this.timestampByLocation.isDataInBoundaries(txLocation, timestampBoundaries);
                        if (isInBoundaries) {
                            result.push(channelId);
                            break;
                        }
                    }
                }
                return result;
            }
            else {
                return channelIds;
            }
        });
    }
    /**
     * the list of indexed locations
     */
    getIndexedLocations() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const listDataIds = yield this.indexedLocation.get('list');
            return listDataIds || [];
        });
    }
    /**
     * Update the list of data ids stored
     *
     * @param dataId data id to add to the list
     * @returns
     */
    updateIndexedLocation(dataId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let listDataIds = yield this.indexedLocation.get('list');
            if (!listDataIds) {
                listDataIds = [];
            }
            // push it if not already done
            if (!listDataIds.includes(dataId)) {
                listDataIds.push(dataId);
                yield this.indexedLocation.set('list', listDataIds);
            }
        });
    }
}
exports.default = TransactionIndex;
//# sourceMappingURL=transaction-index.js.map