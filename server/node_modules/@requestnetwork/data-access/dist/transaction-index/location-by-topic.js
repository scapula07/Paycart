"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const Keyv = require("keyv");
const utils_1 = require("@requestnetwork/utils");
// Serialize function used for keyv to serialize a Set data structure into a string
// There is no way to directly stringify a Set, we need to convert it to an array before
// Typescript error from keyv: deserialized's type should be { value: Set<string>, expires: number }
// but it's inferred as a Set<string>
const serializeSet = (deserialized) => JSON.stringify(Array.from(deserialized.value));
// Deserialize function used for keyv to deserialize a string into a Set data structure
// Typescript error from keyv: function return's type should be { value: Set<string>, expires: number }
// but it's inferred as a Set<string>
const deserializeSet = (serialized) => {
    // We use JSON.parse to convert the string into an array before converting it to a Set
    const set = new Set(JSON.parse(serialized));
    return { value: set };
};
/**
 * Helps store and retrieve channelIds by topic, and transaction location per channelId
 */
class LocationByTopicTransactionIndex {
    /**
     * Constructor for LocationByTopicIndex
     * @param store a Keyv store to persist the index to.
     */
    constructor(store) {
        this.storageLocationByChannelId = new Keyv({
            deserialize: deserializeSet,
            namespace: 'storageLocationByChannelId',
            serialize: serializeSet,
            store,
        });
        this.channelIdByTopics = new Keyv({
            deserialize: deserializeSet,
            namespace: 'channelIdByTopics',
            serialize: serializeSet,
            store,
        });
    }
    /**
     * Function to push location indexed with block topics
     *
     * @param storageLocation storage location to index
     * @param blockHeader header of the block
     */
    pushStorageLocationIndexedWithBlockTopics(storageLocation, blockHeader) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // index the new block with the channel ids
            for (const id of Object.keys(blockHeader.channelIds)) {
                const existingLocationIds = (yield this.storageLocationByChannelId.get(id)) || new Set([]);
                yield this.storageLocationByChannelId.set(id, existingLocationIds.add(storageLocation));
            }
            // index channel ids by the topics
            for (const id of Object.keys(blockHeader.topics)) {
                for (const topic of blockHeader.topics[id]) {
                    const existingChannelIds = (yield this.channelIdByTopics.get(topic)) || new Set([]);
                    yield this.channelIdByTopics.set(topic, existingChannelIds.add(id));
                }
            }
        });
    }
    /**
     * Function to get the channel ids from a topic
     *
     * @param topic topic to retrieve the dataId
     * @returns list of the channel ids connected to the topic
     */
    getChannelIdsFromTopic(topic) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return Array.from((yield this.channelIdByTopics.get(topic)) || []);
        });
    }
    /**
     * Function to get the channel ids from multiple topics
     *
     * @param topics topics to retrieve the dataIds
     * @returns list of the channel ids linked to the topics
     */
    getChannelIdsFromMultipleTopics(topics) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const channelIdsPromises = topics.map((topic) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                return Array.from((yield this.channelIdByTopics.get(topic)) || []);
            }));
            const channelIds = yield Promise.all(channelIdsPromises);
            // flatten the array of array and remove the duplicates
            return (0, utils_1.unique)((0, utils_1.flatten2DimensionsArray)(channelIds)).uniqueItems;
        });
    }
    /**
     * Function to get storage locations from a channel id
     *
     * @param channelId channel id to retrieve the storage location
     * @returns list of the location connected to the channel id
     */
    getStorageLocationsFromChannelId(channelId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return Array.from((yield this.storageLocationByChannelId.get(channelId)) || []);
        });
    }
}
exports.default = LocationByTopicTransactionIndex;
//# sourceMappingURL=location-by-topic.js.map