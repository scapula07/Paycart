"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const Keyv = require("keyv");
/**
 * Class used to store the block's timestamp indexed by location
 */
class TimestampByLocationTransactionIndex {
    /**
     * TimestampByLocationTransactionIndex constructor
     * @param store a Keyv store to persist the index to
     */
    constructor(store) {
        this.timestampByLocation = new Keyv({
            namespace: 'timestampByLocation',
            store,
        });
    }
    /**
     * Function to push timestamp indexed by location
     *
     * @param dataId dataId of the block
     * @param timestamp timestamp of the block
     */
    pushTimestampByLocation(dataId, timestamp) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!(yield this.timestampByLocation.get(dataId))) {
                yield this.timestampByLocation.set(dataId, timestamp);
            }
            const lastTransactionTimestamp = yield this.getLastTransactionTimestamp();
            if (!lastTransactionTimestamp || timestamp > lastTransactionTimestamp) {
                yield this.setLastTransactionTimestamp(timestamp);
            }
        });
    }
    /**
     * Removes timestamp indexed by location
     *
     * @param dataId dataId of the block
     */
    removeIndexedDataId(dataId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.timestampByLocation.delete(dataId);
        });
    }
    /**
     * Function to update timestamp indexed by location
     *
     * @param dataId dataId of the block
     * @param timestamp timestamp of the block
     */
    updateTimestampByLocation(dataId, timestamp) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.timestampByLocation.set(dataId, timestamp);
            const lastTransactionTimestamp = yield this.getLastTransactionTimestamp();
            if (!lastTransactionTimestamp || timestamp > lastTransactionTimestamp) {
                yield this.setLastTransactionTimestamp(timestamp);
            }
        });
    }
    /**
     * Function to get timestamp from location
     *
     * @param dataId location to get the timestamp from
     * @returns timestamp of the location, null if not found
     */
    getTimestampFromLocation(dataId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const timestamp = yield this.timestampByLocation.get(dataId);
            return timestamp !== undefined ? timestamp : null;
        });
    }
    /**
     * Function to get timestamp from location
     *
     * @param dataId location to get the timestamp from
     * @returns timestamp of the location, null if not found
     */
    isDataInBoundaries(dataId, boundaries) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const timestamp = yield this.timestampByLocation.get(dataId);
            if (!timestamp) {
                throw Error(`Unknown timestamp for the dataId ${dataId}`);
            }
            return (!boundaries ||
                ((boundaries.from === undefined || boundaries.from <= timestamp) &&
                    (boundaries.to === undefined || boundaries.to >= timestamp)));
        });
    }
    /**
     * the timestamp of the latest transaction
     */
    getLastTransactionTimestamp() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (yield this.timestampByLocation.get('last_transaction_timestamp')) || null;
        });
    }
    /**
     * the timestamp of the latest transaction
     */
    setLastTransactionTimestamp(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.timestampByLocation.set('last_transaction_timestamp', value);
        });
    }
}
exports.default = TimestampByLocationTransactionIndex;
//# sourceMappingURL=timestamp-by-location.js.map