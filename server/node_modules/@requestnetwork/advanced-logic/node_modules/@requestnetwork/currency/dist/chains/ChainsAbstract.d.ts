import { Chain } from '../types';
import { CurrencyTypes, RequestLogicTypes } from '@requestnetwork/types';
export declare abstract class ChainsAbstract<CHAIN_NAME extends CurrencyTypes.ChainName, CHAIN extends Chain, CHAIN_ID extends string | number> {
    chains: Record<CHAIN_NAME, CHAIN>;
    chainNames: CHAIN_NAME[];
    constructor(chains: Record<CHAIN_NAME, CHAIN>, currencyType: RequestLogicTypes.CURRENCY.ETH | RequestLogicTypes.CURRENCY.BTC);
    /**
     * Adds the native currency to the list of currencies supported by each chain
     */
    private addNativeCurrenciesToChains;
    /**
     * Check if chainName lives amongst the list of supported chains by this chain type.
     * Throws in the case it's not supported.
     */
    assertChainSupported(chainName?: string): asserts chainName is CHAIN_NAME;
    /**
     * Check if chainName lives amongst the list of supported chains by this chain type.
     */
    isChainSupported(chainName?: string): chainName is CHAIN_NAME;
    /**
     * Retrieve the corresponding chain ID from Request Network's internal chain name representation
     */
    getChainId(chainName: CHAIN_NAME): CHAIN_ID;
    /**
     * Retrieve Request Network's internal chain name representation from the corresponding chain ID
     */
    getChainName(chainId: CHAIN_ID): CHAIN_NAME | undefined;
    /**
     * Returns true is the chain is a testnet chain
     */
    isTestnet(chainName: CHAIN_NAME): boolean;
    /**
     * @returns true if both chains have the same ID or same name
     */
    isSameChain: (chain1: CHAIN_NAME, chain2: CHAIN_NAME) => boolean;
    /**
     * @returns true if both chains have the same ID or same name
     */
    isSameChainFromString: (chain1: string, chain2: string) => boolean;
}
//# sourceMappingURL=ChainsAbstract.d.ts.map