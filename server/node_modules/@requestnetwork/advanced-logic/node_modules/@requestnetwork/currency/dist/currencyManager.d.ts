import { CurrencyTypes } from '@requestnetwork/types';
import { StorageCurrency, CurrencyDefinition, CurrencyInput, ICurrencyManager, LegacyTokenMap, NativeCurrencyType } from './types';
import { AggregatorsMap } from './conversion-aggregators';
/**
 * Handles a list of currencies and provide features to retrieve them, as well as convert to/from storage format
 */
export declare class CurrencyManager<TMeta = unknown> implements ICurrencyManager<TMeta> {
    private readonly knownCurrencies;
    private readonly legacyTokens;
    private readonly conversionPairs;
    /**
     *
     * @param inputCurrencies The list of currencies known by the Manager.
     * @param legacyTokens A mapping of legacy currency name or network name, in the format { "chainName": {"TOKEN": ["NEW_TOKEN","NEW_CHAIN"]}}
     * @param conversionPairs A mapping of possible conversions by network (network => currencyFrom => currencyTo => cost)
     */
    constructor(inputCurrencies: (CurrencyInput & {
        id?: string;
        meta?: TMeta;
    })[], legacyTokens?: LegacyTokenMap, conversionPairs?: AggregatorsMap);
    /**
     * Gets a supported currency from a symbol, symbol-network, currency definition id or address.
     *
     * @param currencyIdentifier e.g. 'DAI', 'FAU', 'FAU-rinkeby', 'ETH-rinkeby-rinkeby' or '0xFab46E002BbF0b4509813474841E0716E6730136'
     * @param network e.g. rinkeby, mainnet
     */
    from(currencyIdentifier: string | undefined, network?: CurrencyTypes.ChainName): CurrencyDefinition<TMeta> | undefined;
    /**
     * Gets a supported currency from its CurrencyDefinition id
     */
    fromId(id: string): CurrencyDefinition<TMeta> | undefined;
    /**
     * Gets a supported currency from its address and network.
     * If more than one currency are found, undefined is returned
     */
    fromAddress(address: string, network?: string): CurrencyDefinition<TMeta> | undefined;
    /**
     * Gets a supported currency from its symbol and network.
     */
    fromSymbol(symbol: string, network?: CurrencyTypes.ChainName): CurrencyDefinition<TMeta> | undefined;
    fromHash(hash: string, network?: string): CurrencyDefinition<TMeta> | undefined;
    /**
     * Retrieves a currency given its storage format (ICurrency)
     */
    fromStorageCurrency(currency: StorageCurrency): CurrencyDefinition<TMeta> | undefined;
    /**
     * Retrieves a Native currency for a type and network
     */
    getNativeCurrency(type: NativeCurrencyType, network: string): CurrencyDefinition<TMeta> | undefined;
    getConversionPath(from: Pick<CurrencyDefinition, 'hash'>, to: Pick<CurrencyDefinition, 'hash'>, network: CurrencyTypes.ChainName): string[] | null;
    supportsConversion(currency: Pick<CurrencyDefinition, 'hash'>, network: CurrencyTypes.ChainName): boolean;
    /**
     * Adds computed parameters to a CurrencyInput
     */
    static fromInput<TMeta = unknown>({ id, hash, meta, ...input }: CurrencyInput & {
        id?: string;
        hash?: string;
        meta?: TMeta;
    }): CurrencyDefinition<TMeta>;
    /**
     * Utility function to compute the unique identifier
     */
    static currencyId(currency: CurrencyInput): string;
    /**
     * Converts a currency to the storage format (ICurrency)
     */
    static toStorageCurrency(currency: CurrencyInput): StorageCurrency;
    /**
     * Validates an address for a given currency.
     * Throws if the currency is an ISO4217 currency.
     */
    static validateAddress(address: string, currency: CurrencyInput | StorageCurrency): boolean;
    /**
     * Validate the correctness of a Storage Currency
     */
    static validateCurrency(currency: StorageCurrency): boolean;
    /**
     * Returns the list of currencies supported by Request out of the box
     * Contains:
     * - ISO currencies
     * - ERC20 currencies from Metamask/contract-metadata + some additional tokens
     * - ERC777 SuperTokens managed by SuperFluid
     * - ETH, & some EVM-compatible chains native tokens
     * - NEAR, YEL, ZIL, BTC
     * - ETH-rinkeby, FAU-rinkeby, CTBK-rinkeby
     */
    static getDefaultList(): CurrencyDefinition[];
    /**
     * Returns the default list of legacy names (for symbol or network)
     */
    static getDefaultLegacyTokens(): LegacyTokenMap;
    static getDefaultConversionPairs(): AggregatorsMap;
    /**
     * Returns a default instance of CurrencyManager based on default lists
     */
    static getDefault(): CurrencyManager;
}
//# sourceMappingURL=currencyManager.d.ts.map