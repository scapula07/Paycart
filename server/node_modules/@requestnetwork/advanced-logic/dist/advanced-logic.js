"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@requestnetwork/types");
const currency_1 = require("@requestnetwork/currency");
const content_data_1 = require("./extensions/content-data");
const mainnet_address_based_1 = require("./extensions/payment-network/bitcoin/mainnet-address-based");
const testnet_address_based_1 = require("./extensions/payment-network/bitcoin/testnet-address-based");
const declarative_1 = require("./extensions/payment-network/declarative");
const address_based_1 = require("./extensions/payment-network/erc20/address-based");
const fee_proxy_contract_1 = require("./extensions/payment-network/erc20/fee-proxy-contract");
const proxy_contract_1 = require("./extensions/payment-network/erc20/proxy-contract");
const stream_1 = require("./extensions/payment-network/erc777/stream");
const fee_proxy_contract_2 = require("./extensions/payment-network/ethereum/fee-proxy-contract");
const input_data_1 = require("./extensions/payment-network/ethereum/input-data");
const near_native_1 = require("./extensions/payment-network/near/near-native");
const near_testnet_native_1 = require("./extensions/payment-network/near/near-testnet-native");
const any_to_erc20_proxy_1 = require("./extensions/payment-network/any-to-erc20-proxy");
const any_to_eth_proxy_1 = require("./extensions/payment-network/any-to-eth-proxy");
const any_to_near_1 = require("./extensions/payment-network/near/any-to-near");
const any_to_near_testnet_1 = require("./extensions/payment-network/near/any-to-near-testnet");
const transferable_receivable_1 = require("./extensions/payment-network/erc20/transferable-receivable");
/**
 * Module to manage Advanced logic extensions
 * Package to route the format and parsing of extensions following their id
 */
class AdvancedLogic {
    constructor(currencyManager) {
        if (!currencyManager) {
            currencyManager = currency_1.CurrencyManager.getDefault();
        }
        this.extensions = {
            addressBasedBtc: new mainnet_address_based_1.default(),
            addressBasedErc20: new address_based_1.default(),
            addressBasedTestnetBtc: new testnet_address_based_1.default(),
            contentData: new content_data_1.default(),
            anyToErc20Proxy: new any_to_erc20_proxy_1.default(currencyManager),
            declarative: new declarative_1.default(),
            ethereumInputData: new input_data_1.default(),
            feeProxyContractErc20: new fee_proxy_contract_1.default(),
            proxyContractErc20: new proxy_contract_1.default(),
            erc777Stream: new stream_1.default(),
            feeProxyContractEth: new fee_proxy_contract_2.default(),
            anyToEthProxy: new any_to_eth_proxy_1.default(currencyManager),
            nativeToken: [new near_native_1.default(), new near_testnet_native_1.default()],
            anyToNativeToken: [new any_to_near_1.default(currencyManager), new any_to_near_testnet_1.default(currencyManager)],
            erc20TransferableReceivable: new transferable_receivable_1.default(),
        };
    }
    /**
     * Applies the extension action to the request extensions state
     *
     * @param extensionsState IExtensionStates previous state of the extensions
     * @param extensionAction IAction action to apply
     * @param requestState IRequest request state read-only
     * @param actionSigner IIdentity identity of the signer
     * @param timestamp timestamp of the action
     *
     * @returns state of the extension
     */
    applyActionToExtensions(extensionsState, extensionAction, requestState, actionSigner, timestamp) {
        const extension = this.getExtensionForActionAndState(extensionAction, requestState);
        return extension.applyActionToExtension(extensionsState, extensionAction, requestState, actionSigner, timestamp);
    }
    getExtensionForActionAndState(extensionAction, requestState) {
        const id = extensionAction.id;
        const network = this.getNetwork(extensionAction, requestState) || requestState.currency.network;
        const extension = {
            [types_1.ExtensionTypes.ID.CONTENT_DATA]: this.extensions.contentData,
            [types_1.ExtensionTypes.PAYMENT_NETWORK_ID.BITCOIN_ADDRESS_BASED]: this.extensions.addressBasedBtc,
            [types_1.ExtensionTypes.PAYMENT_NETWORK_ID.TESTNET_BITCOIN_ADDRESS_BASED]: this.extensions.addressBasedTestnetBtc,
            [types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_DECLARATIVE]: this.extensions.declarative,
            [types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_ADDRESS_BASED]: this.extensions.addressBasedErc20,
            [types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_PROXY_CONTRACT]: this.extensions.proxyContractErc20,
            [types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_FEE_PROXY_CONTRACT]: this.getFeeProxyContractErc20ForNetwork(network),
            [types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC777_STREAM]: this.extensions.erc777Stream,
            [types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ETH_INPUT_DATA]: this.extensions.ethereumInputData,
            [types_1.ExtensionTypes.PAYMENT_NETWORK_ID.NATIVE_TOKEN]: this.getNativeTokenExtensionForNetwork(network),
            [types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ERC20_PROXY]: this.extensions.anyToErc20Proxy,
            [types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ETH_FEE_PROXY_CONTRACT]: this.extensions.feeProxyContractEth,
            [types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ETH_PROXY]: this.extensions.anyToEthProxy,
            [types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_NATIVE_TOKEN]: this.getAnyToNativeTokenExtensionForNetwork(network),
            [types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_TRANSFERABLE_RECEIVABLE]: this.extensions.erc20TransferableReceivable,
        }[id];
        if (!extension) {
            if (id === types_1.ExtensionTypes.PAYMENT_NETWORK_ID.NATIVE_TOKEN ||
                id === types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_NATIVE_TOKEN) {
                throw Error(`extension with id: ${id} not found for network: ${network}`);
            }
            throw Error(`extension not recognized, id: ${id}`);
        }
        return extension;
    }
    getNativeTokenExtensionForNetwork(network) {
        return network
            ? this.extensions.nativeToken.find((nativeTokenExtension) => nativeTokenExtension.supportedNetworks.includes(network))
            : undefined;
    }
    getAnyToNativeTokenExtensionForNetwork(network) {
        return network
            ? this.extensions.anyToNativeToken.find((anyToNativeTokenExtension) => anyToNativeTokenExtension.supportedNetworks.includes(network))
            : undefined;
    }
    getFeeProxyContractErc20ForNetwork(network) {
        return currency_1.NearChains.isChainSupported(network)
            ? new fee_proxy_contract_1.default(undefined, undefined, network)
            : this.extensions.feeProxyContractErc20;
    }
    getNetwork(extensionAction, requestState) {
        var _a, _b;
        if (requestState.currency.network &&
            extensionAction.parameters.paymentNetworkName &&
            !(0, currency_1.isSameChain)(requestState.currency.network, extensionAction.parameters.paymentNetworkName)) {
            throw new Error(`Cannot apply action for network ${extensionAction.parameters.paymentNetworkName} on state with payment network: ${requestState.currency.network}`);
        }
        const network = extensionAction.action === 'create'
            ? extensionAction.parameters.network
            : (_b = (_a = requestState.extensions[types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_NATIVE_TOKEN]) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b.network;
        return network;
    }
}
exports.default = AdvancedLogic;
//# sourceMappingURL=advanced-logic.js.map