import { CurrencyTypes, ExtensionTypes, IdentityTypes, RequestLogicTypes } from '@requestnetwork/types';
import DeclarativePaymentNetwork from './declarative';
/**
 * Core of the address based payment networks
 * This module is called by the address based payment networks to avoid code redundancy
 */
export default abstract class AddressBasedPaymentNetwork<TCreationParameters extends ExtensionTypes.PnAddressBased.ICreationParameters = ExtensionTypes.PnAddressBased.ICreationParameters> extends DeclarativePaymentNetwork<TCreationParameters> {
    readonly supportedCurrencyType: RequestLogicTypes.CURRENCY;
    protected constructor(extensionId: ExtensionTypes.PAYMENT_NETWORK_ID, currentVersion: string, supportedCurrencyType: RequestLogicTypes.CURRENCY);
    /**
     * Creates the extensionsData for address based payment networks
     *
     * @param creationParameters extensions parameters to create
     *
     * @returns IExtensionCreationAction the extensionsData to be stored in the request
     */
    createCreationAction(creationParameters: TCreationParameters): ExtensionTypes.IAction<TCreationParameters>;
    /**
     * Creates the extensionsData to add a payment address
     *
     * @param addPaymentAddressParameters extensions parameters to create
     *
     * @returns IAction the extensionsData to be stored in the request
     */
    createAddPaymentAddressAction(addPaymentAddressParameters: ExtensionTypes.PnAddressBased.IAddPaymentAddressParameters): ExtensionTypes.IAction;
    /**
     * Creates the extensionsData to add a refund address
     *
     * @param addRefundAddressParameters extensions parameters to create
     *
     * @returns IAction the extensionsData to be stored in the request
     */
    createAddRefundAddressAction(addRefundAddressParameters: ExtensionTypes.PnAddressBased.IAddRefundAddressParameters): ExtensionTypes.IAction;
    protected applyCreation(extensionAction: ExtensionTypes.IAction, timestamp: number): ExtensionTypes.IState;
    protected isValidAddress(address: string): boolean;
    protected isValidAddressForSymbolAndNetwork(address: string, symbol: string, network: CurrencyTypes.ChainName): boolean;
    /**
     * Applies the add payment address action
     *
     * @param extensionState previous state of the extension
     * @param extensionAction action to apply
     * @param requestState request state read-only
     * @param actionSigner identity of the signer
     *
     * @returns state of the extension updated
     */
    protected applyAddPaymentAddress(extensionState: ExtensionTypes.IState, extensionAction: ExtensionTypes.IAction, requestState: RequestLogicTypes.IRequest, actionSigner: IdentityTypes.IIdentity, timestamp: number): ExtensionTypes.IState;
    /**
     * Applies add refund address
     *
     * @param extensionState previous state of the extension
     * @param extensionAction action to apply
     * @param requestState request state read-only
     * @param actionSigner identity of the signer
     *
     * @returns state of the extension updated
     */
    protected applyAddRefundAddress(extensionState: ExtensionTypes.IState, extensionAction: ExtensionTypes.IAction, requestState: RequestLogicTypes.IRequest, actionSigner: IdentityTypes.IIdentity, timestamp: number): ExtensionTypes.IState;
    protected validate(request: RequestLogicTypes.IRequest, _extensionAction: ExtensionTypes.IAction): void;
    protected throwIfInvalidNetwork(network?: string): asserts network is string;
}
export declare class InvalidPaymentAddressError extends Error {
    constructor(address?: string, addressReference?: string);
}
export declare class UnsupportedNetworkError extends Error {
    constructor(unsupportedNetworkName: string, supportedNetworks?: string[]);
}
//# sourceMappingURL=address-based.d.ts.map