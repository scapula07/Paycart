"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@requestnetwork/types");
const utils_1 = require("@requestnetwork/utils");
const abstract_extension_1 = require("../abstract-extension");
const CURRENT_VERSION = '0.1.0';
/**
 * Core of the declarative payment network
 */
class DeclarativePaymentNetwork extends abstract_extension_1.AbstractExtension {
    constructor(extensionId = types_1.ExtensionTypes
        .PAYMENT_NETWORK_ID.ANY_DECLARATIVE, currentVersion = CURRENT_VERSION) {
        super(types_1.ExtensionTypes.TYPE.PAYMENT_NETWORK, extensionId, currentVersion);
        this.extensionId = extensionId;
        this.currentVersion = currentVersion;
        this.actions = Object.assign(Object.assign({}, this.actions), { [types_1.ExtensionTypes.PnAnyDeclarative.ACTION.ADD_PAYMENT_INSTRUCTION]: this.applyAddPaymentInstruction.bind(this), [types_1.ExtensionTypes.PnAnyDeclarative.ACTION.ADD_REFUND_INSTRUCTION]: this.applyAddRefundInstruction.bind(this), [types_1.ExtensionTypes.PnAnyDeclarative.ACTION.DECLARE_SENT_PAYMENT]: this.applyDeclareSentPayment.bind(this), [types_1.ExtensionTypes.PnAnyDeclarative.ACTION.DECLARE_SENT_REFUND]: this.applyDeclareSentRefund.bind(this), [types_1.ExtensionTypes.PnAnyDeclarative.ACTION.DECLARE_RECEIVED_PAYMENT]: this.applyDeclareReceivedPayment.bind(this), [types_1.ExtensionTypes.PnAnyDeclarative.ACTION.DECLARE_RECEIVED_REFUND]: this.applyDeclareReceivedRefund.bind(this), [types_1.ExtensionTypes.PnAnyDeclarative.ACTION.ADD_DELEGATE]: this.applyAddDelegate.bind(this) });
    }
    /**
     * Creates the extensionsData to add a sent payment declaration
     *
     * @param parameters parameters to create sent payment declaration
     *
     * @returns IAction the extensionsData to be stored in the request
     */
    createDeclareSentPaymentAction(parameters) {
        return {
            action: types_1.ExtensionTypes.PnAnyDeclarative.ACTION.DECLARE_SENT_PAYMENT,
            id: this.extensionId,
            parameters: {
                amount: parameters.amount.toString(),
                note: parameters.note,
                txHash: parameters.txHash,
                network: parameters.network,
            },
        };
    }
    /**
     * Creates the extensionsData to add a sent refund declaration
     *
     * @param parameters parameters to create sent refund declaration
     *
     * @returns IAction the extensionsData to be stored in the request
     */
    createDeclareSentRefundAction(parameters) {
        return {
            action: types_1.ExtensionTypes.PnAnyDeclarative.ACTION.DECLARE_SENT_REFUND,
            id: this.extensionId,
            parameters: {
                amount: parameters.amount.toString(),
                note: parameters.note,
                txHash: parameters.txHash,
                network: parameters.network,
            },
        };
    }
    /**
     * Creates the extensionsData to add a received payment declaration
     *
     * @param parameters parameters to create received payment declaration
     *
     * @returns IAction the extensionsData to be stored in the request
     */
    createDeclareReceivedPaymentAction(parameters) {
        return {
            action: types_1.ExtensionTypes.PnAnyDeclarative.ACTION.DECLARE_RECEIVED_PAYMENT,
            id: this.extensionId,
            parameters: {
                amount: parameters.amount.toString(),
                note: parameters.note,
                txHash: parameters.txHash,
                network: parameters.network,
            },
        };
    }
    /**
     * Creates the extensionsData to add a received refund declaration
     *
     * @param parameters parameters to create received refund declaration
     *
     * @returns IAction the extensionsData to be stored in the request
     */
    createDeclareReceivedRefundAction(parameters) {
        return {
            action: types_1.ExtensionTypes.PnAnyDeclarative.ACTION.DECLARE_RECEIVED_REFUND,
            id: this.extensionId,
            parameters: {
                amount: parameters.amount.toString(),
                note: parameters.note,
                txHash: parameters.txHash,
                network: parameters.network,
            },
        };
    }
    /**
     * Creates the extensionsData to add payment instruction
     *
     * @param extensions extensions parameters to add payment instruction
     *
     * @returns IAction the extensionsData to be stored in the request
     */
    createAddPaymentInstructionAction(parameters) {
        return {
            action: types_1.ExtensionTypes.PnAnyDeclarative.ACTION.ADD_PAYMENT_INSTRUCTION,
            id: this.extensionId,
            parameters: {
                paymentInfo: parameters.paymentInfo,
            },
        };
    }
    /**
     * Creates the extensionsData to add refund instruction
     *
     * @param extensions extensions parameters to add refund instruction
     *
     * @returns IAction the extensionsData to be stored in the request
     */
    createAddRefundInstructionAction(parameters) {
        return {
            action: types_1.ExtensionTypes.PnAnyDeclarative.ACTION.ADD_REFUND_INSTRUCTION,
            id: this.extensionId,
            parameters: {
                refundInfo: parameters.refundInfo,
            },
        };
    }
    /**
     * Creates the extensionsData to add delegate
     *
     * @param extensions extensions parameters to add delegate
     *
     * @returns IAction the extensionsData to be stored in the request
     */
    createAddDelegateAction(parameters) {
        return {
            action: types_1.ExtensionTypes.PnAnyDeclarative.ACTION.ADD_DELEGATE,
            id: this.extensionId,
            parameters: {
                delegate: parameters.delegate,
            },
        };
    }
    /** Applies a creation
     *
     * @param extensionAction action to apply
     * @param timestamp timestamp of the action
     *
     * @returns state of the extension created
     */
    applyCreation(extensionAction, timestamp) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const genericCreationAction = super.applyCreation(extensionAction, timestamp);
        return Object.assign(Object.assign({}, genericCreationAction), { events: [
                {
                    name: 'create',
                    parameters: {
                        paymentInfo: (_a = extensionAction.parameters) === null || _a === void 0 ? void 0 : _a.paymentInfo,
                        refundInfo: (_b = extensionAction.parameters) === null || _b === void 0 ? void 0 : _b.refundInfo,
                        salt: (_c = extensionAction.parameters) === null || _c === void 0 ? void 0 : _c.salt,
                        payeeDelegate: (_d = extensionAction.parameters) === null || _d === void 0 ? void 0 : _d.payeeDelegate,
                        payerDelegate: (_e = extensionAction.parameters) === null || _e === void 0 ? void 0 : _e.payerDelegate,
                    },
                    timestamp,
                },
            ], values: {
                paymentInfo: (_f = extensionAction.parameters) === null || _f === void 0 ? void 0 : _f.paymentInfo,
                refundInfo: (_g = extensionAction.parameters) === null || _g === void 0 ? void 0 : _g.refundInfo,
                salt: (_h = extensionAction.parameters) === null || _h === void 0 ? void 0 : _h.salt,
                payeeDelegate: (_j = extensionAction.parameters) === null || _j === void 0 ? void 0 : _j.payeeDelegate,
                payerDelegate: (_k = extensionAction.parameters) === null || _k === void 0 ? void 0 : _k.payerDelegate,
                receivedPaymentAmount: '0',
                receivedRefundAmount: '0',
                sentPaymentAmount: '0',
                sentRefundAmount: '0',
            } });
    }
    /** Applies a declare sent payment
     *
     * @param extensionsState previous state of the extensions
     * @param extensionAction action to apply
     * @param requestState request state read-only
     * @param actionSigner identity of the signer
     * @param timestamp timestamp of the action
     *
     * @returns state of the extension created
     */
    applyDeclareSentPayment(extensionState, extensionAction, requestState, actionSigner, timestamp) {
        this.checkIdentities(extensionState, requestState, actionSigner, types_1.RequestLogicTypes.ROLE.PAYER);
        if (!(0, utils_1.isValidAmount)(extensionAction.parameters.amount)) {
            throw Error(`The amount is not a valid amount`);
        }
        const copiedExtensionState = (0, utils_1.deepCopy)(extensionState);
        // increment sentPaymentAmount
        copiedExtensionState.values.sentPaymentAmount = (0, utils_1.addAmount)(copiedExtensionState.values.sentPaymentAmount, extensionAction.parameters.amount);
        // update events
        copiedExtensionState.events.push({
            name: types_1.ExtensionTypes.PnAnyDeclarative.ACTION.DECLARE_SENT_PAYMENT,
            parameters: {
                amount: extensionAction.parameters.amount,
                note: extensionAction.parameters.note,
                txHash: extensionAction.parameters.txHash,
                network: extensionAction.parameters.network,
            },
            timestamp,
            from: actionSigner,
        });
        return copiedExtensionState;
    }
    /** Applies a declare sent refund
     *
     * @param extensionsState previous state of the extensions
     * @param extensionAction action to apply
     * @param requestState request state read-only
     * @param actionSigner identity of the signer
     * @param timestamp timestamp of the action
     *
     * @returns state of the extension created
     */
    applyDeclareSentRefund(extensionState, extensionAction, requestState, actionSigner, timestamp) {
        this.checkIdentities(extensionState, requestState, actionSigner, types_1.RequestLogicTypes.ROLE.PAYEE);
        if (!(0, utils_1.isValidAmount)(extensionAction.parameters.amount)) {
            throw Error(`The amount is not a valid amount`);
        }
        const copiedExtensionState = (0, utils_1.deepCopy)(extensionState);
        // increment sentRefundAmount
        copiedExtensionState.values.sentRefundAmount = (0, utils_1.addAmount)(copiedExtensionState.values.sentRefundAmount, extensionAction.parameters.amount);
        // update events
        copiedExtensionState.events.push({
            name: types_1.ExtensionTypes.PnAnyDeclarative.ACTION.DECLARE_SENT_REFUND,
            parameters: {
                amount: extensionAction.parameters.amount,
                note: extensionAction.parameters.note,
                txHash: extensionAction.parameters.txHash,
                network: extensionAction.parameters.network,
            },
            timestamp,
            from: actionSigner,
        });
        return copiedExtensionState;
    }
    /** Applies a declare received payment
     *
     * @param extensionsState previous state of the extensions
     * @param extensionAction action to apply
     * @param requestState request state read-only
     * @param actionSigner identity of the signer
     * @param timestamp timestamp of the action
     *
     * @returns state of the extension created
     */
    applyDeclareReceivedPayment(extensionState, extensionAction, requestState, actionSigner, timestamp) {
        this.checkIdentities(extensionState, requestState, actionSigner, types_1.RequestLogicTypes.ROLE.PAYEE);
        if (!(0, utils_1.isValidAmount)(extensionAction.parameters.amount)) {
            throw Error(`The amount is not a valid amount`);
        }
        const copiedExtensionState = (0, utils_1.deepCopy)(extensionState);
        // increment receivedPaymentAmount
        copiedExtensionState.values.receivedPaymentAmount = (0, utils_1.addAmount)(copiedExtensionState.values.receivedPaymentAmount, extensionAction.parameters.amount);
        // update events
        copiedExtensionState.events.push({
            name: types_1.ExtensionTypes.PnAnyDeclarative.ACTION.DECLARE_RECEIVED_PAYMENT,
            parameters: {
                amount: extensionAction.parameters.amount,
                note: extensionAction.parameters.note,
                txHash: extensionAction.parameters.txHash,
                network: extensionAction.parameters.network,
            },
            timestamp,
            from: actionSigner,
        });
        return copiedExtensionState;
    }
    /** Applies a declare received refund
     *
     * @param extensionsState previous state of the extensions
     * @param extensionAction action to apply
     * @param requestState request state read-only
     * @param actionSigner identity of the signer
     * @param timestamp timestamp of the action
     *
     * @returns state of the extension created
     */
    applyDeclareReceivedRefund(extensionState, extensionAction, requestState, actionSigner, timestamp) {
        this.checkIdentities(extensionState, requestState, actionSigner, types_1.RequestLogicTypes.ROLE.PAYER);
        if (!(0, utils_1.isValidAmount)(extensionAction.parameters.amount)) {
            throw Error(`The amount is not a valid amount`);
        }
        const copiedExtensionState = (0, utils_1.deepCopy)(extensionState);
        // increment receivedRefundAmount
        copiedExtensionState.values.receivedRefundAmount = (0, utils_1.addAmount)(copiedExtensionState.values.receivedRefundAmount, extensionAction.parameters.amount);
        // update events
        copiedExtensionState.events.push({
            name: types_1.ExtensionTypes.PnAnyDeclarative.ACTION.DECLARE_RECEIVED_REFUND,
            parameters: {
                amount: extensionAction.parameters.amount,
                note: extensionAction.parameters.note,
                txHash: extensionAction.parameters.txHash,
                network: extensionAction.parameters.network,
            },
            timestamp,
            from: actionSigner,
        });
        return copiedExtensionState;
    }
    /** Applies an add of payment instruction
     *
     * @param extensionsState previous state of the extensions
     * @param extensionAction action to apply
     * @param requestState request state read-only
     * @param actionSigner identity of the signer
     * @param timestamp timestamp of the action
     *
     * @returns state of the extension created
     */
    applyAddPaymentInstruction(extensionState, extensionAction, requestState, actionSigner, timestamp) {
        if (extensionState.values.paymentInfo) {
            throw Error(`The payment instruction already assigned`);
        }
        this.checkIdentities(extensionState, requestState, actionSigner, types_1.RequestLogicTypes.ROLE.PAYEE);
        const copiedExtensionState = (0, utils_1.deepCopy)(extensionState);
        // assign paymentInfo
        copiedExtensionState.values.paymentInfo = extensionAction.parameters.paymentInfo;
        // update events
        copiedExtensionState.events.push({
            name: types_1.ExtensionTypes.PnAnyDeclarative.ACTION.ADD_PAYMENT_INSTRUCTION,
            parameters: {
                paymentInfo: extensionAction.parameters.paymentInfo,
            },
            timestamp,
            from: actionSigner,
        });
        return copiedExtensionState;
    }
    /** Applies an add of a delegate
     *
     * @param extensionsState previous state of the extensions
     * @param extensionAction action to apply
     * @param requestState request state read-only
     * @param actionSigner identity of the signer
     * @param timestamp timestamp of the action
     *
     * @returns state of the extension created
     */
    applyAddDelegate(extensionState, extensionAction, requestState, actionSigner, timestamp) {
        let delegateStr;
        if ((0, utils_1.areEqualIdentities)(actionSigner, requestState.payee)) {
            delegateStr = 'payeeDelegate';
        }
        else if ((0, utils_1.areEqualIdentities)(actionSigner, requestState.payer)) {
            delegateStr = 'payerDelegate';
        }
        else {
            throw Error(`The signer must be the payee or the payer`);
        }
        if (extensionState.values[delegateStr]) {
            throw Error(`The ${delegateStr} is already assigned`);
        }
        const copiedExtensionState = (0, utils_1.deepCopy)(extensionState);
        // assign payeeDelegate or payerDelegate
        copiedExtensionState.values[delegateStr] = extensionAction.parameters.delegate;
        // update events
        copiedExtensionState.events.push({
            name: types_1.ExtensionTypes.PnAnyDeclarative.ACTION.ADD_DELEGATE,
            parameters: {
                delegate: extensionAction.parameters.delegate,
            },
            timestamp,
            from: actionSigner,
        });
        return copiedExtensionState;
    }
    /** Applies an add of refund instruction
     *
     * @param extensionsState previous state of the extensions
     * @param extensionAction action to apply
     * @param requestState request state read-only
     * @param actionSigner identity of the signer
     * @param timestamp timestamp of the action
     *
     * @returns state of the extension created
     */
    applyAddRefundInstruction(extensionState, extensionAction, requestState, actionSigner, timestamp) {
        if (extensionState.values.refundInfo) {
            throw Error(`The refund instruction already assigned`);
        }
        this.checkIdentities(extensionState, requestState, actionSigner, types_1.RequestLogicTypes.ROLE.PAYER);
        const copiedExtensionState = (0, utils_1.deepCopy)(extensionState);
        // assign refundInfo
        copiedExtensionState.values.refundInfo = extensionAction.parameters.refundInfo;
        // update events
        copiedExtensionState.events.push({
            name: types_1.ExtensionTypes.PnAnyDeclarative.ACTION.ADD_REFUND_INSTRUCTION,
            parameters: {
                refundInfo: extensionAction.parameters.refundInfo,
            },
            timestamp,
            from: actionSigner,
        });
        return copiedExtensionState;
    }
    /** Checks if signer is the right identity from the request and the role expected
     *
     * @param extensionsState previous state of the extensions
     * @param requestState request state read-only
     * @param actionSigner identity of the signer
     * @param role The role to check (Payee or Payer)
     *
     * @returns throws in case of error
     */
    checkIdentities(extensionState, requestState, actionSigner, role) {
        let requestRole;
        let requestRoleStr;
        let requestRoleDelegate;
        if (role === types_1.RequestLogicTypes.ROLE.PAYER) {
            requestRole = requestState.payer;
            requestRoleStr = 'payer';
            requestRoleDelegate = extensionState.values.payerDelegate;
        }
        if (role === types_1.RequestLogicTypes.ROLE.PAYEE) {
            requestRole = requestState.payee;
            requestRoleStr = 'payee';
            requestRoleDelegate = extensionState.values.payeeDelegate;
        }
        if (!requestRole) {
            throw Error(`The request must have a ${requestRoleStr}`);
        }
        if (!(0, utils_1.areEqualIdentities)(actionSigner, requestRole) &&
            !(0, utils_1.areEqualIdentities)(actionSigner, requestRoleDelegate)) {
            throw Error(`The signer must be the ${requestRoleStr} or the ${requestRoleStr}Delegate`);
        }
    }
}
exports.default = DeclarativePaymentNetwork;
//# sourceMappingURL=declarative.js.map