"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeeReferenceBasedPaymentNetwork = void 0;
const types_1 = require("@requestnetwork/types");
const reference_based_1 = require("./reference-based");
const utils_1 = require("@requestnetwork/utils");
/**
 * Core of the reference based with fee payment networks
 * This module is called by the fee reference based (ethereum & erc20) payment networks to avoid code redundancy
 */
class FeeReferenceBasedPaymentNetwork extends reference_based_1.default {
    constructor(extensionId, currentVersion, supportedCurrencyType) {
        super(extensionId, currentVersion, supportedCurrencyType);
        this.actions = Object.assign(Object.assign({}, this.actions), { [types_1.ExtensionTypes.PnFeeReferenceBased.ACTION.ADD_FEE]: this.applyAddFee.bind(this) });
    }
    /**
     * Creates the extensionsData to create the payment detection extension
     *
     * @param creationParameters extensions parameters to create
     *
     * @returns IExtensionCreationAction the extensionsData to be stored in the request
     */
    createCreationAction(creationParameters) {
        if (creationParameters.feeAddress && !this.isValidAddress(creationParameters.feeAddress)) {
            throw Error('feeAddress is not a valid address');
        }
        if (creationParameters.feeAmount && !(0, utils_1.isValidAmount)(creationParameters.feeAmount)) {
            throw Error('feeAmount is not a valid amount');
        }
        if (!creationParameters.feeAmount && creationParameters.feeAddress) {
            throw Error('feeAmount requires feeAddress');
        }
        if (creationParameters.feeAmount && !creationParameters.feeAddress) {
            throw Error('feeAddress requires feeAmount');
        }
        return super.createCreationAction(creationParameters);
    }
    /**
     * Creates the extensionsData to add a fee address
     *
     * @param addFeeParameters extensions parameters to create
     *
     * @returns IAction the extensionsData to be stored in the request
     */
    createAddFeeAction(addFeeParameters) {
        if (addFeeParameters.feeAddress && !this.isValidAddress(addFeeParameters.feeAddress)) {
            throw Error('feeAddress is not a valid address');
        }
        if (addFeeParameters.feeAmount && !(0, utils_1.isValidAmount)(addFeeParameters.feeAmount)) {
            throw Error('feeAmount is not a valid amount');
        }
        if (addFeeParameters.feeAddress && !addFeeParameters.feeAmount) {
            throw Error('feeAddress requires feeAmount');
        }
        if (addFeeParameters.feeAmount && !addFeeParameters.feeAddress) {
            throw Error('feeAmount requires feeAddress');
        }
        return {
            action: types_1.ExtensionTypes.PnFeeReferenceBased.ACTION.ADD_FEE,
            id: this.extensionId,
            parameters: addFeeParameters,
        };
    }
    /**
     * Applies a creation extension action
     *
     * @param extensionAction action to apply
     * @param timestamp action timestamp
     *
     * @returns state of the extension created
     */
    applyCreation(extensionAction, timestamp) {
        if (extensionAction.parameters.feeAddress &&
            !this.isValidAddress(extensionAction.parameters.feeAddress)) {
            throw Error('feeAddress is not a valid address');
        }
        if (extensionAction.parameters.feeAmount &&
            !(0, utils_1.isValidAmount)(extensionAction.parameters.feeAmount)) {
            throw Error('feeAmount is not a valid amount');
        }
        const proxyPNCreationAction = super.applyCreation(extensionAction, timestamp);
        return Object.assign(Object.assign({}, proxyPNCreationAction), { events: [
                {
                    name: 'create',
                    parameters: {
                        feeAddress: extensionAction.parameters.feeAddress,
                        feeAmount: extensionAction.parameters.feeAmount,
                        paymentAddress: extensionAction.parameters.paymentAddress,
                        refundAddress: extensionAction.parameters.refundAddress,
                        salt: extensionAction.parameters.salt,
                    },
                    timestamp,
                },
            ], values: Object.assign(Object.assign({}, proxyPNCreationAction.values), { feeAddress: extensionAction.parameters.feeAddress, feeAmount: extensionAction.parameters.feeAmount }) });
    }
    /**
     * Applies an add fee address and amount extension action
     *
     * @param extensionState previous state of the extension
     * @param extensionAction action to apply
     * @param requestState request state read-only
     * @param actionSigner identity of the signer
     * @param timestamp action timestamp
     *
     * @returns state of the extension updated
     */
    applyAddFee(extensionState, extensionAction, requestState, actionSigner, timestamp) {
        if (extensionAction.parameters.feeAddress &&
            !this.isValidAddress(extensionAction.parameters.feeAddress)) {
            throw Error('feeAddress is not a valid address');
        }
        if (extensionState.values.feeAddress) {
            throw Error(`Fee address already given`);
        }
        if (extensionAction.parameters.feeAmount &&
            !(0, utils_1.isValidAmount)(extensionAction.parameters.feeAmount)) {
            throw Error('feeAmount is not a valid amount');
        }
        if (extensionState.values.feeAmount) {
            throw Error(`Fee amount already given`);
        }
        if (!requestState.payee) {
            throw Error(`The request must have a payee`);
        }
        if (!(0, utils_1.areEqualIdentities)(actionSigner, requestState.payee)) {
            throw Error(`The signer must be the payee`);
        }
        const copiedExtensionState = (0, utils_1.deepCopy)(extensionState);
        // update fee address and amount
        copiedExtensionState.values.feeAddress = extensionAction.parameters.feeAddress;
        copiedExtensionState.values.feeAmount = extensionAction.parameters.feeAmount;
        // update events
        copiedExtensionState.events.push({
            name: types_1.ExtensionTypes.PnFeeReferenceBased.ACTION.ADD_FEE,
            parameters: {
                feeAddress: extensionAction.parameters.feeAddress,
                feeAmount: extensionAction.parameters.feeAmount,
            },
            timestamp,
        });
        return copiedExtensionState;
    }
}
exports.FeeReferenceBasedPaymentNetwork = FeeReferenceBasedPaymentNetwork;
//# sourceMappingURL=fee-reference-based.js.map