"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const currency_1 = require("@requestnetwork/currency");
const types_1 = require("@requestnetwork/types");
const fee_proxy_contract_1 = require("./erc20/fee-proxy-contract");
const CURRENT_VERSION = '0.1.0';
class AnyToErc20ProxyPaymentNetwork extends fee_proxy_contract_1.default {
    constructor(currencyManager, extensionId = types_1.ExtensionTypes.PAYMENT_NETWORK_ID
        .ANY_TO_ERC20_PROXY, currentVersion = CURRENT_VERSION) {
        super(extensionId, currentVersion);
        this.currencyManager = currencyManager;
    }
    /**
     * Creates the extensionsData to create the extension ERC20 fee proxy contract payment detection
     *
     * @param creationParameters extensions parameters to create
     *
     * @returns IExtensionCreationAction the extensionsData to be stored in the request
     */
    createCreationAction(creationParameters) {
        if (!creationParameters.acceptedTokens || creationParameters.acceptedTokens.length === 0) {
            throw Error('acceptedTokens is required');
        }
        if (creationParameters.acceptedTokens.some((address) => !this.isValidAddress(address))) {
            throw Error('acceptedTokens must contains only valid ethereum addresses');
        }
        const network = creationParameters.network;
        this.throwIfInvalidNetwork(network);
        for (const address of creationParameters.acceptedTokens) {
            const acceptedCurrency = this.currencyManager.fromAddress(address, network);
            if (!acceptedCurrency) {
                throw new currency_1.UnsupportedCurrencyError({
                    value: address,
                    network,
                });
            }
            if (!this.currencyManager.supportsConversion(acceptedCurrency, network)) {
                throw Error(`acceptedTokens must contain only supported token addresses (ERC20 only). ${address} is not supported for ${network}.`);
            }
        }
        return super.createCreationAction(creationParameters);
    }
    /**
     * Applies a creation extension action
     *
     * @param extensionAction action to apply
     * @param timestamp action timestamp
     *
     * @returns state of the extension created
     */
    applyCreation(extensionAction, timestamp) {
        if (!extensionAction.parameters.network || extensionAction.parameters.network.length === 0) {
            throw Error('network is required');
        }
        if (!extensionAction.parameters.acceptedTokens ||
            extensionAction.parameters.acceptedTokens.length === 0) {
            throw Error('acceptedTokens is required and cannot be empty');
        }
        if (extensionAction.parameters.acceptedTokens.some((address) => !this.isValidAddress(address))) {
            throw Error('acceptedTokens must contains only valid ethereum addresses');
        }
        const feePNCreationAction = super.applyCreation(extensionAction, timestamp);
        return Object.assign(Object.assign({}, feePNCreationAction), { events: [
                {
                    name: 'create',
                    parameters: {
                        feeAddress: extensionAction.parameters.feeAddress,
                        feeAmount: extensionAction.parameters.feeAmount,
                        paymentAddress: extensionAction.parameters.paymentAddress,
                        refundAddress: extensionAction.parameters.refundAddress,
                        salt: extensionAction.parameters.salt,
                        network: extensionAction.parameters.network,
                        acceptedTokens: extensionAction.parameters.acceptedTokens,
                        maxRateTimespan: extensionAction.parameters.maxRateTimespan,
                    },
                    timestamp,
                },
            ], values: Object.assign(Object.assign({}, feePNCreationAction.values), { network: extensionAction.parameters.network, acceptedTokens: extensionAction.parameters.acceptedTokens, maxRateTimespan: extensionAction.parameters.maxRateTimespan }) });
    }
    /**
     * Validate the extension action regarding the currency and network
     * It must throw in case of error
     */
    validate(request, extensionAction) {
        var _a;
        const network = extensionAction.action === types_1.ExtensionTypes.PnFeeReferenceBased.ACTION.CREATE
            ? extensionAction.parameters.network
            : (_a = request.extensions[this.extensionId]) === null || _a === void 0 ? void 0 : _a.values.network;
        if (!network) {
            return;
        }
        // Nothing can be validated if the network has not been given yet
        if (!network) {
            return;
        }
        if (!currency_1.conversionSupportedNetworks.includes(network)) {
            throw new Error(`The network (${network}) is not supported for this payment network.`);
        }
        const currency = this.currencyManager.fromStorageCurrency(request.currency);
        if (!currency) {
            throw new currency_1.UnsupportedCurrencyError(request.currency);
        }
        if (!this.currencyManager.supportsConversion(currency, network)) {
            throw new Error(`The currency (${currency.id}, ${currency.hash}) of the request is not supported for this payment network.`);
        }
    }
}
exports.default = AnyToErc20ProxyPaymentNetwork;
//# sourceMappingURL=any-to-erc20-proxy.js.map