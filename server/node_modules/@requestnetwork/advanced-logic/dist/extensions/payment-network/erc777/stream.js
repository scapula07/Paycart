"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@requestnetwork/types");
const reference_based_1 = require("../reference-based");
const utils_1 = require("@requestnetwork/utils");
const CURRENT_VERSION = '0.1.0';
/**
 * Implementation of the payment network to pay in ERC777, including third-party fees payment, based on a reference provided to a proxy contract.
 */
class Erc777StreamPaymentNetwork extends reference_based_1.default {
    constructor() {
        super(types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC777_STREAM, CURRENT_VERSION, types_1.RequestLogicTypes.CURRENCY.ERC777);
    }
    /**
     * Creates the extensionsData to create the payment detection extension
     *
     * @param creationParameters extensions parameters to create
     *
     * @returns IExtensionCreationAction the extensionsData to be stored in the request
     */
    createCreationAction(creationParameters) {
        if (!types_1.TypesUtils.isOriginalRequestCreationParameters(creationParameters) &&
            !types_1.TypesUtils.isSubsequentRequestCreationParameters(creationParameters)) {
            throw Error('originalRequestId, previousRequestId and recurrenceNumber must be all empty or all filled');
        }
        /* Original Request Creation */
        if (types_1.TypesUtils.isOriginalRequestCreationParameters(creationParameters)) {
            if (!creationParameters.expectedFlowRate) {
                throw Error('expectedFlowRate should not be empty');
            }
            if (!creationParameters.expectedStartDate) {
                throw Error('expectedStartDate should not be empty');
            }
            return super.createCreationAction(creationParameters);
        }
        /* Subsequent request Creation */
        if (!this.isSubsequentRequestParametersValid(creationParameters)) {
            throw Error('recurrenceNumber must be 1 if originalRequestId and previousRequestId are equal and vice versa');
        }
        return {
            action: types_1.ExtensionTypes.PnFeeReferenceBased.ACTION.CREATE,
            id: this.extensionId,
            parameters: creationParameters,
            version: this.currentVersion,
        };
    }
    /**
     * Applies a creation extension action
     *
     * @param extensionAction action to apply
     * @param timestamp ?
     *
     * @returns state of the extension created
     */
    applyCreation(extensionAction, timestamp) {
        if (!types_1.TypesUtils.isOriginalRequestCreationParameters(extensionAction.parameters) &&
            !types_1.TypesUtils.isSubsequentRequestCreationParameters(extensionAction.parameters)) {
            throw Error('originalRequestId, previousRequestId and recurrenceNumber must be all empty or all filled');
        }
        /* Master request Creation */
        if (types_1.TypesUtils.isOriginalRequestCreationParameters(extensionAction.parameters)) {
            if (!extensionAction.parameters.expectedStartDate ||
                (extensionAction.parameters.expectedStartDate &&
                    !(0, utils_1.isValidAmount)(extensionAction.parameters.expectedStartDate))) {
                throw Error('expectedStartDate is empty or invalid');
            }
            if (!extensionAction.parameters.expectedFlowRate ||
                (extensionAction.parameters.expectedFlowRate &&
                    !(0, utils_1.isValidAmount)(extensionAction.parameters.expectedFlowRate))) {
                throw Error('expectedFlowRate is empty or invalid');
            }
            const proxyPNCreationAction = super.applyCreation(extensionAction, timestamp);
            return Object.assign(Object.assign({}, proxyPNCreationAction), { events: [
                    {
                        name: types_1.ExtensionTypes.PnFeeReferenceBased.ACTION.CREATE,
                        parameters: extensionAction.parameters,
                        timestamp,
                    },
                ], values: Object.assign(Object.assign({}, proxyPNCreationAction.values), { expectedStartDate: extensionAction.parameters.expectedStartDate, expectedFlowRate: extensionAction.parameters.expectedFlowRate }) });
        }
        /* Subsequent Request Creation */
        if (!extensionAction.parameters.originalRequestId) {
            throw Error('originalRequestId is empty');
        }
        if (!extensionAction.parameters.previousRequestId) {
            throw Error('previousRequestId is empty');
        }
        if (!extensionAction.parameters.recurrenceNumber) {
            throw Error('recurrenceNumber is empty');
        }
        if (!extensionAction.version) {
            throw Error('version is required at creation');
        }
        if (!this.isSubsequentRequestParametersValid(extensionAction.parameters)) {
            throw Error('recurrenceNumber must be 1 if originalRequestId and previousRequestId are equal and vice versa');
        }
        return {
            events: [
                {
                    name: types_1.ExtensionTypes.PnFeeReferenceBased.ACTION.CREATE,
                    parameters: extensionAction.parameters,
                    timestamp,
                },
            ],
            id: extensionAction.id,
            type: this.extensionType,
            values: extensionAction.parameters,
            version: extensionAction.version,
        };
    }
    /**
     * Verifies the consistency between the different parameters of the create action for subsequent requests
     *
     * @param parameters extension parameters to check
     *
     * @returns a boolean
     */
    isSubsequentRequestParametersValid(parameters) {
        return ((parameters.originalRequestId === parameters.previousRequestId &&
            parameters.recurrenceNumber === 1) ||
            (parameters.recurrenceNumber !== 1 &&
                parameters.originalRequestId !== parameters.previousRequestId));
    }
}
exports.default = Erc777StreamPaymentNetwork;
//# sourceMappingURL=stream.js.map