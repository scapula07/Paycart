"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnsupportedNetworkError = exports.InvalidPaymentAddressError = void 0;
const currency_1 = require("@requestnetwork/currency");
const types_1 = require("@requestnetwork/types");
const utils_1 = require("@requestnetwork/utils");
const declarative_1 = require("./declarative");
/**
 * Core of the address based payment networks
 * This module is called by the address based payment networks to avoid code redundancy
 */
class AddressBasedPaymentNetwork extends declarative_1.default {
    constructor(extensionId, currentVersion, supportedCurrencyType) {
        super(extensionId, currentVersion);
        this.supportedCurrencyType = supportedCurrencyType;
        this.actions = Object.assign(Object.assign({}, this.actions), { [types_1.ExtensionTypes.PnAddressBased.ACTION.ADD_PAYMENT_ADDRESS]: this.applyAddPaymentAddress.bind(this), [types_1.ExtensionTypes.PnAddressBased.ACTION.ADD_REFUND_ADDRESS]: this.applyAddRefundAddress.bind(this) });
    }
    /**
     * Creates the extensionsData for address based payment networks
     *
     * @param creationParameters extensions parameters to create
     *
     * @returns IExtensionCreationAction the extensionsData to be stored in the request
     */
    createCreationAction(creationParameters) {
        if (creationParameters.paymentAddress &&
            !this.isValidAddress(creationParameters.paymentAddress)) {
            throw new InvalidPaymentAddressError(creationParameters.paymentAddress);
        }
        if (creationParameters.refundAddress &&
            !this.isValidAddress(creationParameters.refundAddress)) {
            throw new InvalidPaymentAddressError(creationParameters.refundAddress, 'refundAddress');
        }
        return super.createCreationAction(creationParameters);
    }
    /**
     * Creates the extensionsData to add a payment address
     *
     * @param addPaymentAddressParameters extensions parameters to create
     *
     * @returns IAction the extensionsData to be stored in the request
     */
    createAddPaymentAddressAction(addPaymentAddressParameters) {
        const paymentAddress = addPaymentAddressParameters.paymentAddress;
        if (paymentAddress && !this.isValidAddress(paymentAddress)) {
            throw new InvalidPaymentAddressError(paymentAddress);
        }
        return {
            action: types_1.ExtensionTypes.PnAddressBased.ACTION.ADD_PAYMENT_ADDRESS,
            id: this.extensionId,
            parameters: {
                paymentAddress,
            },
        };
    }
    /**
     * Creates the extensionsData to add a refund address
     *
     * @param addRefundAddressParameters extensions parameters to create
     *
     * @returns IAction the extensionsData to be stored in the request
     */
    createAddRefundAddressAction(addRefundAddressParameters) {
        const refundAddress = addRefundAddressParameters.refundAddress;
        if (refundAddress && !this.isValidAddress(refundAddress)) {
            throw new InvalidPaymentAddressError(refundAddress, 'refundAddress');
        }
        return {
            action: types_1.ExtensionTypes.PnAddressBased.ACTION.ADD_REFUND_ADDRESS,
            id: this.extensionId,
            parameters: {
                refundAddress,
            },
        };
    }
    applyCreation(extensionAction, timestamp) {
        const paymentAddress = extensionAction.parameters.paymentAddress;
        const refundAddress = extensionAction.parameters.refundAddress;
        if (paymentAddress && !this.isValidAddress(paymentAddress)) {
            throw new InvalidPaymentAddressError(paymentAddress);
        }
        if (refundAddress && !this.isValidAddress(refundAddress)) {
            throw new InvalidPaymentAddressError(refundAddress, 'refundAddress');
        }
        const genericCreationAction = super.applyCreation(extensionAction, timestamp);
        return Object.assign(Object.assign({}, genericCreationAction), { events: [
                {
                    name: 'create',
                    parameters: {
                        paymentAddress,
                        refundAddress,
                    },
                    timestamp,
                },
            ], id: this.extensionId, type: this.extensionType, values: Object.assign(Object.assign({}, genericCreationAction.values), { paymentAddress,
                refundAddress }) });
    }
    isValidAddress(address) {
        switch (this.supportedCurrencyType) {
            case types_1.RequestLogicTypes.CURRENCY.ETH:
            case types_1.RequestLogicTypes.CURRENCY.ERC20:
            case types_1.RequestLogicTypes.CURRENCY.ERC777:
                return this.isValidAddressForSymbolAndNetwork(address, 'ETH', 'mainnet');
            default:
                throw new Error(`Default implementation of isValidAddressForNetwork() does not support currency type ${this.supportedCurrencyType}. Please override this method if needed.`);
        }
    }
    isValidAddressForSymbolAndNetwork(address, symbol, network) {
        const currencyManager = currency_1.CurrencyManager.getDefault();
        const currency = currencyManager.from(symbol, network);
        if (!currency) {
            throw new currency_1.UnsupportedCurrencyError({ value: symbol, network });
        }
        return currency_1.CurrencyManager.validateAddress(address, currency);
    }
    /**
     * Applies the add payment address action
     *
     * @param extensionState previous state of the extension
     * @param extensionAction action to apply
     * @param requestState request state read-only
     * @param actionSigner identity of the signer
     *
     * @returns state of the extension updated
     */
    applyAddPaymentAddress(extensionState, extensionAction, requestState, actionSigner, timestamp) {
        if (extensionAction.parameters.paymentAddress &&
            !this.isValidAddress(extensionAction.parameters.paymentAddress)) {
            throw new InvalidPaymentAddressError(extensionAction.parameters.paymentAddress);
        }
        if (extensionState.values.paymentAddress) {
            throw Error(`Payment address already given`);
        }
        if (!requestState.payee) {
            throw Error(`The request must have a payee`);
        }
        if (!(0, utils_1.areEqualIdentities)(actionSigner, requestState.payee)) {
            throw Error(`The signer must be the payee`);
        }
        const copiedExtensionState = (0, utils_1.deepCopy)(extensionState);
        // update payment address
        copiedExtensionState.values.paymentAddress = extensionAction.parameters.paymentAddress;
        // update events
        copiedExtensionState.events.push({
            name: types_1.ExtensionTypes.PnAddressBased.ACTION.ADD_PAYMENT_ADDRESS,
            parameters: { paymentAddress: extensionAction.parameters.paymentAddress },
            timestamp,
        });
        return copiedExtensionState;
    }
    /**
     * Applies add refund address
     *
     * @param extensionState previous state of the extension
     * @param extensionAction action to apply
     * @param requestState request state read-only
     * @param actionSigner identity of the signer
     *
     * @returns state of the extension updated
     */
    applyAddRefundAddress(extensionState, extensionAction, requestState, actionSigner, timestamp) {
        if (extensionAction.parameters.refundAddress &&
            !this.isValidAddress(extensionAction.parameters.refundAddress)) {
            throw Error('refundAddress is not a valid address');
        }
        if (extensionState.values.refundAddress) {
            throw Error(`Refund address already given`);
        }
        if (!requestState.payer) {
            throw Error(`The request must have a payer`);
        }
        if (!(0, utils_1.areEqualIdentities)(actionSigner, requestState.payer)) {
            throw Error(`The signer must be the payer`);
        }
        const copiedExtensionState = (0, utils_1.deepCopy)(extensionState);
        // update refund address
        copiedExtensionState.values.refundAddress = extensionAction.parameters.refundAddress;
        // update events
        copiedExtensionState.events.push({
            name: types_1.ExtensionTypes.PnAddressBased.ACTION.ADD_REFUND_ADDRESS,
            parameters: { refundAddress: extensionAction.parameters.refundAddress },
            timestamp,
        });
        return copiedExtensionState;
    }
    validate(request, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _extensionAction) {
        if (request.currency.type !== this.supportedCurrencyType) {
            throw Error(`This extension can be used only on ${this.supportedCurrencyType} requests`);
        }
        this.throwIfInvalidNetwork(request.currency.network);
    }
    throwIfInvalidNetwork(network) {
        if (!network) {
            throw Error('network is required');
        }
    }
}
exports.default = AddressBasedPaymentNetwork;
class InvalidPaymentAddressError extends Error {
    constructor(address, addressReference = 'paymentAddress') {
        const formattedAddress = address ? ` '${address}'` : '';
        super(`${addressReference}${formattedAddress} is not a valid address`);
    }
}
exports.InvalidPaymentAddressError = InvalidPaymentAddressError;
class UnsupportedNetworkError extends Error {
    constructor(unsupportedNetworkName, supportedNetworks) {
        const supportedNetworkDetails = supportedNetworks
            ? ` (only ${supportedNetworks.join(', ')})`
            : '';
        super(`Payment network '${unsupportedNetworkName}' is not supported by this extension${supportedNetworkDetails}`);
    }
}
exports.UnsupportedNetworkError = UnsupportedNetworkError;
//# sourceMappingURL=address-based.js.map