"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const currency_1 = require("@requestnetwork/currency");
const types_1 = require("@requestnetwork/types");
const fee_proxy_contract_1 = require("./ethereum/fee-proxy-contract");
const CURRENT_VERSION = '0.2.0';
class AnyToEthProxyPaymentNetwork extends fee_proxy_contract_1.default {
    constructor(currencyManager) {
        super(types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ANY_TO_ETH_PROXY, CURRENT_VERSION);
        this.currencyManager = currencyManager;
    }
    /**
     * Creates the extensionsData to create the extension ETH fee proxy contract payment detection
     *
     * @param creationParameters extensions parameters to create
     *
     * @returns IExtensionCreationAction the extensionsData to be stored in the request
     */
    createCreationAction(creationParameters) {
        this.throwIfInvalidNetwork(creationParameters.network);
        return super.createCreationAction(creationParameters);
    }
    /**
     * Applies a creation extension action
     *
     * @param extensionAction action to apply
     * @param timestamp action timestamp
     *
     * @returns state of the extension created
     */
    applyCreation(extensionAction, timestamp) {
        if (!extensionAction.parameters.network || extensionAction.parameters.network.length === 0) {
            throw Error('network is required');
        }
        const feePNCreationAction = super.applyCreation(extensionAction, timestamp);
        return Object.assign(Object.assign({}, feePNCreationAction), { events: [
                {
                    name: 'create',
                    parameters: {
                        feeAddress: extensionAction.parameters.feeAddress,
                        feeAmount: extensionAction.parameters.feeAmount,
                        paymentAddress: extensionAction.parameters.paymentAddress,
                        refundAddress: extensionAction.parameters.refundAddress,
                        salt: extensionAction.parameters.salt,
                        network: extensionAction.parameters.network,
                        maxRateTimespan: extensionAction.parameters.maxRateTimespan,
                    },
                    timestamp,
                },
            ], values: Object.assign(Object.assign({}, feePNCreationAction.values), { network: extensionAction.parameters.network, maxRateTimespan: extensionAction.parameters.maxRateTimespan }) });
    }
    /**
     * Validate the extension action regarding the currency and network
     * It must throw in case of error
     */
    validate(request, extensionAction) {
        var _a;
        const network = extensionAction.action === types_1.ExtensionTypes.PnFeeReferenceBased.ACTION.CREATE
            ? extensionAction.parameters.network
            : (_a = request.extensions[this.extensionId]) === null || _a === void 0 ? void 0 : _a.values.network;
        if (!network) {
            throw new Error(`The network must be provided from the creation action or from the extension state`);
        }
        const currency = this.currencyManager.fromStorageCurrency(request.currency);
        if (!currency) {
            throw new currency_1.UnsupportedCurrencyError(request.currency);
        }
        if (!this.currencyManager.supportsConversion(currency, network)) {
            throw new Error(`The currency (${request.currency.value}) of the request is not supported for this payment network.`);
        }
    }
}
exports.default = AnyToEthProxyPaymentNetwork;
//# sourceMappingURL=any-to-eth-proxy.js.map