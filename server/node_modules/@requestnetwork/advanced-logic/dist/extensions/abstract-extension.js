"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractExtension = void 0;
const types_1 = require("@requestnetwork/types");
const utils_1 = require("@requestnetwork/utils");
/**
 * Abstract class to create extension
 */
class AbstractExtension {
    constructor(extensionType, extensionId, currentVersion) {
        this.extensionType = extensionType;
        this.extensionId = extensionId;
        this.currentVersion = currentVersion;
        this.actions = {};
    }
    /**
     * Creates the extensionsData to create the extension
     *
     * @param creationParameters extensions parameters to create
     *
     * @returns IExtensionCreationAction the extensionsData to be stored in the request
     */
    createCreationAction(creationParameters) {
        return {
            action: 'create',
            id: this.extensionId,
            parameters: creationParameters,
            version: this.currentVersion,
        };
    }
    /**
     * Applies the extension action to the request
     * Is called to interpret the extensions data when applying the transaction
     *
     * @param extensionsState previous state of the extensions
     * @param extensionAction action to apply
     * @param requestState request state read-only
     * @param actionSigner identity of the signer
     *
     * @returns state of the request updated
     */
    applyActionToExtension(extensionsState, extensionAction, requestState, actionSigner, timestamp) {
        this.validate(requestState, extensionAction);
        const copiedExtensionState = (0, utils_1.deepCopy)(extensionsState);
        if (extensionAction.action === types_1.ExtensionTypes.PnFeeReferenceBased.ACTION.CREATE) {
            if (requestState.extensions[extensionAction.id]) {
                throw Error(`This extension has already been created`);
            }
            copiedExtensionState[extensionAction.id] = this.applyCreation(extensionAction, timestamp);
            return copiedExtensionState;
        }
        // if the action is not "create", the state must have been created before
        if (!extensionsState[extensionAction.id]) {
            throw Error(`The extension should be created before receiving any other action`);
        }
        const actionToApply = this.actions[extensionAction.action];
        if (!actionToApply) {
            throw Error(`Unknown action: ${extensionAction.action}`);
        }
        copiedExtensionState[extensionAction.id] = actionToApply(copiedExtensionState[extensionAction.id], extensionAction, requestState, actionSigner, timestamp);
        return copiedExtensionState;
    }
    /**
     * Applies an extension creation action
     *
     * @param extensionAction action to apply
     * @param _timestamp action timestamp
     *
     * @returns state of the extension created
     */
    applyCreation(extensionAction, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _timestamp) {
        if (!extensionAction.version) {
            throw Error('version is required at creation');
        }
        return {
            events: [],
            id: extensionAction.id,
            type: this.extensionType,
            values: {},
            version: extensionAction.version,
        };
    }
    /**
     * Validate the extension action regarding the request
     * It is called at the beginning of every applyActionToExtension()
     * It must throw in case of error
     *
     * @param extensionAction action to apply
     */
    validate(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _request, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _extensionAction) { }
}
exports.AbstractExtension = AbstractExtension;
//# sourceMappingURL=abstract-extension.js.map