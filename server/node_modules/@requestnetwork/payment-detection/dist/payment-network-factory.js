"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaymentNetworkFactory = void 0;
const types_1 = require("@requestnetwork/types");
const btc_1 = require("./btc");
const declarative_1 = require("./declarative");
const erc20_1 = require("./erc20");
const superfluid_detector_1 = require("./erc777/superfluid-detector");
const eth_1 = require("./eth");
const any_1 = require("./any");
const near_1 = require("./near");
const utils_1 = require("./utils");
const thegraph_1 = require("./thegraph");
const provider_1 = require("./provider");
const PN_ID = types_1.ExtensionTypes.PAYMENT_NETWORK_ID;
/** Register the payment network by currency and type */
const supportedPaymentNetwork = {
    BTC: {
        mainnet: {
            [PN_ID.BITCOIN_ADDRESS_BASED]: btc_1.BtcMainnetAddressBasedDetector,
        },
        testnet: {
            [PN_ID.TESTNET_BITCOIN_ADDRESS_BASED]: btc_1.BtcTestnetAddressBasedDetector,
        },
    },
    ERC777: {
        '*': {
            [PN_ID.ERC777_STREAM]: superfluid_detector_1.SuperFluidPaymentDetector,
        },
    },
    ERC20: {
        '*': {
            [PN_ID.ERC20_ADDRESS_BASED]: erc20_1.ERC20AddressBasedPaymentDetector,
            [PN_ID.ERC20_PROXY_CONTRACT]: erc20_1.ERC20ProxyPaymentDetector,
            [PN_ID.ERC20_FEE_PROXY_CONTRACT]: erc20_1.ERC20FeeProxyPaymentDetector,
        },
    },
    ETH: {
        aurora: { [PN_ID.NATIVE_TOKEN]: near_1.NearNativeTokenPaymentDetector },
        'aurora-testnet': {
            [PN_ID.NATIVE_TOKEN]: near_1.NearNativeTokenPaymentDetector,
        },
        'near-testnet': {
            [PN_ID.NATIVE_TOKEN]: near_1.NearNativeTokenPaymentDetector,
        },
        '*': {
            [PN_ID.ETH_INPUT_DATA]: eth_1.EthInputDataPaymentDetector,
            [PN_ID.ETH_FEE_PROXY_CONTRACT]: eth_1.EthFeeProxyPaymentDetector,
        },
    },
};
const anyCurrencyPaymentNetwork = {
    [PN_ID.ANY_TO_ERC20_PROXY]: any_1.AnyToERC20PaymentDetector,
    [PN_ID.ANY_DECLARATIVE]: declarative_1.DeclarativePaymentDetector,
    [PN_ID.ANY_TO_ETH_PROXY]: any_1.AnyToEthFeeProxyPaymentDetector,
    [PN_ID.ANY_TO_NATIVE_TOKEN]: near_1.NearConversionNativeTokenPaymentDetector,
};
/** Factory to create the payment network according to the currency and payment network type */
class PaymentNetworkFactory {
    /**
     *
     * @param advancedLogic the advanced-logic layer in charge of the extensions
     * @param currencyManager the currency manager handling supported currencies
     * @param options the payment network options
     */
    constructor(advancedLogic, currencyManager, options) {
        this.advancedLogic = advancedLogic;
        this.currencyManager = currencyManager;
        this.options = this.buildOptions(options || {});
    }
    buildOptions(options) {
        const defaultOptions = {
            getSubgraphClient: (network) => {
                return network === 'private'
                    ? undefined
                    : (0, thegraph_1.getTheGraphClient)(`https://api.thegraph.com/subgraphs/name/requestnetwork/request-payments-${network}`);
            },
            explorerApiKeys: {},
            getRpcProvider: provider_1.getDefaultProvider,
        };
        return Object.assign(Object.assign({}, defaultOptions), options);
    }
    /**
     * Creates a payment network according to payment network creation parameters
     * It throws if the payment network given is not supported by this library
     *
     * @param paymentNetworkId the ID of the payment network to instantiate
     * @param currencyType the currency type of the request
     * @param paymentChain Different from request.currency.network for on-chain conversion payment networks (any-to-something)
     * @returns the module to handle the payment network
     */
    createPaymentNetwork(paymentNetworkId, currencyType, paymentChain, paymentNetworkVersion) {
        var _a, _b;
        const network = paymentChain !== null && paymentChain !== void 0 ? paymentChain : 'mainnet';
        const currencyPaymentMap = ((_a = supportedPaymentNetwork[currencyType]) === null || _a === void 0 ? void 0 : _a[network]) ||
            ((_b = supportedPaymentNetwork[currencyType]) === null || _b === void 0 ? void 0 : _b['*']) ||
            {};
        const paymentNetworkMap = Object.assign(Object.assign({}, currencyPaymentMap), anyCurrencyPaymentNetwork);
        const detectorClass = paymentNetworkMap[paymentNetworkId];
        if (!detectorClass) {
            throw new Error(`the payment network id: ${paymentNetworkId} is not supported for the currency: ${currencyType} on network ${network}`);
        }
        const detector = new detectorClass(Object.assign({ network, advancedLogic: this.advancedLogic, currencyManager: this.currencyManager }, this.options));
        if (detector.extension && 'getDeploymentInformation' in detectorClass) {
            // this throws when the contract isn't deployed and was mandatory for payment detection
            detectorClass.getDeploymentInformation(network, paymentNetworkVersion || detector.extension.currentVersion);
        }
        return detector;
    }
    /**
     * Gets the module to the payment network of a request
     * It throws if the payment network found is not supported by this library
     *
     * @param request the request
     * @returns the module to handle the payment network or null if no payment network found
     */
    getPaymentNetworkFromRequest(request) {
        var _a, _b;
        const pn = (0, utils_1.getPaymentNetworkExtension)(request);
        if (!pn) {
            return null;
        }
        const detectionChain = (_b = (_a = pn.values) === null || _a === void 0 ? void 0 : _a.network) !== null && _b !== void 0 ? _b : request.currency.network;
        const { id, version } = pn;
        return this.createPaymentNetwork(id, request.currency.type, detectionChain, version);
    }
}
exports.PaymentNetworkFactory = PaymentNetworkFactory;
//# sourceMappingURL=payment-network-factory.js.map