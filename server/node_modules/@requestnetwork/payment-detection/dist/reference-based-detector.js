"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReferenceBasedDetector = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const utils_1 = require("@requestnetwork/utils");
const payment_reference_calculator_1 = require("./payment-reference-calculator");
const declarative_1 = require("./declarative");
/**
 * Abstract class to extend to get the payment balance of reference based requests
 */
class ReferenceBasedDetector extends declarative_1.DeclarativePaymentDetectorBase {
    /**
     * @param paymentNetworkId Example : ExtensionTypes.PAYMENT_NETWORK_ID.ETH_INPUT_DATA
     * @param extension The advanced logic payment network extension, reference based
     * @param currencyManager The currency manager
     */
    constructor(paymentNetworkId, extension, currencyManager) {
        super(paymentNetworkId, extension);
        this.currencyManager = currencyManager;
        if (!types_1.TypesUtils.isPaymentNetworkId(paymentNetworkId)) {
            throw new Error(`Cannot detect payment for extension type '${paymentNetworkId}', it is not a payment network ID.`);
        }
    }
    /**
     * Creates the extensions data for the creation of this extension.
     * Will set a salt if none is already given
     *
     * @param paymentNetworkCreationParameters Parameters to create the extension
     * @returns The extensionData object
     */
    createExtensionsDataForCreation(paymentNetworkCreationParameters) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // If no salt is given, generate one
            paymentNetworkCreationParameters.salt =
                paymentNetworkCreationParameters.salt || (yield utils_1.default.crypto.generate8randomBytes());
            return this.extension.createCreationAction(Object.assign({ paymentAddress: paymentNetworkCreationParameters.paymentAddress, refundAddress: paymentNetworkCreationParameters.refundAddress }, paymentNetworkCreationParameters));
        });
    }
    /**
     * Creates the extensions data to add payment address
     *
     * @param parameters to add payment address
     * @returns The extensionData object
     */
    createExtensionsDataForAddPaymentAddress(parameters) {
        return this.extension.createAddPaymentAddressAction({
            paymentAddress: parameters.paymentAddress,
        });
    }
    /**
     * Creates the extensions data to add refund address
     *
     * @param Parameters to add refund address
     * @returns The extensionData object
     */
    createExtensionsDataForAddRefundAddress(parameters) {
        return this.extension.createAddRefundAddressAction({
            refundAddress: parameters.refundAddress,
        });
    }
    getEvents(request) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const paymentExtension = this.getPaymentExtension(request);
            const paymentChain = this.getPaymentChain(request);
            this.checkRequiredParameter(paymentExtension.values.salt, 'salt');
            this.checkRequiredParameter(paymentExtension.values.paymentAddress, 'paymentAddress');
            const [paymentAndEscrowEvents, refundAndEscrowEvents] = yield Promise.all([
                this.extractEvents(types_1.PaymentTypes.EVENTS_NAMES.PAYMENT, paymentExtension.values.paymentAddress, this.getPaymentReference(request), request.currency, paymentChain, paymentExtension),
                this.extractEvents(types_1.PaymentTypes.EVENTS_NAMES.REFUND, paymentExtension.values.refundAddress, request.requestId, request.currency, paymentChain, paymentExtension),
            ]);
            const paymentEvents = paymentAndEscrowEvents.paymentEvents;
            const escrowEvents = paymentAndEscrowEvents.escrowEvents;
            const refundEvents = refundAndEscrowEvents.paymentEvents;
            const declaredEvents = this.getDeclarativeEvents(request);
            const allPaymentEvents = [...declaredEvents, ...paymentEvents, ...refundEvents];
            return {
                paymentEvents: allPaymentEvents,
                escrowEvents: escrowEvents,
            };
        });
    }
    /**
     * Get the network of the payment
     * @returns The network of payment
     */
    getPaymentChain(request) {
        const network = request.currency.network;
        if (!network) {
            throw Error(`request.currency.network must be defined for ${this.paymentNetworkId}`);
        }
        return network;
    }
    getPaymentReference(request) {
        const { paymentAddress, salt } = this.getPaymentExtension(request).values;
        this.checkRequiredParameter(paymentAddress, 'paymentAddress');
        this.checkRequiredParameter(salt, 'salt');
        return payment_reference_calculator_1.default.calculate(request.requestId, salt, paymentAddress);
    }
}
exports.ReferenceBasedDetector = ReferenceBasedDetector;
//# sourceMappingURL=reference-based-detector.js.map