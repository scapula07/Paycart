"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERC20ProxyPaymentDetector = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const smart_contracts_1 = require("@requestnetwork/smart-contracts");
const proxy_info_retriever_1 = require("./proxy-info-retriever");
const thegraph_1 = require("../thegraph");
const utils_1 = require("../utils");
const reference_based_detector_1 = require("../reference-based-detector");
const PROXY_CONTRACT_ADDRESS_MAP = {
    ['0.1.0']: '0.1.0',
};
/**
 * Handle payment networks with ERC20 proxy contract extension
 */
class ERC20ProxyPaymentDetector extends reference_based_detector_1.ReferenceBasedDetector {
    /**
     * @param extension The advanced logic payment network extensions
     */
    constructor({ advancedLogic, currencyManager, getSubgraphClient, }) {
        super(types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_PROXY_CONTRACT, advancedLogic.extensions.proxyContractErc20, currencyManager);
        this.getSubgraphClient = getSubgraphClient;
    }
    /**
     * Extracts the balance and events of an address
     *
     * @private
     * @param address Address to check
     * @param eventName Indicate if it is an address for payment or refund
     * @param network The id of network we want to check
     * @param tokenContractAddress the address of the token contract
     * @returns The balance and events
     */
    extractEvents(eventName, toAddress, paymentReference, requestCurrency, paymentChain, paymentNetwork) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (!toAddress) {
                return {
                    paymentEvents: [],
                };
            }
            const { address: proxyContractAddress, creationBlockNumber: proxyCreationBlockNumber } = ERC20ProxyPaymentDetector.getDeploymentInformation(paymentChain, paymentNetwork.version);
            const subgraphClient = this.getSubgraphClient(paymentChain);
            if (subgraphClient) {
                const graphInfoRetriever = new thegraph_1.TheGraphInfoRetriever(subgraphClient, this.currencyManager);
                return graphInfoRetriever.getTransferEvents({
                    paymentReference,
                    toAddress,
                    eventName,
                    contractAddress: proxyContractAddress,
                    paymentChain,
                });
            }
            else {
                const proxyInfoRetriever = new proxy_info_retriever_1.default(paymentReference, proxyContractAddress, proxyCreationBlockNumber, requestCurrency.value, toAddress, eventName, paymentChain);
                const paymentEvents = yield proxyInfoRetriever.getTransferEvents();
                return {
                    paymentEvents,
                };
            }
        });
    }
}
exports.ERC20ProxyPaymentDetector = ERC20ProxyPaymentDetector;
/*
 * Returns deployment information for the underlying smart contract for a given payment network version
 */
ERC20ProxyPaymentDetector.getDeploymentInformation = (0, utils_1.makeGetDeploymentInformation)(smart_contracts_1.erc20ProxyArtifact, PROXY_CONTRACT_ADDRESS_MAP);
//# sourceMappingURL=proxy-contract.js.map