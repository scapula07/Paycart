"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EscrowERC20InfoRetriever = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const smart_contracts_1 = require("@requestnetwork/smart-contracts");
const ethers_1 = require("ethers");
const provider_1 = require("../provider");
const utils_1 = require("../utils");
const ESCROW_CONTRACT_ADDRESS_MAP = {
    ['0.1.0']: '0.1.0',
    ['0.2.0']: '0.1.0',
};
/**
 * Retrieves a list of payment events from a escrow contract.
 *
 */
class EscrowERC20InfoRetriever {
    /**
     * @param paymentReference The reference to identify the payment.
     * @param escrowContractAddress The address of the escrow contract.
     * @param escrowCreationBlockNumber The block that created the escrow contract.
     * @param tokenContractAddress The address of the ERC20 contract
     * @param toAddress Address of the balance we want to check
     * @param eventName Indicate if it is an address for payment or escrow
     * @param network The Ethereum network to use.
     */
    constructor(paymentReference, escrowContractAddress, escrowCreationBlockNumber, tokenContractAddress, toAddress, network, eventName) {
        this.paymentReference = paymentReference;
        this.escrowContractAddress = escrowContractAddress;
        this.escrowCreationBlockNumber = escrowCreationBlockNumber;
        this.tokenContractAddress = tokenContractAddress;
        this.toAddress = toAddress;
        this.network = network;
        this.eventName = eventName;
        // Creates a local or default provider.
        this.provider = (0, provider_1.getDefaultProvider)(this.network);
        // Setup the ERC20 escrow contract interface.
        this.contractEscrow = new ethers_1.ethers.Contract(this.escrowContractAddress, smart_contracts_1.erc20EscrowToPayArtifact.getContractAbi(), this.provider);
    }
    /**
     * Retrieves events for the current contract, address and network.
     */
    getAllContractEvents() {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const freezeEvents = yield this.getContractEventsForEventName(types_1.PaymentTypes.ESCROW_EVENTS_NAMES.FREEZE_ESCROW);
            const initEmergencyEvents = yield this.getContractEventsForEventName(types_1.PaymentTypes.ESCROW_EVENTS_NAMES.INITIATE_EMERGENCY_CLAIM);
            const revertEmergencyEvents = yield this.getContractEventsForEventName(types_1.PaymentTypes.ESCROW_EVENTS_NAMES.REVERT_EMERGENCY_CLAIM);
            return [...freezeEvents, ...initEmergencyEvents, ...revertEmergencyEvents];
        });
    }
    getContractEvents() {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (!this.eventName) {
                throw new Error('Missing event name in EscrowInfoRetriever for getContractEvents()');
            }
            return this.getContractEventsForEventName(this.eventName);
        });
    }
    /**
     * Retrieves events for the current contract, address and network.
     */
    getContractEventsForEventName(eventName) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const filter = eventName === types_1.PaymentTypes.ESCROW_EVENTS_NAMES.FREEZE_ESCROW
                ? // Create a filter to find all the RequestFrozen logs with the payment reference
                    this.contractEscrow.filters.RequestFrozen('0x' + this.paymentReference)
                : eventName === types_1.PaymentTypes.ESCROW_EVENTS_NAMES.INITIATE_EMERGENCY_CLAIM
                    ? this.contractEscrow.filters.InitiatedEmergencyClaim('0x' + this.paymentReference)
                    : eventName === types_1.PaymentTypes.ESCROW_EVENTS_NAMES.REVERT_EMERGENCY_CLAIM
                        ? this.contractEscrow.filters.RevertedEmergencyClaim('0x' + this.paymentReference)
                        : eventName === types_1.PaymentTypes.ESCROW_EVENTS_NAMES.PAID_ESCROW
                            ? this.contractEscrow.filters.TransferWithReferenceAndFee(null, 
                            // TODO: be sure null is a good idea
                            null, null, '0x' + this.paymentReference, null, null)
                            : undefined;
            if (!filter) {
                throw new Error('Wrong eventName for Escrow event retriever');
            }
            filter.fromBlock = this.escrowCreationBlockNumber;
            filter.toBlock = 'latest';
            const logs = yield this.provider.getLogs(filter);
            // Parses, filters and creates the events from the logs with the payment reference.
            const eventPromises = logs
                // Parses the logs
                .map((log) => {
                const parsedLog = this.contractEscrow.interface.parseLog(log);
                return Object.assign(Object.assign({}, log), { parsedLog: (0, utils_1.parseLogArgs)(parsedLog) });
            })
                // Keeps only the log with the right token and the right destination address
                .filter(({ parsedLog }) => {
                if (parsedLog.tokenAddress) {
                    return (parsedLog.tokenAddress.toLowerCase() === this.tokenContractAddress.toLowerCase() &&
                        parsedLog.to.toLowerCase() === this.toAddress.toLowerCase());
                }
                else {
                    return true;
                }
            })
                // Creates the escrow events.
                .map(({ parsedLog, blockNumber, transactionHash }) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                var _a, _b;
                return ({
                    // TODO fix me
                    amount: ((_a = parsedLog.amount) === null || _a === void 0 ? void 0 : _a.toString()) || undefined,
                    name: eventName,
                    parameters: {
                        block: blockNumber,
                        paymentReference: parsedLog.paymentReference,
                        feeAddress: parsedLog.feeAddress || undefined,
                        feeAmount: ((_b = parsedLog.feeAmount) === null || _b === void 0 ? void 0 : _b.toString()) || undefined,
                        to: this.toAddress || undefined,
                        txHash: transactionHash,
                    },
                    timestamp: (yield this.provider.getBlock(blockNumber || 0)).timestamp,
                });
            }));
            return Promise.all(eventPromises);
        });
    }
    /**
     * Retrieves current escrow data from requestMapping in the Escrow smart contract
     */
    getEscrowRequestMapping() {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            return this.contractEscrow.requestMapping(`0x${this.paymentReference}`);
        });
    }
}
exports.EscrowERC20InfoRetriever = EscrowERC20InfoRetriever;
EscrowERC20InfoRetriever.getEscrowDeploymentInformation = (0, utils_1.makeGetDeploymentInformation)(smart_contracts_1.erc20EscrowToPayArtifact, ESCROW_CONTRACT_ADDRESS_MAP);
//# sourceMappingURL=escrow-info-retriever.js.map