"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeeReferenceBasedDetector = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const utils_1 = require("@requestnetwork/utils");
const reference_based_detector_1 = require("./reference-based-detector");
/**
 * Abstract class to extend to get the payment balance of reference based requests
 */
class FeeReferenceBasedDetector extends reference_based_detector_1.ReferenceBasedDetector {
    /**
     * @param paymentNetworkId Example : ExtensionTypes.PAYMENT_NETWORK_ID.ETH_INPUT_DATA
     * @param extension The advanced logic payment network extension, reference based
     */
    constructor(paymentNetworkId, extension, currencyManager) {
        super(paymentNetworkId, extension, currencyManager);
    }
    /**
     * Creates the extensions data for the creation of this extension.
     * Will set a salt if none is already given
     *
     * @param paymentNetworkCreationParameters Parameters to create the extension
     * @returns The extensionData object
     */
    createExtensionsDataForCreation(paymentNetworkCreationParameters) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // If no salt is given, generate one
            paymentNetworkCreationParameters.salt =
                paymentNetworkCreationParameters.salt || (yield utils_1.default.crypto.generate8randomBytes());
            return this.extension.createCreationAction(Object.assign({ feeAddress: paymentNetworkCreationParameters.feeAddress, feeAmount: paymentNetworkCreationParameters.feeAmount, paymentAddress: paymentNetworkCreationParameters.paymentAddress, refundAddress: paymentNetworkCreationParameters.refundAddress }, paymentNetworkCreationParameters));
        });
    }
    /**
     * Creates the extensions data to add fee address and amount
     *
     * @param Parameters to add refund information
     * @returns The extensionData object
     */
    createExtensionsDataForAddFeeInformation(parameters) {
        return this.extension.createAddFeeAction({
            feeAddress: parameters.feeAddress,
            feeAmount: parameters.feeAmount,
        });
    }
    getBalance(request) {
        const _super = Object.create(null, {
            getBalance: { get: () => super.getBalance }
        });
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const balance = yield _super.getBalance.call(this, request);
            if (balance.error) {
                return balance;
            }
            // FIXME: should be at the same level as balance
            const values = this.getPaymentExtension(request).values;
            values.feeBalance = yield this.getFeeBalance(request, balance);
            return balance;
        });
    }
    getFeeBalance(request, balance) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const { feeAddress } = this.getPaymentExtension(request).values;
            this.checkRequiredParameter(feeAddress, 'feeAddress');
            const feeBalance = this.computeFeeBalance(balance.events, feeAddress).toString();
            return {
                events: balance.events,
                balance: feeBalance,
            };
        });
    }
    // Sum fee that are directed to the right fee address
    computeFeeBalance(feeEvents, feeAddress) {
        return feeEvents.reduce((sum, curr) => {
            var _a;
            return curr.parameters &&
                'feeAmount' in curr.parameters &&
                curr.parameters.feeAmount &&
                (!((_a = curr.parameters) === null || _a === void 0 ? void 0 : _a.feeAddress) || curr.parameters.feeAddress === feeAddress)
                ? sum.add(curr.parameters.feeAmount)
                : sum;
        }, ethers_1.BigNumber.from(0));
    }
}
exports.FeeReferenceBasedDetector = FeeReferenceBasedDetector;
//# sourceMappingURL=fee-reference-based-detector.js.map