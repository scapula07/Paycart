"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthFeeProxyPaymentDetector = void 0;
const tslib_1 = require("tslib");
const SmartContracts = require("@requestnetwork/smart-contracts");
const types_1 = require("@requestnetwork/types");
const proxy_info_retriever_1 = require("./proxy-info-retriever");
const fee_reference_based_detector_1 = require("../fee-reference-based-detector");
const utils_1 = require("../utils");
const thegraph_1 = require("../thegraph");
const PROXY_CONTRACT_ADDRESS_MAP = {
    ['0.1.0']: '0.1.0',
    ['0.2.0']: '0.2.0',
};
/**
 * Handle payment networks with ETH fee proxy extension
 */
class EthFeeProxyPaymentDetector extends fee_reference_based_detector_1.FeeReferenceBasedDetector {
    /**
     * @param extension The advanced logic payment network extensions
     */
    constructor({ advancedLogic, currencyManager, getSubgraphClient, }) {
        super(types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ETH_FEE_PROXY_CONTRACT, advancedLogic.extensions.feeProxyContractEth, currencyManager);
        this.getSubgraphClient = getSubgraphClient;
    }
    /**
     * Extracts payment events of an address matching an address and a payment reference
     *
     * @param eventName Indicate if it is an address for payment or refund
     * @param toAddress Address to check
     * @param paymentReference The reference to identify the payment
     * @param _requestCurrency The request currency
     * @param paymentChain the name of the payment (block)chain
     * @param paymentNetwork the payment network
     * @returns The balance
     */
    extractEvents(eventName, toAddress, paymentReference, _requestCurrency, paymentChain, paymentNetwork) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (!toAddress) {
                return {
                    paymentEvents: [],
                };
            }
            const proxyContractArtifact = EthFeeProxyPaymentDetector.getDeploymentInformation(paymentChain, paymentNetwork.version);
            const subgraphClient = this.getSubgraphClient(paymentChain);
            if (subgraphClient) {
                const graphInfoRetriever = new thegraph_1.TheGraphInfoRetriever(subgraphClient, this.currencyManager);
                return graphInfoRetriever.getTransferEvents({
                    paymentReference,
                    contractAddress: proxyContractArtifact.address,
                    toAddress,
                    eventName,
                    paymentChain,
                });
            }
            else {
                const proxyInfoRetriever = new proxy_info_retriever_1.EthProxyInfoRetriever(paymentReference, proxyContractArtifact.address, proxyContractArtifact.creationBlockNumber, toAddress, eventName, paymentChain);
                const paymentEvents = yield proxyInfoRetriever.getTransferEvents();
                return {
                    paymentEvents,
                };
            }
        });
    }
}
exports.EthFeeProxyPaymentDetector = EthFeeProxyPaymentDetector;
/*
 * Returns deployment information for the underlying smart contract for a given payment network version
 */
EthFeeProxyPaymentDetector.getDeploymentInformation = (0, utils_1.makeGetDeploymentInformation)(SmartContracts.ethereumFeeProxyArtifact, PROXY_CONTRACT_ADDRESS_MAP);
//# sourceMappingURL=fee-proxy-detector.js.map