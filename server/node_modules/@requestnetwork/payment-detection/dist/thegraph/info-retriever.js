"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TheGraphInfoRetriever = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const ethers_1 = require("ethers");
const lodash_1 = require("lodash");
const utils_1 = require("../utils");
class TheGraphInfoRetriever {
    constructor(client, currencyManager) {
        this.client = client;
        this.currencyManager = currencyManager;
    }
    getTransferEvents(params) {
        var _a;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const { payments, escrowEvents } = yield this.client.GetPaymentsAndEscrowState({
                reference: ethers_1.utils.keccak256(`0x${params.paymentReference}`),
                to: params.toAddress,
            });
            params.contractAddress = (0, utils_1.formatAddress)(params.contractAddress, 'contractAddress');
            params.acceptedTokens =
                ((_a = params.acceptedTokens) === null || _a === void 0 ? void 0 : _a.map((tok) => (0, utils_1.formatAddress)(tok, 'acceptedTokens'))) || [];
            return {
                paymentEvents: payments
                    .filter((payment) => this.filterPaymentEvents(payment, params))
                    .map((payment) => this.mapPaymentEvents(payment, params)),
                escrowEvents: escrowEvents.map((escrow) => this.mapEscrowEvents(escrow, params)),
            };
        });
    }
    filterPaymentEvents(payment, params) {
        var _a;
        // Check contract address matches expected
        if ((0, utils_1.formatAddress)(payment.contractAddress) !== (0, utils_1.formatAddress)(params.contractAddress)) {
            return false;
        }
        // Check paid token tokens matches expected (conversion only)
        if (payment.tokenAddress &&
            params.acceptedTokens &&
            params.acceptedTokens.length > 0 &&
            !((_a = params.acceptedTokens) === null || _a === void 0 ? void 0 : _a.includes((0, utils_1.formatAddress)(payment.tokenAddress, 'tokenAddress')))) {
            return false;
        }
        // Check payment was done within expected delays (conversion only)
        if (payment.maxRateTimespan !== undefined &&
            payment.maxRateTimespan !== null &&
            params.maxRateTimespan !== undefined &&
            payment.maxRateTimespan < params.maxRateTimespan) {
            return false;
        }
        return true;
    }
    mapPaymentEvents(payment, params) {
        let amount = payment.amount;
        let feeAmount = payment.feeAmount;
        if (payment.currency) {
            // account for the possibility the searched currency is of type ISO4217 and has no network
            const ccy = this.currencyManager.fromHash(payment.currency, params.paymentChain) ||
                this.currencyManager.fromHash(payment.currency);
            if (!ccy) {
                throw new Error(`Currency with hash ${payment.currency} is unknown`);
            }
            amount = (0, utils_1.unpadAmountFromChainlink)(amount, ccy).toString();
            feeAmount = (0, utils_1.unpadAmountFromChainlink)(feeAmount, ccy).toString();
        }
        return {
            amount,
            name: params.eventName,
            timestamp: payment.timestamp,
            parameters: Object.assign(Object.assign({ feeAmount, block: payment.block, to: (0, utils_1.formatAddress)(payment.to, 'to') }, (0, lodash_1.mapValues)((0, lodash_1.pick)(payment, 'txHash', 'gasUsed', 'gasPrice', 'amountInCrypto', 'feeAmountInCrypto', 'maxRateTimespan'), (val) => (val !== null ? String(val) : undefined))), (0, lodash_1.mapValues)((0, lodash_1.pick)(payment, 'from', 'feeAddress', 'tokenAddress'), (str, key) => str ? (0, utils_1.formatAddress)(str, key) : undefined)),
        };
    }
    mapEscrowEvents(escrow, params) {
        return {
            name: types_1.PaymentTypes.EVENTS_NAMES.ESCROW,
            timestamp: escrow.timestamp,
            parameters: {
                to: params.toAddress,
                from: escrow.from,
                txHash: escrow.txHash,
                block: escrow.block,
                eventName: escrow.eventName,
                gasUsed: escrow.gasUsed,
                gasPrice: escrow.gasPrice,
            },
        };
    }
}
exports.TheGraphInfoRetriever = TheGraphInfoRetriever;
//# sourceMappingURL=info-retriever.js.map