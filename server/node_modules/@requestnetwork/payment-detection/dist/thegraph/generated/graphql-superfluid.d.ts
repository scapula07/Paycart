import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
export declare type Maybe<T> = T | null;
export declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export declare type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export declare type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    BigDecimal: any;
    BigInt: any;
    Bytes: any;
};
/**
 * Account: A higher order entity created for any addresses which interact with
 * Superfluid contracts.
 */
export declare type Account = {
    __typename?: 'Account';
    id: Scalars['ID'];
    createdAtTimestamp: Scalars['BigInt'];
    createdAtBlockNumber: Scalars['BigInt'];
    updatedAtTimestamp: Scalars['BigInt'];
    updatedAtBlockNumber: Scalars['BigInt'];
    /** Indicates whether the address/account is a super app. */
    isSuperApp: Scalars['Boolean'];
    inflows: Array<Stream>;
    outflows: Array<Stream>;
    subscriptions: Array<IndexSubscription>;
    publishedIndexes: Array<Index>;
    sentTransferEvents: Array<TransferEvent>;
    receivedTransferEvents: Array<TransferEvent>;
    tokenUpgradedEvents: Array<TokenUpgradedEvent>;
    tokenDowngradedEvents: Array<TokenDowngradedEvent>;
    accountTokenSnapshots: Array<AccountTokenSnapshot>;
};
/**
 * Account: A higher order entity created for any addresses which interact with
 * Superfluid contracts.
 */
export declare type AccountInflowsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Stream_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Stream_Filter>;
};
/**
 * Account: A higher order entity created for any addresses which interact with
 * Superfluid contracts.
 */
export declare type AccountOutflowsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Stream_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Stream_Filter>;
};
/**
 * Account: A higher order entity created for any addresses which interact with
 * Superfluid contracts.
 */
export declare type AccountSubscriptionsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexSubscription_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexSubscription_Filter>;
};
/**
 * Account: A higher order entity created for any addresses which interact with
 * Superfluid contracts.
 */
export declare type AccountPublishedIndexesArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Index_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Index_Filter>;
};
/**
 * Account: A higher order entity created for any addresses which interact with
 * Superfluid contracts.
 */
export declare type AccountSentTransferEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TransferEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TransferEvent_Filter>;
};
/**
 * Account: A higher order entity created for any addresses which interact with
 * Superfluid contracts.
 */
export declare type AccountReceivedTransferEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TransferEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TransferEvent_Filter>;
};
/**
 * Account: A higher order entity created for any addresses which interact with
 * Superfluid contracts.
 */
export declare type AccountTokenUpgradedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenUpgradedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenUpgradedEvent_Filter>;
};
/**
 * Account: A higher order entity created for any addresses which interact with
 * Superfluid contracts.
 */
export declare type AccountTokenDowngradedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenDowngradedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenDowngradedEvent_Filter>;
};
/**
 * Account: A higher order entity created for any addresses which interact with
 * Superfluid contracts.
 */
export declare type AccountAccountTokenSnapshotsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AccountTokenSnapshot_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AccountTokenSnapshot_Filter>;
};
/**
 * AccountTokenSnapshot: An aggregate entity which aggregates data on an account's
 * interaction with a `token`.
 */
export declare type AccountTokenSnapshot = {
    __typename?: 'AccountTokenSnapshot';
    /** ID composed of: accountID-tokenID */
    id: Scalars['ID'];
    updatedAtTimestamp: Scalars['BigInt'];
    updatedAtBlockNumber: Scalars['BigInt'];
    /**
     * isLiquidationEstimateOptimistic, If `totalSubscriptionsWithUnits > 0`, it is true.
     * Optimistic means that it is the earliest time the user will be liquidated as they may receive ongoing distributions which aren't tracked by the subgraph
     */
    isLiquidationEstimateOptimistic: Scalars['Boolean'];
    /** Optimistic liquidation estimation property. */
    maybeCriticalAtTimestamp?: Maybe<Scalars['BigInt']>;
    /** The number of currently open streams. */
    totalNumberOfActiveStreams: Scalars['Int'];
    /** The number of all-time closed streams. */
    totalNumberOfClosedStreams: Scalars['Int'];
    /** The current (as of updatedAt) number of subscriptions with units allocated to them tied to this `account`. */
    totalSubscriptionsWithUnits: Scalars['Int'];
    /** Counts all currently (as of updatedAt) approved subscriptions whether or not they have units. */
    totalApprovedSubscriptions: Scalars['Int'];
    /** Balance of `account` as of `updatedAtTimestamp`/`updatedAtBlock`. */
    balanceUntilUpdatedAt: Scalars['BigInt'];
    /** The total deposit this account has held by the CFA agreement for `account` active streams. */
    totalDeposit: Scalars['BigInt'];
    /** The total net flow rate of the `account` as of `updatedAtTimestamp`/`updatedAtBlock`. */
    totalNetFlowRate: Scalars['BigInt'];
    /** The total inflow rate (receive flowRate per second) of the `account`. */
    totalInflowRate: Scalars['BigInt'];
    /** The total outflow rate (send flowrate per second) of the `account`. */
    totalOutflowRate: Scalars['BigInt'];
    /**
     * The total amount of `token` streamed into this `account` until
     * the `updatedAtTimestamp`/`updatedAtBlock`.
     */
    totalAmountStreamedInUntilUpdatedAt: Scalars['BigInt'];
    /**
     * The total amount of `token` streamed from this `account` until
     * the `updatedAtTimestamp`/`updatedAtBlock`.
     */
    totalAmountStreamedOutUntilUpdatedAt: Scalars['BigInt'];
    /**
     * The total amount of `token` streamed through this `account` until
     * the `updatedAtTimestamp`/`updatedAtBlock`.
     */
    totalAmountStreamedUntilUpdatedAt: Scalars['BigInt'];
    /** The total amount of `token` this `account` has transferred. */
    totalAmountTransferredUntilUpdatedAt: Scalars['BigInt'];
    account: Account;
    token: Token;
    flowOperators: Array<FlowOperator>;
    accountTokenSnapshotLogs: Array<AccountTokenSnapshotLog>;
};
/**
 * AccountTokenSnapshot: An aggregate entity which aggregates data on an account's
 * interaction with a `token`.
 */
export declare type AccountTokenSnapshotFlowOperatorsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowOperator_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowOperator_Filter>;
};
/**
 * AccountTokenSnapshot: An aggregate entity which aggregates data on an account's
 * interaction with a `token`.
 */
export declare type AccountTokenSnapshotAccountTokenSnapshotLogsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AccountTokenSnapshotLog_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AccountTokenSnapshotLog_Filter>;
};
/** AccountTokenSnapshotLog: Historical entries of AccountTokenSnapshot updates. */
export declare type AccountTokenSnapshotLog = {
    __typename?: 'AccountTokenSnapshotLog';
    id: Scalars['ID'];
    timestamp: Scalars['BigInt'];
    blockNumber: Scalars['BigInt'];
    transactionHash: Scalars['Bytes'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    triggeredByEventName: Scalars['String'];
    /** Optimistic liquidation estimation property. */
    maybeCriticalAtTimestamp?: Maybe<Scalars['BigInt']>;
    /** The current (as of timestamp) number of currently open streams. */
    totalNumberOfActiveStreams: Scalars['Int'];
    /** The current (as of timestamp) number of all-time closed streams. */
    totalNumberOfClosedStreams: Scalars['Int'];
    /** The current (as of timestamp) number of subscriptions with units allocated to them tied to this `account`. */
    totalSubscriptionsWithUnits: Scalars['Int'];
    /** Counts all currently (as of timestamp) approved subscriptions whether or not they have units. */
    totalApprovedSubscriptions: Scalars['Int'];
    /** Balance of `account` as of `timestamp`/`block`. */
    balance: Scalars['BigInt'];
    /** The total (as of timestamp) deposit this account has held by the CFA agreement for `account` active streams. */
    totalDeposit: Scalars['BigInt'];
    /** The total (as of timestamp) net flow rate of the `account` as of `timestamp`/`block`. */
    totalNetFlowRate: Scalars['BigInt'];
    /** The total (as of timestamp) inflow rate (receive flowRate per second) of the `account`. */
    totalInflowRate: Scalars['BigInt'];
    /** The total (as of timestamp) outflow rate (send flowrate per second) of the `account`. */
    totalOutflowRate: Scalars['BigInt'];
    /**
     * The total (as of timestamp) amount of `token` streamed into this `account` until
     * the `timestamp`/`block`.
     */
    totalAmountStreamedIn: Scalars['BigInt'];
    /**
     * The total (as of timestamp) amount of `token` streamed from this `account` until
     * the `timestamp`/`block`.
     */
    totalAmountStreamedOut: Scalars['BigInt'];
    /**
     * The total (as of timestamp) net amount of `token` streamed through this `account` until
     * the `timestamp`/`block`.
     */
    totalAmountStreamed: Scalars['BigInt'];
    /** The total (as of timestamp) amount of `token` this `account` has transferred. */
    totalAmountTransferred: Scalars['BigInt'];
    account: Account;
    token: Token;
    accountTokenSnapshot: AccountTokenSnapshot;
};
export declare type AccountTokenSnapshotLog_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    triggeredByEventName?: Maybe<Scalars['String']>;
    triggeredByEventName_not?: Maybe<Scalars['String']>;
    triggeredByEventName_gt?: Maybe<Scalars['String']>;
    triggeredByEventName_lt?: Maybe<Scalars['String']>;
    triggeredByEventName_gte?: Maybe<Scalars['String']>;
    triggeredByEventName_lte?: Maybe<Scalars['String']>;
    triggeredByEventName_in?: Maybe<Array<Scalars['String']>>;
    triggeredByEventName_not_in?: Maybe<Array<Scalars['String']>>;
    triggeredByEventName_contains?: Maybe<Scalars['String']>;
    triggeredByEventName_contains_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_not_contains?: Maybe<Scalars['String']>;
    triggeredByEventName_not_contains_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_starts_with?: Maybe<Scalars['String']>;
    triggeredByEventName_starts_with_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_not_starts_with?: Maybe<Scalars['String']>;
    triggeredByEventName_not_starts_with_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_ends_with?: Maybe<Scalars['String']>;
    triggeredByEventName_ends_with_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_not_ends_with?: Maybe<Scalars['String']>;
    triggeredByEventName_not_ends_with_nocase?: Maybe<Scalars['String']>;
    maybeCriticalAtTimestamp?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    maybeCriticalAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalNumberOfActiveStreams?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_not?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_gt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_lt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_gte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_lte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfActiveStreams_not_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfClosedStreams?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_not?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_gt?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_lt?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_gte?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_lte?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfClosedStreams_not_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_not?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits_not_in?: Maybe<Array<Scalars['Int']>>;
    totalApprovedSubscriptions?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_not?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_gt?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_lt?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_gte?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_lte?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_in?: Maybe<Array<Scalars['Int']>>;
    totalApprovedSubscriptions_not_in?: Maybe<Array<Scalars['Int']>>;
    balance?: Maybe<Scalars['BigInt']>;
    balance_not?: Maybe<Scalars['BigInt']>;
    balance_gt?: Maybe<Scalars['BigInt']>;
    balance_lt?: Maybe<Scalars['BigInt']>;
    balance_gte?: Maybe<Scalars['BigInt']>;
    balance_lte?: Maybe<Scalars['BigInt']>;
    balance_in?: Maybe<Array<Scalars['BigInt']>>;
    balance_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalDeposit?: Maybe<Scalars['BigInt']>;
    totalDeposit_not?: Maybe<Scalars['BigInt']>;
    totalDeposit_gt?: Maybe<Scalars['BigInt']>;
    totalDeposit_lt?: Maybe<Scalars['BigInt']>;
    totalDeposit_gte?: Maybe<Scalars['BigInt']>;
    totalDeposit_lte?: Maybe<Scalars['BigInt']>;
    totalDeposit_in?: Maybe<Array<Scalars['BigInt']>>;
    totalDeposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalNetFlowRate?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_not?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_gt?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_lt?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_gte?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_lte?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalNetFlowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalInflowRate?: Maybe<Scalars['BigInt']>;
    totalInflowRate_not?: Maybe<Scalars['BigInt']>;
    totalInflowRate_gt?: Maybe<Scalars['BigInt']>;
    totalInflowRate_lt?: Maybe<Scalars['BigInt']>;
    totalInflowRate_gte?: Maybe<Scalars['BigInt']>;
    totalInflowRate_lte?: Maybe<Scalars['BigInt']>;
    totalInflowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalInflowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalOutflowRate?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_not?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_gt?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_lt?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_gte?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_lte?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalOutflowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedIn?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedIn_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedIn_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedIn_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedIn_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedIn_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedIn_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedIn_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedOut?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOut_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOut_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOut_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOut_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOut_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOut_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedOut_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamed?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountTransferred?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_not?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_gt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_lt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_gte?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_lte?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountTransferred_not_in?: Maybe<Array<Scalars['BigInt']>>;
    account?: Maybe<Scalars['String']>;
    account_not?: Maybe<Scalars['String']>;
    account_gt?: Maybe<Scalars['String']>;
    account_lt?: Maybe<Scalars['String']>;
    account_gte?: Maybe<Scalars['String']>;
    account_lte?: Maybe<Scalars['String']>;
    account_in?: Maybe<Array<Scalars['String']>>;
    account_not_in?: Maybe<Array<Scalars['String']>>;
    account_contains?: Maybe<Scalars['String']>;
    account_contains_nocase?: Maybe<Scalars['String']>;
    account_not_contains?: Maybe<Scalars['String']>;
    account_not_contains_nocase?: Maybe<Scalars['String']>;
    account_starts_with?: Maybe<Scalars['String']>;
    account_starts_with_nocase?: Maybe<Scalars['String']>;
    account_not_starts_with?: Maybe<Scalars['String']>;
    account_not_starts_with_nocase?: Maybe<Scalars['String']>;
    account_ends_with?: Maybe<Scalars['String']>;
    account_ends_with_nocase?: Maybe<Scalars['String']>;
    account_not_ends_with?: Maybe<Scalars['String']>;
    account_not_ends_with_nocase?: Maybe<Scalars['String']>;
    account_?: Maybe<Account_Filter>;
    token?: Maybe<Scalars['String']>;
    token_not?: Maybe<Scalars['String']>;
    token_gt?: Maybe<Scalars['String']>;
    token_lt?: Maybe<Scalars['String']>;
    token_gte?: Maybe<Scalars['String']>;
    token_lte?: Maybe<Scalars['String']>;
    token_in?: Maybe<Array<Scalars['String']>>;
    token_not_in?: Maybe<Array<Scalars['String']>>;
    token_contains?: Maybe<Scalars['String']>;
    token_contains_nocase?: Maybe<Scalars['String']>;
    token_not_contains?: Maybe<Scalars['String']>;
    token_not_contains_nocase?: Maybe<Scalars['String']>;
    token_starts_with?: Maybe<Scalars['String']>;
    token_starts_with_nocase?: Maybe<Scalars['String']>;
    token_not_starts_with?: Maybe<Scalars['String']>;
    token_not_starts_with_nocase?: Maybe<Scalars['String']>;
    token_ends_with?: Maybe<Scalars['String']>;
    token_ends_with_nocase?: Maybe<Scalars['String']>;
    token_not_ends_with?: Maybe<Scalars['String']>;
    token_not_ends_with_nocase?: Maybe<Scalars['String']>;
    token_?: Maybe<Token_Filter>;
    accountTokenSnapshot?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not?: Maybe<Scalars['String']>;
    accountTokenSnapshot_gt?: Maybe<Scalars['String']>;
    accountTokenSnapshot_lt?: Maybe<Scalars['String']>;
    accountTokenSnapshot_gte?: Maybe<Scalars['String']>;
    accountTokenSnapshot_lte?: Maybe<Scalars['String']>;
    accountTokenSnapshot_in?: Maybe<Array<Scalars['String']>>;
    accountTokenSnapshot_not_in?: Maybe<Array<Scalars['String']>>;
    accountTokenSnapshot_contains?: Maybe<Scalars['String']>;
    accountTokenSnapshot_contains_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_contains?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_contains_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_starts_with?: Maybe<Scalars['String']>;
    accountTokenSnapshot_starts_with_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_starts_with?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_starts_with_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_ends_with?: Maybe<Scalars['String']>;
    accountTokenSnapshot_ends_with_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_ends_with?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_ends_with_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_?: Maybe<AccountTokenSnapshot_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum AccountTokenSnapshotLog_OrderBy {
    Id = "id",
    Timestamp = "timestamp",
    BlockNumber = "blockNumber",
    TransactionHash = "transactionHash",
    LogIndex = "logIndex",
    Order = "order",
    TriggeredByEventName = "triggeredByEventName",
    MaybeCriticalAtTimestamp = "maybeCriticalAtTimestamp",
    TotalNumberOfActiveStreams = "totalNumberOfActiveStreams",
    TotalNumberOfClosedStreams = "totalNumberOfClosedStreams",
    TotalSubscriptionsWithUnits = "totalSubscriptionsWithUnits",
    TotalApprovedSubscriptions = "totalApprovedSubscriptions",
    Balance = "balance",
    TotalDeposit = "totalDeposit",
    TotalNetFlowRate = "totalNetFlowRate",
    TotalInflowRate = "totalInflowRate",
    TotalOutflowRate = "totalOutflowRate",
    TotalAmountStreamedIn = "totalAmountStreamedIn",
    TotalAmountStreamedOut = "totalAmountStreamedOut",
    TotalAmountStreamed = "totalAmountStreamed",
    TotalAmountTransferred = "totalAmountTransferred",
    Account = "account",
    Token = "token",
    AccountTokenSnapshot = "accountTokenSnapshot"
}
export declare type AccountTokenSnapshot_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    updatedAtTimestamp?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    isLiquidationEstimateOptimistic?: Maybe<Scalars['Boolean']>;
    isLiquidationEstimateOptimistic_not?: Maybe<Scalars['Boolean']>;
    isLiquidationEstimateOptimistic_in?: Maybe<Array<Scalars['Boolean']>>;
    isLiquidationEstimateOptimistic_not_in?: Maybe<Array<Scalars['Boolean']>>;
    maybeCriticalAtTimestamp?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    maybeCriticalAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    maybeCriticalAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalNumberOfActiveStreams?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_not?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_gt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_lt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_gte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_lte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfActiveStreams_not_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfClosedStreams?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_not?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_gt?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_lt?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_gte?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_lte?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfClosedStreams_not_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_not?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits_not_in?: Maybe<Array<Scalars['Int']>>;
    totalApprovedSubscriptions?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_not?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_gt?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_lt?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_gte?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_lte?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_in?: Maybe<Array<Scalars['Int']>>;
    totalApprovedSubscriptions_not_in?: Maybe<Array<Scalars['Int']>>;
    balanceUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    balanceUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    balanceUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    balanceUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    balanceUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    balanceUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    balanceUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    balanceUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalDeposit?: Maybe<Scalars['BigInt']>;
    totalDeposit_not?: Maybe<Scalars['BigInt']>;
    totalDeposit_gt?: Maybe<Scalars['BigInt']>;
    totalDeposit_lt?: Maybe<Scalars['BigInt']>;
    totalDeposit_gte?: Maybe<Scalars['BigInt']>;
    totalDeposit_lte?: Maybe<Scalars['BigInt']>;
    totalDeposit_in?: Maybe<Array<Scalars['BigInt']>>;
    totalDeposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalNetFlowRate?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_not?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_gt?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_lt?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_gte?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_lte?: Maybe<Scalars['BigInt']>;
    totalNetFlowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalNetFlowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalInflowRate?: Maybe<Scalars['BigInt']>;
    totalInflowRate_not?: Maybe<Scalars['BigInt']>;
    totalInflowRate_gt?: Maybe<Scalars['BigInt']>;
    totalInflowRate_lt?: Maybe<Scalars['BigInt']>;
    totalInflowRate_gte?: Maybe<Scalars['BigInt']>;
    totalInflowRate_lte?: Maybe<Scalars['BigInt']>;
    totalInflowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalInflowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalOutflowRate?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_not?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_gt?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_lt?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_gte?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_lte?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalOutflowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedInUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedInUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedInUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedInUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedInUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedInUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedInUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedInUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedOutUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOutUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOutUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOutUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOutUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOutUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedOutUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedOutUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountTransferredUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountTransferredUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    account?: Maybe<Scalars['String']>;
    account_not?: Maybe<Scalars['String']>;
    account_gt?: Maybe<Scalars['String']>;
    account_lt?: Maybe<Scalars['String']>;
    account_gte?: Maybe<Scalars['String']>;
    account_lte?: Maybe<Scalars['String']>;
    account_in?: Maybe<Array<Scalars['String']>>;
    account_not_in?: Maybe<Array<Scalars['String']>>;
    account_contains?: Maybe<Scalars['String']>;
    account_contains_nocase?: Maybe<Scalars['String']>;
    account_not_contains?: Maybe<Scalars['String']>;
    account_not_contains_nocase?: Maybe<Scalars['String']>;
    account_starts_with?: Maybe<Scalars['String']>;
    account_starts_with_nocase?: Maybe<Scalars['String']>;
    account_not_starts_with?: Maybe<Scalars['String']>;
    account_not_starts_with_nocase?: Maybe<Scalars['String']>;
    account_ends_with?: Maybe<Scalars['String']>;
    account_ends_with_nocase?: Maybe<Scalars['String']>;
    account_not_ends_with?: Maybe<Scalars['String']>;
    account_not_ends_with_nocase?: Maybe<Scalars['String']>;
    account_?: Maybe<Account_Filter>;
    token?: Maybe<Scalars['String']>;
    token_not?: Maybe<Scalars['String']>;
    token_gt?: Maybe<Scalars['String']>;
    token_lt?: Maybe<Scalars['String']>;
    token_gte?: Maybe<Scalars['String']>;
    token_lte?: Maybe<Scalars['String']>;
    token_in?: Maybe<Array<Scalars['String']>>;
    token_not_in?: Maybe<Array<Scalars['String']>>;
    token_contains?: Maybe<Scalars['String']>;
    token_contains_nocase?: Maybe<Scalars['String']>;
    token_not_contains?: Maybe<Scalars['String']>;
    token_not_contains_nocase?: Maybe<Scalars['String']>;
    token_starts_with?: Maybe<Scalars['String']>;
    token_starts_with_nocase?: Maybe<Scalars['String']>;
    token_not_starts_with?: Maybe<Scalars['String']>;
    token_not_starts_with_nocase?: Maybe<Scalars['String']>;
    token_ends_with?: Maybe<Scalars['String']>;
    token_ends_with_nocase?: Maybe<Scalars['String']>;
    token_not_ends_with?: Maybe<Scalars['String']>;
    token_not_ends_with_nocase?: Maybe<Scalars['String']>;
    token_?: Maybe<Token_Filter>;
    flowOperators_?: Maybe<FlowOperator_Filter>;
    accountTokenSnapshotLogs_?: Maybe<AccountTokenSnapshotLog_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum AccountTokenSnapshot_OrderBy {
    Id = "id",
    UpdatedAtTimestamp = "updatedAtTimestamp",
    UpdatedAtBlockNumber = "updatedAtBlockNumber",
    IsLiquidationEstimateOptimistic = "isLiquidationEstimateOptimistic",
    MaybeCriticalAtTimestamp = "maybeCriticalAtTimestamp",
    TotalNumberOfActiveStreams = "totalNumberOfActiveStreams",
    TotalNumberOfClosedStreams = "totalNumberOfClosedStreams",
    TotalSubscriptionsWithUnits = "totalSubscriptionsWithUnits",
    TotalApprovedSubscriptions = "totalApprovedSubscriptions",
    BalanceUntilUpdatedAt = "balanceUntilUpdatedAt",
    TotalDeposit = "totalDeposit",
    TotalNetFlowRate = "totalNetFlowRate",
    TotalInflowRate = "totalInflowRate",
    TotalOutflowRate = "totalOutflowRate",
    TotalAmountStreamedInUntilUpdatedAt = "totalAmountStreamedInUntilUpdatedAt",
    TotalAmountStreamedOutUntilUpdatedAt = "totalAmountStreamedOutUntilUpdatedAt",
    TotalAmountStreamedUntilUpdatedAt = "totalAmountStreamedUntilUpdatedAt",
    TotalAmountTransferredUntilUpdatedAt = "totalAmountTransferredUntilUpdatedAt",
    Account = "account",
    Token = "token",
    FlowOperators = "flowOperators",
    AccountTokenSnapshotLogs = "accountTokenSnapshotLogs"
}
export declare type Account_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    createdAtTimestamp?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    isSuperApp?: Maybe<Scalars['Boolean']>;
    isSuperApp_not?: Maybe<Scalars['Boolean']>;
    isSuperApp_in?: Maybe<Array<Scalars['Boolean']>>;
    isSuperApp_not_in?: Maybe<Array<Scalars['Boolean']>>;
    inflows_?: Maybe<Stream_Filter>;
    outflows_?: Maybe<Stream_Filter>;
    subscriptions_?: Maybe<IndexSubscription_Filter>;
    publishedIndexes_?: Maybe<Index_Filter>;
    sentTransferEvents_?: Maybe<TransferEvent_Filter>;
    receivedTransferEvents_?: Maybe<TransferEvent_Filter>;
    tokenUpgradedEvents_?: Maybe<TokenUpgradedEvent_Filter>;
    tokenDowngradedEvents_?: Maybe<TokenDowngradedEvent_Filter>;
    accountTokenSnapshots_?: Maybe<AccountTokenSnapshot_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum Account_OrderBy {
    Id = "id",
    CreatedAtTimestamp = "createdAtTimestamp",
    CreatedAtBlockNumber = "createdAtBlockNumber",
    UpdatedAtTimestamp = "updatedAtTimestamp",
    UpdatedAtBlockNumber = "updatedAtBlockNumber",
    IsSuperApp = "isSuperApp",
    Inflows = "inflows",
    Outflows = "outflows",
    Subscriptions = "subscriptions",
    PublishedIndexes = "publishedIndexes",
    SentTransferEvents = "sentTransferEvents",
    ReceivedTransferEvents = "receivedTransferEvents",
    TokenUpgradedEvents = "tokenUpgradedEvents",
    TokenDowngradedEvents = "tokenDowngradedEvents",
    AccountTokenSnapshots = "accountTokenSnapshots"
}
export declare type AgreementClassRegisteredEvent = Event & {
    __typename?: 'AgreementClassRegisteredEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    agreementType: Scalars['Bytes'];
    code: Scalars['Bytes'];
};
export declare type AgreementClassRegisteredEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    agreementType?: Maybe<Scalars['Bytes']>;
    agreementType_not?: Maybe<Scalars['Bytes']>;
    agreementType_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementType_not_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementType_contains?: Maybe<Scalars['Bytes']>;
    agreementType_not_contains?: Maybe<Scalars['Bytes']>;
    code?: Maybe<Scalars['Bytes']>;
    code_not?: Maybe<Scalars['Bytes']>;
    code_in?: Maybe<Array<Scalars['Bytes']>>;
    code_not_in?: Maybe<Array<Scalars['Bytes']>>;
    code_contains?: Maybe<Scalars['Bytes']>;
    code_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum AgreementClassRegisteredEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    AgreementType = "agreementType",
    Code = "code"
}
export declare type AgreementClassUpdatedEvent = Event & {
    __typename?: 'AgreementClassUpdatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    agreementType: Scalars['Bytes'];
    code: Scalars['Bytes'];
};
export declare type AgreementClassUpdatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    agreementType?: Maybe<Scalars['Bytes']>;
    agreementType_not?: Maybe<Scalars['Bytes']>;
    agreementType_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementType_not_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementType_contains?: Maybe<Scalars['Bytes']>;
    agreementType_not_contains?: Maybe<Scalars['Bytes']>;
    code?: Maybe<Scalars['Bytes']>;
    code_not?: Maybe<Scalars['Bytes']>;
    code_in?: Maybe<Array<Scalars['Bytes']>>;
    code_not_in?: Maybe<Array<Scalars['Bytes']>>;
    code_contains?: Maybe<Scalars['Bytes']>;
    code_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum AgreementClassUpdatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    AgreementType = "agreementType",
    Code = "code"
}
export declare type AgreementLiquidatedByEvent = Event & {
    __typename?: 'AgreementLiquidatedByEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token, liquidatorAccount, penaltyAccount and bondAccount addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    liquidatorAccount: Scalars['Bytes'];
    agreementClass: Scalars['Bytes'];
    agreementId: Scalars['Bytes'];
    penaltyAccount: Scalars['Bytes'];
    bondAccount: Scalars['Bytes'];
    rewardAmount: Scalars['BigInt'];
    bailoutAmount: Scalars['BigInt'];
};
export declare type AgreementLiquidatedByEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    liquidatorAccount?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_not?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_in?: Maybe<Array<Scalars['Bytes']>>;
    liquidatorAccount_not_in?: Maybe<Array<Scalars['Bytes']>>;
    liquidatorAccount_contains?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_not_contains?: Maybe<Scalars['Bytes']>;
    agreementClass?: Maybe<Scalars['Bytes']>;
    agreementClass_not?: Maybe<Scalars['Bytes']>;
    agreementClass_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementClass_not_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementClass_contains?: Maybe<Scalars['Bytes']>;
    agreementClass_not_contains?: Maybe<Scalars['Bytes']>;
    agreementId?: Maybe<Scalars['Bytes']>;
    agreementId_not?: Maybe<Scalars['Bytes']>;
    agreementId_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementId_not_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementId_contains?: Maybe<Scalars['Bytes']>;
    agreementId_not_contains?: Maybe<Scalars['Bytes']>;
    penaltyAccount?: Maybe<Scalars['Bytes']>;
    penaltyAccount_not?: Maybe<Scalars['Bytes']>;
    penaltyAccount_in?: Maybe<Array<Scalars['Bytes']>>;
    penaltyAccount_not_in?: Maybe<Array<Scalars['Bytes']>>;
    penaltyAccount_contains?: Maybe<Scalars['Bytes']>;
    penaltyAccount_not_contains?: Maybe<Scalars['Bytes']>;
    bondAccount?: Maybe<Scalars['Bytes']>;
    bondAccount_not?: Maybe<Scalars['Bytes']>;
    bondAccount_in?: Maybe<Array<Scalars['Bytes']>>;
    bondAccount_not_in?: Maybe<Array<Scalars['Bytes']>>;
    bondAccount_contains?: Maybe<Scalars['Bytes']>;
    bondAccount_not_contains?: Maybe<Scalars['Bytes']>;
    rewardAmount?: Maybe<Scalars['BigInt']>;
    rewardAmount_not?: Maybe<Scalars['BigInt']>;
    rewardAmount_gt?: Maybe<Scalars['BigInt']>;
    rewardAmount_lt?: Maybe<Scalars['BigInt']>;
    rewardAmount_gte?: Maybe<Scalars['BigInt']>;
    rewardAmount_lte?: Maybe<Scalars['BigInt']>;
    rewardAmount_in?: Maybe<Array<Scalars['BigInt']>>;
    rewardAmount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    bailoutAmount?: Maybe<Scalars['BigInt']>;
    bailoutAmount_not?: Maybe<Scalars['BigInt']>;
    bailoutAmount_gt?: Maybe<Scalars['BigInt']>;
    bailoutAmount_lt?: Maybe<Scalars['BigInt']>;
    bailoutAmount_gte?: Maybe<Scalars['BigInt']>;
    bailoutAmount_lte?: Maybe<Scalars['BigInt']>;
    bailoutAmount_in?: Maybe<Array<Scalars['BigInt']>>;
    bailoutAmount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum AgreementLiquidatedByEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    LiquidatorAccount = "liquidatorAccount",
    AgreementClass = "agreementClass",
    AgreementId = "agreementId",
    PenaltyAccount = "penaltyAccount",
    BondAccount = "bondAccount",
    RewardAmount = "rewardAmount",
    BailoutAmount = "bailoutAmount"
}
export declare type AgreementLiquidatedV2Event = Event & {
    __typename?: 'AgreementLiquidatedV2Event';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token, liquidatorAccount, targetAccount and rewardAmountReceiver addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    liquidatorAccount: Scalars['Bytes'];
    agreementClass: Scalars['Bytes'];
    agreementId: Scalars['Bytes'];
    targetAccount: Scalars['Bytes'];
    rewardAmountReceiver: Scalars['Bytes'];
    rewardAmount: Scalars['BigInt'];
    targetAccountBalanceDelta: Scalars['BigInt'];
    version: Scalars['BigInt'];
    liquidationType: Scalars['Int'];
    /** TO BE DEPRECATED in v2 endpoint - use rewardAmountReceiver instead */
    rewardAccount: Scalars['Bytes'];
};
export declare type AgreementLiquidatedV2Event_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    liquidatorAccount?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_not?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_in?: Maybe<Array<Scalars['Bytes']>>;
    liquidatorAccount_not_in?: Maybe<Array<Scalars['Bytes']>>;
    liquidatorAccount_contains?: Maybe<Scalars['Bytes']>;
    liquidatorAccount_not_contains?: Maybe<Scalars['Bytes']>;
    agreementClass?: Maybe<Scalars['Bytes']>;
    agreementClass_not?: Maybe<Scalars['Bytes']>;
    agreementClass_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementClass_not_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementClass_contains?: Maybe<Scalars['Bytes']>;
    agreementClass_not_contains?: Maybe<Scalars['Bytes']>;
    agreementId?: Maybe<Scalars['Bytes']>;
    agreementId_not?: Maybe<Scalars['Bytes']>;
    agreementId_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementId_not_in?: Maybe<Array<Scalars['Bytes']>>;
    agreementId_contains?: Maybe<Scalars['Bytes']>;
    agreementId_not_contains?: Maybe<Scalars['Bytes']>;
    targetAccount?: Maybe<Scalars['Bytes']>;
    targetAccount_not?: Maybe<Scalars['Bytes']>;
    targetAccount_in?: Maybe<Array<Scalars['Bytes']>>;
    targetAccount_not_in?: Maybe<Array<Scalars['Bytes']>>;
    targetAccount_contains?: Maybe<Scalars['Bytes']>;
    targetAccount_not_contains?: Maybe<Scalars['Bytes']>;
    rewardAmountReceiver?: Maybe<Scalars['Bytes']>;
    rewardAmountReceiver_not?: Maybe<Scalars['Bytes']>;
    rewardAmountReceiver_in?: Maybe<Array<Scalars['Bytes']>>;
    rewardAmountReceiver_not_in?: Maybe<Array<Scalars['Bytes']>>;
    rewardAmountReceiver_contains?: Maybe<Scalars['Bytes']>;
    rewardAmountReceiver_not_contains?: Maybe<Scalars['Bytes']>;
    rewardAmount?: Maybe<Scalars['BigInt']>;
    rewardAmount_not?: Maybe<Scalars['BigInt']>;
    rewardAmount_gt?: Maybe<Scalars['BigInt']>;
    rewardAmount_lt?: Maybe<Scalars['BigInt']>;
    rewardAmount_gte?: Maybe<Scalars['BigInt']>;
    rewardAmount_lte?: Maybe<Scalars['BigInt']>;
    rewardAmount_in?: Maybe<Array<Scalars['BigInt']>>;
    rewardAmount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    targetAccountBalanceDelta?: Maybe<Scalars['BigInt']>;
    targetAccountBalanceDelta_not?: Maybe<Scalars['BigInt']>;
    targetAccountBalanceDelta_gt?: Maybe<Scalars['BigInt']>;
    targetAccountBalanceDelta_lt?: Maybe<Scalars['BigInt']>;
    targetAccountBalanceDelta_gte?: Maybe<Scalars['BigInt']>;
    targetAccountBalanceDelta_lte?: Maybe<Scalars['BigInt']>;
    targetAccountBalanceDelta_in?: Maybe<Array<Scalars['BigInt']>>;
    targetAccountBalanceDelta_not_in?: Maybe<Array<Scalars['BigInt']>>;
    version?: Maybe<Scalars['BigInt']>;
    version_not?: Maybe<Scalars['BigInt']>;
    version_gt?: Maybe<Scalars['BigInt']>;
    version_lt?: Maybe<Scalars['BigInt']>;
    version_gte?: Maybe<Scalars['BigInt']>;
    version_lte?: Maybe<Scalars['BigInt']>;
    version_in?: Maybe<Array<Scalars['BigInt']>>;
    version_not_in?: Maybe<Array<Scalars['BigInt']>>;
    liquidationType?: Maybe<Scalars['Int']>;
    liquidationType_not?: Maybe<Scalars['Int']>;
    liquidationType_gt?: Maybe<Scalars['Int']>;
    liquidationType_lt?: Maybe<Scalars['Int']>;
    liquidationType_gte?: Maybe<Scalars['Int']>;
    liquidationType_lte?: Maybe<Scalars['Int']>;
    liquidationType_in?: Maybe<Array<Scalars['Int']>>;
    liquidationType_not_in?: Maybe<Array<Scalars['Int']>>;
    rewardAccount?: Maybe<Scalars['Bytes']>;
    rewardAccount_not?: Maybe<Scalars['Bytes']>;
    rewardAccount_in?: Maybe<Array<Scalars['Bytes']>>;
    rewardAccount_not_in?: Maybe<Array<Scalars['Bytes']>>;
    rewardAccount_contains?: Maybe<Scalars['Bytes']>;
    rewardAccount_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum AgreementLiquidatedV2Event_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    LiquidatorAccount = "liquidatorAccount",
    AgreementClass = "agreementClass",
    AgreementId = "agreementId",
    TargetAccount = "targetAccount",
    RewardAmountReceiver = "rewardAmountReceiver",
    RewardAmount = "rewardAmount",
    TargetAccountBalanceDelta = "targetAccountBalanceDelta",
    Version = "version",
    LiquidationType = "liquidationType",
    RewardAccount = "rewardAccount"
}
export declare type AppRegisteredEvent = Event & {
    __typename?: 'AppRegisteredEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    app: Scalars['Bytes'];
};
export declare type AppRegisteredEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    app?: Maybe<Scalars['Bytes']>;
    app_not?: Maybe<Scalars['Bytes']>;
    app_in?: Maybe<Array<Scalars['Bytes']>>;
    app_not_in?: Maybe<Array<Scalars['Bytes']>>;
    app_contains?: Maybe<Scalars['Bytes']>;
    app_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum AppRegisteredEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    App = "app"
}
export declare type BlockChangedFilter = {
    number_gte: Scalars['Int'];
};
export declare type Block_Height = {
    hash?: Maybe<Scalars['Bytes']>;
    number?: Maybe<Scalars['Int']>;
    number_gte?: Maybe<Scalars['Int']>;
};
export declare type BurnedEvent = Event & {
    __typename?: 'BurnedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token and from addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    operator: Scalars['Bytes'];
    from: Scalars['Bytes'];
    token: Scalars['Bytes'];
    amount: Scalars['BigInt'];
    data: Scalars['Bytes'];
    operatorData: Scalars['Bytes'];
};
export declare type BurnedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    operator?: Maybe<Scalars['Bytes']>;
    operator_not?: Maybe<Scalars['Bytes']>;
    operator_in?: Maybe<Array<Scalars['Bytes']>>;
    operator_not_in?: Maybe<Array<Scalars['Bytes']>>;
    operator_contains?: Maybe<Scalars['Bytes']>;
    operator_not_contains?: Maybe<Scalars['Bytes']>;
    from?: Maybe<Scalars['Bytes']>;
    from_not?: Maybe<Scalars['Bytes']>;
    from_in?: Maybe<Array<Scalars['Bytes']>>;
    from_not_in?: Maybe<Array<Scalars['Bytes']>>;
    from_contains?: Maybe<Scalars['Bytes']>;
    from_not_contains?: Maybe<Scalars['Bytes']>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    amount?: Maybe<Scalars['BigInt']>;
    amount_not?: Maybe<Scalars['BigInt']>;
    amount_gt?: Maybe<Scalars['BigInt']>;
    amount_lt?: Maybe<Scalars['BigInt']>;
    amount_gte?: Maybe<Scalars['BigInt']>;
    amount_lte?: Maybe<Scalars['BigInt']>;
    amount_in?: Maybe<Array<Scalars['BigInt']>>;
    amount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    data?: Maybe<Scalars['Bytes']>;
    data_not?: Maybe<Scalars['Bytes']>;
    data_in?: Maybe<Array<Scalars['Bytes']>>;
    data_not_in?: Maybe<Array<Scalars['Bytes']>>;
    data_contains?: Maybe<Scalars['Bytes']>;
    data_not_contains?: Maybe<Scalars['Bytes']>;
    operatorData?: Maybe<Scalars['Bytes']>;
    operatorData_not?: Maybe<Scalars['Bytes']>;
    operatorData_in?: Maybe<Array<Scalars['Bytes']>>;
    operatorData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    operatorData_contains?: Maybe<Scalars['Bytes']>;
    operatorData_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum BurnedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Operator = "operator",
    From = "from",
    Token = "token",
    Amount = "amount",
    Data = "data",
    OperatorData = "operatorData"
}
export declare type CfAv1LiquidationPeriodChangedEvent = Event & {
    __typename?: 'CFAv1LiquidationPeriodChangedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** The address of the governance contract the event was emitted from. */
    governanceAddress: Scalars['Bytes'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    order: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    host: Scalars['Bytes'];
    superToken: Scalars['Bytes'];
    isKeySet: Scalars['Boolean'];
    liquidationPeriod: Scalars['BigInt'];
};
export declare type CfAv1LiquidationPeriodChangedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    governanceAddress?: Maybe<Scalars['Bytes']>;
    governanceAddress_not?: Maybe<Scalars['Bytes']>;
    governanceAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_contains?: Maybe<Scalars['Bytes']>;
    governanceAddress_not_contains?: Maybe<Scalars['Bytes']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    host?: Maybe<Scalars['Bytes']>;
    host_not?: Maybe<Scalars['Bytes']>;
    host_in?: Maybe<Array<Scalars['Bytes']>>;
    host_not_in?: Maybe<Array<Scalars['Bytes']>>;
    host_contains?: Maybe<Scalars['Bytes']>;
    host_not_contains?: Maybe<Scalars['Bytes']>;
    superToken?: Maybe<Scalars['Bytes']>;
    superToken_not?: Maybe<Scalars['Bytes']>;
    superToken_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_not_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_contains?: Maybe<Scalars['Bytes']>;
    superToken_not_contains?: Maybe<Scalars['Bytes']>;
    isKeySet?: Maybe<Scalars['Boolean']>;
    isKeySet_not?: Maybe<Scalars['Boolean']>;
    isKeySet_in?: Maybe<Array<Scalars['Boolean']>>;
    isKeySet_not_in?: Maybe<Array<Scalars['Boolean']>>;
    liquidationPeriod?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_not?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_gt?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_lt?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_gte?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_lte?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_in?: Maybe<Array<Scalars['BigInt']>>;
    liquidationPeriod_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum CfAv1LiquidationPeriodChangedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    GovernanceAddress = "governanceAddress",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    Order = "order",
    LogIndex = "logIndex",
    Host = "host",
    SuperToken = "superToken",
    IsKeySet = "isKeySet",
    LiquidationPeriod = "liquidationPeriod"
}
export declare type ConfigChangedEvent = Event & {
    __typename?: 'ConfigChangedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** The address of the governance contract the event was emitted from. */
    governanceAddress: Scalars['Bytes'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    host: Scalars['Bytes'];
    superToken: Scalars['Bytes'];
    key: Scalars['Bytes'];
    isKeySet: Scalars['Boolean'];
    value: Scalars['BigInt'];
};
export declare type ConfigChangedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    governanceAddress?: Maybe<Scalars['Bytes']>;
    governanceAddress_not?: Maybe<Scalars['Bytes']>;
    governanceAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_contains?: Maybe<Scalars['Bytes']>;
    governanceAddress_not_contains?: Maybe<Scalars['Bytes']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    host?: Maybe<Scalars['Bytes']>;
    host_not?: Maybe<Scalars['Bytes']>;
    host_in?: Maybe<Array<Scalars['Bytes']>>;
    host_not_in?: Maybe<Array<Scalars['Bytes']>>;
    host_contains?: Maybe<Scalars['Bytes']>;
    host_not_contains?: Maybe<Scalars['Bytes']>;
    superToken?: Maybe<Scalars['Bytes']>;
    superToken_not?: Maybe<Scalars['Bytes']>;
    superToken_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_not_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_contains?: Maybe<Scalars['Bytes']>;
    superToken_not_contains?: Maybe<Scalars['Bytes']>;
    key?: Maybe<Scalars['Bytes']>;
    key_not?: Maybe<Scalars['Bytes']>;
    key_in?: Maybe<Array<Scalars['Bytes']>>;
    key_not_in?: Maybe<Array<Scalars['Bytes']>>;
    key_contains?: Maybe<Scalars['Bytes']>;
    key_not_contains?: Maybe<Scalars['Bytes']>;
    isKeySet?: Maybe<Scalars['Boolean']>;
    isKeySet_not?: Maybe<Scalars['Boolean']>;
    isKeySet_in?: Maybe<Array<Scalars['Boolean']>>;
    isKeySet_not_in?: Maybe<Array<Scalars['Boolean']>>;
    value?: Maybe<Scalars['BigInt']>;
    value_not?: Maybe<Scalars['BigInt']>;
    value_gt?: Maybe<Scalars['BigInt']>;
    value_lt?: Maybe<Scalars['BigInt']>;
    value_gte?: Maybe<Scalars['BigInt']>;
    value_lte?: Maybe<Scalars['BigInt']>;
    value_in?: Maybe<Array<Scalars['BigInt']>>;
    value_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum ConfigChangedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    GovernanceAddress = "governanceAddress",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Host = "host",
    SuperToken = "superToken",
    Key = "key",
    IsKeySet = "isKeySet",
    Value = "value"
}
export declare type CustomSuperTokenCreatedEvent = Event & {
    __typename?: 'CustomSuperTokenCreatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token address. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
};
export declare type CustomSuperTokenCreatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum CustomSuperTokenCreatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token"
}
/**
 * Event: An interface which is shared by all
 * event entities and contains basic transaction
 * data.
 */
export declare type Event = {
    id: Scalars['ID'];
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the addresses for accounts that were impacted by the event. */
    addresses: Array<Scalars['Bytes']>;
    timestamp: Scalars['BigInt'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
};
export declare type Event_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum Event_OrderBy {
    Id = "id",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Name = "name",
    Addresses = "addresses",
    Timestamp = "timestamp",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice"
}
/** FlowOperator: A higher order entity that of a flow operator for an `AccountTokenSnapshot`. */
export declare type FlowOperator = {
    __typename?: 'FlowOperator';
    /** ID composed of: flowOperator - token - sender */
    id: Scalars['ID'];
    createdAtTimestamp: Scalars['BigInt'];
    createdAtBlockNumber: Scalars['BigInt'];
    updatedAtTimestamp: Scalars['BigInt'];
    updatedAtBlockNumber: Scalars['BigInt'];
    /**
     * The permissions granted to the `flowOperator`.
     * Octo bitmask representation.
     */
    permissions: Scalars['Int'];
    /**
     * The flow rate allowance granted to the `flowOperator`
     * by the `sender`. This can be reset if the `sender`
     * updates the `flowOperator` flow rate allowance.
     */
    flowRateAllowanceGranted: Scalars['BigInt'];
    /**
     * The remaining flow rate allowance the `flowOperator` has,
     * this will go down every time when `flowOperator` uses it
     * (if they increase flowRate or create a new flow)
     * and can only be reset if the `sender` updates the flow
     * rate allowance.
     */
    flowRateAllowanceRemaining: Scalars['BigInt'];
    flowOperator: Scalars['Bytes'];
    sender: Account;
    token: Token;
    accountTokenSnapshot: AccountTokenSnapshot;
    flowOperatorUpdatedEvents: Array<FlowOperatorUpdatedEvent>;
};
/** FlowOperator: A higher order entity that of a flow operator for an `AccountTokenSnapshot`. */
export declare type FlowOperatorFlowOperatorUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowOperatorUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowOperatorUpdatedEvent_Filter>;
};
export declare type FlowOperatorUpdatedEvent = Event & {
    __typename?: 'FlowOperatorUpdatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token, sender, and flowOperator addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    /** The address of the `token` being streamed. */
    token: Scalars['Bytes'];
    sender: Scalars['Bytes'];
    /**
     * The permissions granted to the `flowOperator`.
     * Octo bitmask representation.
     */
    permissions: Scalars['Int'];
    flowRateAllowance: Scalars['BigInt'];
    flowOperator: FlowOperator;
};
export declare type FlowOperatorUpdatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    sender?: Maybe<Scalars['Bytes']>;
    sender_not?: Maybe<Scalars['Bytes']>;
    sender_in?: Maybe<Array<Scalars['Bytes']>>;
    sender_not_in?: Maybe<Array<Scalars['Bytes']>>;
    sender_contains?: Maybe<Scalars['Bytes']>;
    sender_not_contains?: Maybe<Scalars['Bytes']>;
    permissions?: Maybe<Scalars['Int']>;
    permissions_not?: Maybe<Scalars['Int']>;
    permissions_gt?: Maybe<Scalars['Int']>;
    permissions_lt?: Maybe<Scalars['Int']>;
    permissions_gte?: Maybe<Scalars['Int']>;
    permissions_lte?: Maybe<Scalars['Int']>;
    permissions_in?: Maybe<Array<Scalars['Int']>>;
    permissions_not_in?: Maybe<Array<Scalars['Int']>>;
    flowRateAllowance?: Maybe<Scalars['BigInt']>;
    flowRateAllowance_not?: Maybe<Scalars['BigInt']>;
    flowRateAllowance_gt?: Maybe<Scalars['BigInt']>;
    flowRateAllowance_lt?: Maybe<Scalars['BigInt']>;
    flowRateAllowance_gte?: Maybe<Scalars['BigInt']>;
    flowRateAllowance_lte?: Maybe<Scalars['BigInt']>;
    flowRateAllowance_in?: Maybe<Array<Scalars['BigInt']>>;
    flowRateAllowance_not_in?: Maybe<Array<Scalars['BigInt']>>;
    flowOperator?: Maybe<Scalars['String']>;
    flowOperator_not?: Maybe<Scalars['String']>;
    flowOperator_gt?: Maybe<Scalars['String']>;
    flowOperator_lt?: Maybe<Scalars['String']>;
    flowOperator_gte?: Maybe<Scalars['String']>;
    flowOperator_lte?: Maybe<Scalars['String']>;
    flowOperator_in?: Maybe<Array<Scalars['String']>>;
    flowOperator_not_in?: Maybe<Array<Scalars['String']>>;
    flowOperator_contains?: Maybe<Scalars['String']>;
    flowOperator_contains_nocase?: Maybe<Scalars['String']>;
    flowOperator_not_contains?: Maybe<Scalars['String']>;
    flowOperator_not_contains_nocase?: Maybe<Scalars['String']>;
    flowOperator_starts_with?: Maybe<Scalars['String']>;
    flowOperator_starts_with_nocase?: Maybe<Scalars['String']>;
    flowOperator_not_starts_with?: Maybe<Scalars['String']>;
    flowOperator_not_starts_with_nocase?: Maybe<Scalars['String']>;
    flowOperator_ends_with?: Maybe<Scalars['String']>;
    flowOperator_ends_with_nocase?: Maybe<Scalars['String']>;
    flowOperator_not_ends_with?: Maybe<Scalars['String']>;
    flowOperator_not_ends_with_nocase?: Maybe<Scalars['String']>;
    flowOperator_?: Maybe<FlowOperator_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum FlowOperatorUpdatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Sender = "sender",
    Permissions = "permissions",
    FlowRateAllowance = "flowRateAllowance",
    FlowOperator = "flowOperator"
}
export declare type FlowOperator_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    createdAtTimestamp?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    permissions?: Maybe<Scalars['Int']>;
    permissions_not?: Maybe<Scalars['Int']>;
    permissions_gt?: Maybe<Scalars['Int']>;
    permissions_lt?: Maybe<Scalars['Int']>;
    permissions_gte?: Maybe<Scalars['Int']>;
    permissions_lte?: Maybe<Scalars['Int']>;
    permissions_in?: Maybe<Array<Scalars['Int']>>;
    permissions_not_in?: Maybe<Array<Scalars['Int']>>;
    flowRateAllowanceGranted?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceGranted_not?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceGranted_gt?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceGranted_lt?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceGranted_gte?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceGranted_lte?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceGranted_in?: Maybe<Array<Scalars['BigInt']>>;
    flowRateAllowanceGranted_not_in?: Maybe<Array<Scalars['BigInt']>>;
    flowRateAllowanceRemaining?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceRemaining_not?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceRemaining_gt?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceRemaining_lt?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceRemaining_gte?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceRemaining_lte?: Maybe<Scalars['BigInt']>;
    flowRateAllowanceRemaining_in?: Maybe<Array<Scalars['BigInt']>>;
    flowRateAllowanceRemaining_not_in?: Maybe<Array<Scalars['BigInt']>>;
    flowOperator?: Maybe<Scalars['Bytes']>;
    flowOperator_not?: Maybe<Scalars['Bytes']>;
    flowOperator_in?: Maybe<Array<Scalars['Bytes']>>;
    flowOperator_not_in?: Maybe<Array<Scalars['Bytes']>>;
    flowOperator_contains?: Maybe<Scalars['Bytes']>;
    flowOperator_not_contains?: Maybe<Scalars['Bytes']>;
    sender?: Maybe<Scalars['String']>;
    sender_not?: Maybe<Scalars['String']>;
    sender_gt?: Maybe<Scalars['String']>;
    sender_lt?: Maybe<Scalars['String']>;
    sender_gte?: Maybe<Scalars['String']>;
    sender_lte?: Maybe<Scalars['String']>;
    sender_in?: Maybe<Array<Scalars['String']>>;
    sender_not_in?: Maybe<Array<Scalars['String']>>;
    sender_contains?: Maybe<Scalars['String']>;
    sender_contains_nocase?: Maybe<Scalars['String']>;
    sender_not_contains?: Maybe<Scalars['String']>;
    sender_not_contains_nocase?: Maybe<Scalars['String']>;
    sender_starts_with?: Maybe<Scalars['String']>;
    sender_starts_with_nocase?: Maybe<Scalars['String']>;
    sender_not_starts_with?: Maybe<Scalars['String']>;
    sender_not_starts_with_nocase?: Maybe<Scalars['String']>;
    sender_ends_with?: Maybe<Scalars['String']>;
    sender_ends_with_nocase?: Maybe<Scalars['String']>;
    sender_not_ends_with?: Maybe<Scalars['String']>;
    sender_not_ends_with_nocase?: Maybe<Scalars['String']>;
    sender_?: Maybe<Account_Filter>;
    token?: Maybe<Scalars['String']>;
    token_not?: Maybe<Scalars['String']>;
    token_gt?: Maybe<Scalars['String']>;
    token_lt?: Maybe<Scalars['String']>;
    token_gte?: Maybe<Scalars['String']>;
    token_lte?: Maybe<Scalars['String']>;
    token_in?: Maybe<Array<Scalars['String']>>;
    token_not_in?: Maybe<Array<Scalars['String']>>;
    token_contains?: Maybe<Scalars['String']>;
    token_contains_nocase?: Maybe<Scalars['String']>;
    token_not_contains?: Maybe<Scalars['String']>;
    token_not_contains_nocase?: Maybe<Scalars['String']>;
    token_starts_with?: Maybe<Scalars['String']>;
    token_starts_with_nocase?: Maybe<Scalars['String']>;
    token_not_starts_with?: Maybe<Scalars['String']>;
    token_not_starts_with_nocase?: Maybe<Scalars['String']>;
    token_ends_with?: Maybe<Scalars['String']>;
    token_ends_with_nocase?: Maybe<Scalars['String']>;
    token_not_ends_with?: Maybe<Scalars['String']>;
    token_not_ends_with_nocase?: Maybe<Scalars['String']>;
    token_?: Maybe<Token_Filter>;
    accountTokenSnapshot?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not?: Maybe<Scalars['String']>;
    accountTokenSnapshot_gt?: Maybe<Scalars['String']>;
    accountTokenSnapshot_lt?: Maybe<Scalars['String']>;
    accountTokenSnapshot_gte?: Maybe<Scalars['String']>;
    accountTokenSnapshot_lte?: Maybe<Scalars['String']>;
    accountTokenSnapshot_in?: Maybe<Array<Scalars['String']>>;
    accountTokenSnapshot_not_in?: Maybe<Array<Scalars['String']>>;
    accountTokenSnapshot_contains?: Maybe<Scalars['String']>;
    accountTokenSnapshot_contains_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_contains?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_contains_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_starts_with?: Maybe<Scalars['String']>;
    accountTokenSnapshot_starts_with_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_starts_with?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_starts_with_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_ends_with?: Maybe<Scalars['String']>;
    accountTokenSnapshot_ends_with_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_ends_with?: Maybe<Scalars['String']>;
    accountTokenSnapshot_not_ends_with_nocase?: Maybe<Scalars['String']>;
    accountTokenSnapshot_?: Maybe<AccountTokenSnapshot_Filter>;
    flowOperatorUpdatedEvents_?: Maybe<FlowOperatorUpdatedEvent_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum FlowOperator_OrderBy {
    Id = "id",
    CreatedAtTimestamp = "createdAtTimestamp",
    CreatedAtBlockNumber = "createdAtBlockNumber",
    UpdatedAtTimestamp = "updatedAtTimestamp",
    UpdatedAtBlockNumber = "updatedAtBlockNumber",
    Permissions = "permissions",
    FlowRateAllowanceGranted = "flowRateAllowanceGranted",
    FlowRateAllowanceRemaining = "flowRateAllowanceRemaining",
    FlowOperator = "flowOperator",
    Sender = "sender",
    Token = "token",
    AccountTokenSnapshot = "accountTokenSnapshot",
    FlowOperatorUpdatedEvents = "flowOperatorUpdatedEvents"
}
/**
 * FlowUpdated: An `Event` entity that is emitted
 * when a flow is created, updated, or deleted.
 */
export declare type FlowUpdatedEvent = Event & {
    __typename?: 'FlowUpdatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token, sender and receiver addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    /** The address of the `token` being streamed. */
    token: Scalars['Bytes'];
    sender: Scalars['Bytes'];
    receiver: Scalars['Bytes'];
    /**
     * The address that is triggering the flow update.
     * This will be the zero address until the flowOperator
     * feature is live.
     */
    flowOperator: Scalars['Bytes'];
    /** The flow rate per second. */
    flowRate: Scalars['BigInt'];
    totalSenderFlowRate: Scalars['BigInt'];
    totalReceiverFlowRate: Scalars['BigInt'];
    deposit: Scalars['BigInt'];
    userData: Scalars['Bytes'];
    /** The previous flow rate. */
    oldFlowRate: Scalars['BigInt'];
    /**
     * The "type" of the `FlowUpdated` event.
     * 0 = create
     * 1 = update
     * 2 = terminate
     */
    type: Scalars['Int'];
    /**
     * The total amount streamed until the timestamp
     * for the Stream entity linked to this event.
     */
    totalAmountStreamedUntilTimestamp: Scalars['BigInt'];
    /** The stream entity which is being modified. */
    stream: Stream;
};
export declare type FlowUpdatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    sender?: Maybe<Scalars['Bytes']>;
    sender_not?: Maybe<Scalars['Bytes']>;
    sender_in?: Maybe<Array<Scalars['Bytes']>>;
    sender_not_in?: Maybe<Array<Scalars['Bytes']>>;
    sender_contains?: Maybe<Scalars['Bytes']>;
    sender_not_contains?: Maybe<Scalars['Bytes']>;
    receiver?: Maybe<Scalars['Bytes']>;
    receiver_not?: Maybe<Scalars['Bytes']>;
    receiver_in?: Maybe<Array<Scalars['Bytes']>>;
    receiver_not_in?: Maybe<Array<Scalars['Bytes']>>;
    receiver_contains?: Maybe<Scalars['Bytes']>;
    receiver_not_contains?: Maybe<Scalars['Bytes']>;
    flowOperator?: Maybe<Scalars['Bytes']>;
    flowOperator_not?: Maybe<Scalars['Bytes']>;
    flowOperator_in?: Maybe<Array<Scalars['Bytes']>>;
    flowOperator_not_in?: Maybe<Array<Scalars['Bytes']>>;
    flowOperator_contains?: Maybe<Scalars['Bytes']>;
    flowOperator_not_contains?: Maybe<Scalars['Bytes']>;
    flowRate?: Maybe<Scalars['BigInt']>;
    flowRate_not?: Maybe<Scalars['BigInt']>;
    flowRate_gt?: Maybe<Scalars['BigInt']>;
    flowRate_lt?: Maybe<Scalars['BigInt']>;
    flowRate_gte?: Maybe<Scalars['BigInt']>;
    flowRate_lte?: Maybe<Scalars['BigInt']>;
    flowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    flowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalSenderFlowRate?: Maybe<Scalars['BigInt']>;
    totalSenderFlowRate_not?: Maybe<Scalars['BigInt']>;
    totalSenderFlowRate_gt?: Maybe<Scalars['BigInt']>;
    totalSenderFlowRate_lt?: Maybe<Scalars['BigInt']>;
    totalSenderFlowRate_gte?: Maybe<Scalars['BigInt']>;
    totalSenderFlowRate_lte?: Maybe<Scalars['BigInt']>;
    totalSenderFlowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalSenderFlowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalReceiverFlowRate?: Maybe<Scalars['BigInt']>;
    totalReceiverFlowRate_not?: Maybe<Scalars['BigInt']>;
    totalReceiverFlowRate_gt?: Maybe<Scalars['BigInt']>;
    totalReceiverFlowRate_lt?: Maybe<Scalars['BigInt']>;
    totalReceiverFlowRate_gte?: Maybe<Scalars['BigInt']>;
    totalReceiverFlowRate_lte?: Maybe<Scalars['BigInt']>;
    totalReceiverFlowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalReceiverFlowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    deposit?: Maybe<Scalars['BigInt']>;
    deposit_not?: Maybe<Scalars['BigInt']>;
    deposit_gt?: Maybe<Scalars['BigInt']>;
    deposit_lt?: Maybe<Scalars['BigInt']>;
    deposit_gte?: Maybe<Scalars['BigInt']>;
    deposit_lte?: Maybe<Scalars['BigInt']>;
    deposit_in?: Maybe<Array<Scalars['BigInt']>>;
    deposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    oldFlowRate?: Maybe<Scalars['BigInt']>;
    oldFlowRate_not?: Maybe<Scalars['BigInt']>;
    oldFlowRate_gt?: Maybe<Scalars['BigInt']>;
    oldFlowRate_lt?: Maybe<Scalars['BigInt']>;
    oldFlowRate_gte?: Maybe<Scalars['BigInt']>;
    oldFlowRate_lte?: Maybe<Scalars['BigInt']>;
    oldFlowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    oldFlowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    type?: Maybe<Scalars['Int']>;
    type_not?: Maybe<Scalars['Int']>;
    type_gt?: Maybe<Scalars['Int']>;
    type_lt?: Maybe<Scalars['Int']>;
    type_gte?: Maybe<Scalars['Int']>;
    type_lte?: Maybe<Scalars['Int']>;
    type_in?: Maybe<Array<Scalars['Int']>>;
    type_not_in?: Maybe<Array<Scalars['Int']>>;
    totalAmountStreamedUntilTimestamp?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilTimestamp_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilTimestamp_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilTimestamp_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilTimestamp_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilTimestamp_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedUntilTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    stream?: Maybe<Scalars['String']>;
    stream_not?: Maybe<Scalars['String']>;
    stream_gt?: Maybe<Scalars['String']>;
    stream_lt?: Maybe<Scalars['String']>;
    stream_gte?: Maybe<Scalars['String']>;
    stream_lte?: Maybe<Scalars['String']>;
    stream_in?: Maybe<Array<Scalars['String']>>;
    stream_not_in?: Maybe<Array<Scalars['String']>>;
    stream_contains?: Maybe<Scalars['String']>;
    stream_contains_nocase?: Maybe<Scalars['String']>;
    stream_not_contains?: Maybe<Scalars['String']>;
    stream_not_contains_nocase?: Maybe<Scalars['String']>;
    stream_starts_with?: Maybe<Scalars['String']>;
    stream_starts_with_nocase?: Maybe<Scalars['String']>;
    stream_not_starts_with?: Maybe<Scalars['String']>;
    stream_not_starts_with_nocase?: Maybe<Scalars['String']>;
    stream_ends_with?: Maybe<Scalars['String']>;
    stream_ends_with_nocase?: Maybe<Scalars['String']>;
    stream_not_ends_with?: Maybe<Scalars['String']>;
    stream_not_ends_with_nocase?: Maybe<Scalars['String']>;
    stream_?: Maybe<Stream_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum FlowUpdatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Sender = "sender",
    Receiver = "receiver",
    FlowOperator = "flowOperator",
    FlowRate = "flowRate",
    TotalSenderFlowRate = "totalSenderFlowRate",
    TotalReceiverFlowRate = "totalReceiverFlowRate",
    Deposit = "deposit",
    UserData = "userData",
    OldFlowRate = "oldFlowRate",
    Type = "type",
    TotalAmountStreamedUntilTimestamp = "totalAmountStreamedUntilTimestamp",
    Stream = "stream"
}
export declare type GovernanceReplacedEvent = Event & {
    __typename?: 'GovernanceReplacedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    oldGovernance: Scalars['Bytes'];
    newGovernance: Scalars['Bytes'];
};
export declare type GovernanceReplacedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    oldGovernance?: Maybe<Scalars['Bytes']>;
    oldGovernance_not?: Maybe<Scalars['Bytes']>;
    oldGovernance_in?: Maybe<Array<Scalars['Bytes']>>;
    oldGovernance_not_in?: Maybe<Array<Scalars['Bytes']>>;
    oldGovernance_contains?: Maybe<Scalars['Bytes']>;
    oldGovernance_not_contains?: Maybe<Scalars['Bytes']>;
    newGovernance?: Maybe<Scalars['Bytes']>;
    newGovernance_not?: Maybe<Scalars['Bytes']>;
    newGovernance_in?: Maybe<Array<Scalars['Bytes']>>;
    newGovernance_not_in?: Maybe<Array<Scalars['Bytes']>>;
    newGovernance_contains?: Maybe<Scalars['Bytes']>;
    newGovernance_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum GovernanceReplacedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Addresses = "addresses",
    OldGovernance = "oldGovernance",
    NewGovernance = "newGovernance"
}
/** Index: An Index higher order entity. */
export declare type Index = {
    __typename?: 'Index';
    /** ID composed of: publisherAddress-tokenAddress-indexId */
    id: Scalars['ID'];
    createdAtTimestamp: Scalars['BigInt'];
    createdAtBlockNumber: Scalars['BigInt'];
    updatedAtTimestamp: Scalars['BigInt'];
    updatedAtBlockNumber: Scalars['BigInt'];
    /** indexId is not the id of the `Index` entity. */
    indexId: Scalars['BigInt'];
    indexValue: Scalars['BigInt'];
    /** The number of subscriptions which have units allocated to them on the `Index`. */
    totalSubscriptionsWithUnits: Scalars['Int'];
    /**
     * The number of units allocated by the `Index` that are pending.
     * This refers to the current (as of updatedAt) `totalUnitsPending`
     * - not all that has ever been pending.
     */
    totalUnitsPending: Scalars['BigInt'];
    /**
     * The number of units allocated by the `Index` that are approved.
     * This refers to the current (as of updatedAt) `totalUnitsApproved`
     * - not all that has ever been approved.
     */
    totalUnitsApproved: Scalars['BigInt'];
    /** The sum of `totalUnitsPending` and `totalUnitsApproved`. */
    totalUnits: Scalars['BigInt'];
    /** The total amount distributed from this `Index`. */
    totalAmountDistributedUntilUpdatedAt: Scalars['BigInt'];
    token: Token;
    publisher: Account;
    /**
     * The subscriptions of the index, it will include approved, unapproved
     * and deleted subscriptions.
     */
    subscriptions: Array<IndexSubscription>;
    /** IndexCreated event, there will only be one. */
    indexCreatedEvent: IndexCreatedEvent;
    indexDistributionClaimedEvents: Array<IndexDistributionClaimedEvent>;
    indexUpdatedEvents: Array<IndexUpdatedEvent>;
    indexSubscribedEvents: Array<IndexSubscribedEvent>;
    indexUnitsUpdatedEvents: Array<IndexUnitsUpdatedEvent>;
    indexUnsubscribedEvents: Array<IndexUnsubscribedEvent>;
};
/** Index: An Index higher order entity. */
export declare type IndexSubscriptionsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexSubscription_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexSubscription_Filter>;
};
/** Index: An Index higher order entity. */
export declare type IndexIndexDistributionClaimedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexDistributionClaimedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexDistributionClaimedEvent_Filter>;
};
/** Index: An Index higher order entity. */
export declare type IndexIndexUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUpdatedEvent_Filter>;
};
/** Index: An Index higher order entity. */
export declare type IndexIndexSubscribedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexSubscribedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexSubscribedEvent_Filter>;
};
/** Index: An Index higher order entity. */
export declare type IndexIndexUnitsUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUnitsUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUnitsUpdatedEvent_Filter>;
};
/** Index: An Index higher order entity. */
export declare type IndexIndexUnsubscribedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUnsubscribedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUnsubscribedEvent_Filter>;
};
export declare type IndexCreatedEvent = Event & {
    __typename?: 'IndexCreatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token and publisher addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    publisher: Scalars['Bytes'];
    indexId: Scalars['BigInt'];
    userData: Scalars['Bytes'];
    index: Index;
};
export declare type IndexCreatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    index?: Maybe<Scalars['String']>;
    index_not?: Maybe<Scalars['String']>;
    index_gt?: Maybe<Scalars['String']>;
    index_lt?: Maybe<Scalars['String']>;
    index_gte?: Maybe<Scalars['String']>;
    index_lte?: Maybe<Scalars['String']>;
    index_in?: Maybe<Array<Scalars['String']>>;
    index_not_in?: Maybe<Array<Scalars['String']>>;
    index_contains?: Maybe<Scalars['String']>;
    index_contains_nocase?: Maybe<Scalars['String']>;
    index_not_contains?: Maybe<Scalars['String']>;
    index_not_contains_nocase?: Maybe<Scalars['String']>;
    index_starts_with?: Maybe<Scalars['String']>;
    index_starts_with_nocase?: Maybe<Scalars['String']>;
    index_not_starts_with?: Maybe<Scalars['String']>;
    index_not_starts_with_nocase?: Maybe<Scalars['String']>;
    index_ends_with?: Maybe<Scalars['String']>;
    index_ends_with_nocase?: Maybe<Scalars['String']>;
    index_not_ends_with?: Maybe<Scalars['String']>;
    index_not_ends_with_nocase?: Maybe<Scalars['String']>;
    index_?: Maybe<Index_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum IndexCreatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Publisher = "publisher",
    IndexId = "indexId",
    UserData = "userData",
    Index = "index"
}
export declare type IndexDistributionClaimedEvent = Event & {
    __typename?: 'IndexDistributionClaimedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token, publisher and subscriber addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    publisher: Scalars['Bytes'];
    indexId: Scalars['BigInt'];
    subscriber: Scalars['Bytes'];
    amount: Scalars['BigInt'];
    index: Index;
};
export declare type IndexDistributionClaimedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    subscriber?: Maybe<Scalars['Bytes']>;
    subscriber_not?: Maybe<Scalars['Bytes']>;
    subscriber_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_not_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_contains?: Maybe<Scalars['Bytes']>;
    subscriber_not_contains?: Maybe<Scalars['Bytes']>;
    amount?: Maybe<Scalars['BigInt']>;
    amount_not?: Maybe<Scalars['BigInt']>;
    amount_gt?: Maybe<Scalars['BigInt']>;
    amount_lt?: Maybe<Scalars['BigInt']>;
    amount_gte?: Maybe<Scalars['BigInt']>;
    amount_lte?: Maybe<Scalars['BigInt']>;
    amount_in?: Maybe<Array<Scalars['BigInt']>>;
    amount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    index?: Maybe<Scalars['String']>;
    index_not?: Maybe<Scalars['String']>;
    index_gt?: Maybe<Scalars['String']>;
    index_lt?: Maybe<Scalars['String']>;
    index_gte?: Maybe<Scalars['String']>;
    index_lte?: Maybe<Scalars['String']>;
    index_in?: Maybe<Array<Scalars['String']>>;
    index_not_in?: Maybe<Array<Scalars['String']>>;
    index_contains?: Maybe<Scalars['String']>;
    index_contains_nocase?: Maybe<Scalars['String']>;
    index_not_contains?: Maybe<Scalars['String']>;
    index_not_contains_nocase?: Maybe<Scalars['String']>;
    index_starts_with?: Maybe<Scalars['String']>;
    index_starts_with_nocase?: Maybe<Scalars['String']>;
    index_not_starts_with?: Maybe<Scalars['String']>;
    index_not_starts_with_nocase?: Maybe<Scalars['String']>;
    index_ends_with?: Maybe<Scalars['String']>;
    index_ends_with_nocase?: Maybe<Scalars['String']>;
    index_not_ends_with?: Maybe<Scalars['String']>;
    index_not_ends_with_nocase?: Maybe<Scalars['String']>;
    index_?: Maybe<Index_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum IndexDistributionClaimedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Publisher = "publisher",
    IndexId = "indexId",
    Subscriber = "subscriber",
    Amount = "amount",
    Index = "index"
}
export declare type IndexSubscribedEvent = Event & {
    __typename?: 'IndexSubscribedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token, publisher and subscriber addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    publisher: Scalars['Bytes'];
    indexId: Scalars['BigInt'];
    subscriber: Scalars['Bytes'];
    userData: Scalars['Bytes'];
    index: Index;
};
export declare type IndexSubscribedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    subscriber?: Maybe<Scalars['Bytes']>;
    subscriber_not?: Maybe<Scalars['Bytes']>;
    subscriber_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_not_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_contains?: Maybe<Scalars['Bytes']>;
    subscriber_not_contains?: Maybe<Scalars['Bytes']>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    index?: Maybe<Scalars['String']>;
    index_not?: Maybe<Scalars['String']>;
    index_gt?: Maybe<Scalars['String']>;
    index_lt?: Maybe<Scalars['String']>;
    index_gte?: Maybe<Scalars['String']>;
    index_lte?: Maybe<Scalars['String']>;
    index_in?: Maybe<Array<Scalars['String']>>;
    index_not_in?: Maybe<Array<Scalars['String']>>;
    index_contains?: Maybe<Scalars['String']>;
    index_contains_nocase?: Maybe<Scalars['String']>;
    index_not_contains?: Maybe<Scalars['String']>;
    index_not_contains_nocase?: Maybe<Scalars['String']>;
    index_starts_with?: Maybe<Scalars['String']>;
    index_starts_with_nocase?: Maybe<Scalars['String']>;
    index_not_starts_with?: Maybe<Scalars['String']>;
    index_not_starts_with_nocase?: Maybe<Scalars['String']>;
    index_ends_with?: Maybe<Scalars['String']>;
    index_ends_with_nocase?: Maybe<Scalars['String']>;
    index_not_ends_with?: Maybe<Scalars['String']>;
    index_not_ends_with_nocase?: Maybe<Scalars['String']>;
    index_?: Maybe<Index_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum IndexSubscribedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Publisher = "publisher",
    IndexId = "indexId",
    Subscriber = "subscriber",
    UserData = "userData",
    Index = "index"
}
/**
 * IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular
 * `Index`.
 */
export declare type IndexSubscription = {
    __typename?: 'IndexSubscription';
    /** ID composed of: subscriberAddress-publisherAddress-tokenAddress-IndexId */
    id: Scalars['ID'];
    createdAtTimestamp: Scalars['BigInt'];
    createdAtBlockNumber: Scalars['BigInt'];
    updatedAtTimestamp: Scalars['BigInt'];
    updatedAtBlockNumber: Scalars['BigInt'];
    subscriber: Account;
    /**
     * Approved subscriptions don't require subscribers to claim tokens that are distributed from
     * the publisher.
     */
    approved: Scalars['Boolean'];
    /**
     * If units is 0, it indicates that the subscription is "deleted". They are no longer
     * subscribed to the index.
     */
    units: Scalars['BigInt'];
    /**
     * The total amount of tokens you've received via IDA until
     * `updatedAtTimestamp`/`updatedAtBlock`.
     */
    totalAmountReceivedUntilUpdatedAt: Scalars['BigInt'];
    /**
     * The previous index value - used to calculate `totalAmountReceivedUntilUpdatedAt` field as of the
     * `index.updatedAtTimestamp`. The formula to get this value is:
     * `IndexSubscription.totalAmountReceivedUntilUpdatedAt + ((index.newIndexValue - indexSubscription.indexValueUntilUpdatedAt) * indexSubscription.units)`.
     */
    indexValueUntilUpdatedAt: Scalars['BigInt'];
    index: Index;
    /** IndexSubscription approved events on the subscription. */
    subscriptionApprovedEvents: Array<SubscriptionApprovedEvent>;
    subscriptionDistributionClaimedEvents: Array<SubscriptionDistributionClaimedEvent>;
    subscriptionRevokedEvents: Array<SubscriptionRevokedEvent>;
    subscriptionUnitsUpdatedEvents: Array<SubscriptionUnitsUpdatedEvent>;
};
/**
 * IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular
 * `Index`.
 */
export declare type IndexSubscriptionSubscriptionApprovedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionApprovedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionApprovedEvent_Filter>;
};
/**
 * IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular
 * `Index`.
 */
export declare type IndexSubscriptionSubscriptionDistributionClaimedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionDistributionClaimedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionDistributionClaimedEvent_Filter>;
};
/**
 * IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular
 * `Index`.
 */
export declare type IndexSubscriptionSubscriptionRevokedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionRevokedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionRevokedEvent_Filter>;
};
/**
 * IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular
 * `Index`.
 */
export declare type IndexSubscriptionSubscriptionUnitsUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionUnitsUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionUnitsUpdatedEvent_Filter>;
};
export declare type IndexSubscription_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    createdAtTimestamp?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    subscriber?: Maybe<Scalars['String']>;
    subscriber_not?: Maybe<Scalars['String']>;
    subscriber_gt?: Maybe<Scalars['String']>;
    subscriber_lt?: Maybe<Scalars['String']>;
    subscriber_gte?: Maybe<Scalars['String']>;
    subscriber_lte?: Maybe<Scalars['String']>;
    subscriber_in?: Maybe<Array<Scalars['String']>>;
    subscriber_not_in?: Maybe<Array<Scalars['String']>>;
    subscriber_contains?: Maybe<Scalars['String']>;
    subscriber_contains_nocase?: Maybe<Scalars['String']>;
    subscriber_not_contains?: Maybe<Scalars['String']>;
    subscriber_not_contains_nocase?: Maybe<Scalars['String']>;
    subscriber_starts_with?: Maybe<Scalars['String']>;
    subscriber_starts_with_nocase?: Maybe<Scalars['String']>;
    subscriber_not_starts_with?: Maybe<Scalars['String']>;
    subscriber_not_starts_with_nocase?: Maybe<Scalars['String']>;
    subscriber_ends_with?: Maybe<Scalars['String']>;
    subscriber_ends_with_nocase?: Maybe<Scalars['String']>;
    subscriber_not_ends_with?: Maybe<Scalars['String']>;
    subscriber_not_ends_with_nocase?: Maybe<Scalars['String']>;
    subscriber_?: Maybe<Account_Filter>;
    approved?: Maybe<Scalars['Boolean']>;
    approved_not?: Maybe<Scalars['Boolean']>;
    approved_in?: Maybe<Array<Scalars['Boolean']>>;
    approved_not_in?: Maybe<Array<Scalars['Boolean']>>;
    units?: Maybe<Scalars['BigInt']>;
    units_not?: Maybe<Scalars['BigInt']>;
    units_gt?: Maybe<Scalars['BigInt']>;
    units_lt?: Maybe<Scalars['BigInt']>;
    units_gte?: Maybe<Scalars['BigInt']>;
    units_lte?: Maybe<Scalars['BigInt']>;
    units_in?: Maybe<Array<Scalars['BigInt']>>;
    units_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountReceivedUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountReceivedUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountReceivedUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountReceivedUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountReceivedUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountReceivedUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountReceivedUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountReceivedUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    indexValueUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    indexValueUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    indexValueUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    indexValueUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    indexValueUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    indexValueUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    indexValueUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    indexValueUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    index?: Maybe<Scalars['String']>;
    index_not?: Maybe<Scalars['String']>;
    index_gt?: Maybe<Scalars['String']>;
    index_lt?: Maybe<Scalars['String']>;
    index_gte?: Maybe<Scalars['String']>;
    index_lte?: Maybe<Scalars['String']>;
    index_in?: Maybe<Array<Scalars['String']>>;
    index_not_in?: Maybe<Array<Scalars['String']>>;
    index_contains?: Maybe<Scalars['String']>;
    index_contains_nocase?: Maybe<Scalars['String']>;
    index_not_contains?: Maybe<Scalars['String']>;
    index_not_contains_nocase?: Maybe<Scalars['String']>;
    index_starts_with?: Maybe<Scalars['String']>;
    index_starts_with_nocase?: Maybe<Scalars['String']>;
    index_not_starts_with?: Maybe<Scalars['String']>;
    index_not_starts_with_nocase?: Maybe<Scalars['String']>;
    index_ends_with?: Maybe<Scalars['String']>;
    index_ends_with_nocase?: Maybe<Scalars['String']>;
    index_not_ends_with?: Maybe<Scalars['String']>;
    index_not_ends_with_nocase?: Maybe<Scalars['String']>;
    index_?: Maybe<Index_Filter>;
    subscriptionApprovedEvents_?: Maybe<SubscriptionApprovedEvent_Filter>;
    subscriptionDistributionClaimedEvents_?: Maybe<SubscriptionDistributionClaimedEvent_Filter>;
    subscriptionRevokedEvents_?: Maybe<SubscriptionRevokedEvent_Filter>;
    subscriptionUnitsUpdatedEvents_?: Maybe<SubscriptionUnitsUpdatedEvent_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum IndexSubscription_OrderBy {
    Id = "id",
    CreatedAtTimestamp = "createdAtTimestamp",
    CreatedAtBlockNumber = "createdAtBlockNumber",
    UpdatedAtTimestamp = "updatedAtTimestamp",
    UpdatedAtBlockNumber = "updatedAtBlockNumber",
    Subscriber = "subscriber",
    Approved = "approved",
    Units = "units",
    TotalAmountReceivedUntilUpdatedAt = "totalAmountReceivedUntilUpdatedAt",
    IndexValueUntilUpdatedAt = "indexValueUntilUpdatedAt",
    Index = "index",
    SubscriptionApprovedEvents = "subscriptionApprovedEvents",
    SubscriptionDistributionClaimedEvents = "subscriptionDistributionClaimedEvents",
    SubscriptionRevokedEvents = "subscriptionRevokedEvents",
    SubscriptionUnitsUpdatedEvents = "subscriptionUnitsUpdatedEvents"
}
export declare type IndexUnitsUpdatedEvent = Event & {
    __typename?: 'IndexUnitsUpdatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token, publisher and subscriber addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    publisher: Scalars['Bytes'];
    indexId: Scalars['BigInt'];
    subscriber: Scalars['Bytes'];
    units: Scalars['BigInt'];
    userData: Scalars['Bytes'];
    oldUnits: Scalars['BigInt'];
    index: Index;
};
export declare type IndexUnitsUpdatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    subscriber?: Maybe<Scalars['Bytes']>;
    subscriber_not?: Maybe<Scalars['Bytes']>;
    subscriber_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_not_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_contains?: Maybe<Scalars['Bytes']>;
    subscriber_not_contains?: Maybe<Scalars['Bytes']>;
    units?: Maybe<Scalars['BigInt']>;
    units_not?: Maybe<Scalars['BigInt']>;
    units_gt?: Maybe<Scalars['BigInt']>;
    units_lt?: Maybe<Scalars['BigInt']>;
    units_gte?: Maybe<Scalars['BigInt']>;
    units_lte?: Maybe<Scalars['BigInt']>;
    units_in?: Maybe<Array<Scalars['BigInt']>>;
    units_not_in?: Maybe<Array<Scalars['BigInt']>>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    oldUnits?: Maybe<Scalars['BigInt']>;
    oldUnits_not?: Maybe<Scalars['BigInt']>;
    oldUnits_gt?: Maybe<Scalars['BigInt']>;
    oldUnits_lt?: Maybe<Scalars['BigInt']>;
    oldUnits_gte?: Maybe<Scalars['BigInt']>;
    oldUnits_lte?: Maybe<Scalars['BigInt']>;
    oldUnits_in?: Maybe<Array<Scalars['BigInt']>>;
    oldUnits_not_in?: Maybe<Array<Scalars['BigInt']>>;
    index?: Maybe<Scalars['String']>;
    index_not?: Maybe<Scalars['String']>;
    index_gt?: Maybe<Scalars['String']>;
    index_lt?: Maybe<Scalars['String']>;
    index_gte?: Maybe<Scalars['String']>;
    index_lte?: Maybe<Scalars['String']>;
    index_in?: Maybe<Array<Scalars['String']>>;
    index_not_in?: Maybe<Array<Scalars['String']>>;
    index_contains?: Maybe<Scalars['String']>;
    index_contains_nocase?: Maybe<Scalars['String']>;
    index_not_contains?: Maybe<Scalars['String']>;
    index_not_contains_nocase?: Maybe<Scalars['String']>;
    index_starts_with?: Maybe<Scalars['String']>;
    index_starts_with_nocase?: Maybe<Scalars['String']>;
    index_not_starts_with?: Maybe<Scalars['String']>;
    index_not_starts_with_nocase?: Maybe<Scalars['String']>;
    index_ends_with?: Maybe<Scalars['String']>;
    index_ends_with_nocase?: Maybe<Scalars['String']>;
    index_not_ends_with?: Maybe<Scalars['String']>;
    index_not_ends_with_nocase?: Maybe<Scalars['String']>;
    index_?: Maybe<Index_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum IndexUnitsUpdatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Publisher = "publisher",
    IndexId = "indexId",
    Subscriber = "subscriber",
    Units = "units",
    UserData = "userData",
    OldUnits = "oldUnits",
    Index = "index"
}
export declare type IndexUnsubscribedEvent = Event & {
    __typename?: 'IndexUnsubscribedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token, publisher and subscriber addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    publisher: Scalars['Bytes'];
    indexId: Scalars['BigInt'];
    subscriber: Scalars['Bytes'];
    userData: Scalars['Bytes'];
    index: Index;
};
export declare type IndexUnsubscribedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    subscriber?: Maybe<Scalars['Bytes']>;
    subscriber_not?: Maybe<Scalars['Bytes']>;
    subscriber_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_not_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_contains?: Maybe<Scalars['Bytes']>;
    subscriber_not_contains?: Maybe<Scalars['Bytes']>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    index?: Maybe<Scalars['String']>;
    index_not?: Maybe<Scalars['String']>;
    index_gt?: Maybe<Scalars['String']>;
    index_lt?: Maybe<Scalars['String']>;
    index_gte?: Maybe<Scalars['String']>;
    index_lte?: Maybe<Scalars['String']>;
    index_in?: Maybe<Array<Scalars['String']>>;
    index_not_in?: Maybe<Array<Scalars['String']>>;
    index_contains?: Maybe<Scalars['String']>;
    index_contains_nocase?: Maybe<Scalars['String']>;
    index_not_contains?: Maybe<Scalars['String']>;
    index_not_contains_nocase?: Maybe<Scalars['String']>;
    index_starts_with?: Maybe<Scalars['String']>;
    index_starts_with_nocase?: Maybe<Scalars['String']>;
    index_not_starts_with?: Maybe<Scalars['String']>;
    index_not_starts_with_nocase?: Maybe<Scalars['String']>;
    index_ends_with?: Maybe<Scalars['String']>;
    index_ends_with_nocase?: Maybe<Scalars['String']>;
    index_not_ends_with?: Maybe<Scalars['String']>;
    index_not_ends_with_nocase?: Maybe<Scalars['String']>;
    index_?: Maybe<Index_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum IndexUnsubscribedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Publisher = "publisher",
    IndexId = "indexId",
    Subscriber = "subscriber",
    UserData = "userData",
    Index = "index"
}
export declare type IndexUpdatedEvent = Event & {
    __typename?: 'IndexUpdatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token and publisher addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    publisher: Scalars['Bytes'];
    indexId: Scalars['BigInt'];
    oldIndexValue: Scalars['BigInt'];
    newIndexValue: Scalars['BigInt'];
    totalUnitsPending: Scalars['BigInt'];
    totalUnitsApproved: Scalars['BigInt'];
    userData: Scalars['Bytes'];
    index: Index;
};
export declare type IndexUpdatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    oldIndexValue?: Maybe<Scalars['BigInt']>;
    oldIndexValue_not?: Maybe<Scalars['BigInt']>;
    oldIndexValue_gt?: Maybe<Scalars['BigInt']>;
    oldIndexValue_lt?: Maybe<Scalars['BigInt']>;
    oldIndexValue_gte?: Maybe<Scalars['BigInt']>;
    oldIndexValue_lte?: Maybe<Scalars['BigInt']>;
    oldIndexValue_in?: Maybe<Array<Scalars['BigInt']>>;
    oldIndexValue_not_in?: Maybe<Array<Scalars['BigInt']>>;
    newIndexValue?: Maybe<Scalars['BigInt']>;
    newIndexValue_not?: Maybe<Scalars['BigInt']>;
    newIndexValue_gt?: Maybe<Scalars['BigInt']>;
    newIndexValue_lt?: Maybe<Scalars['BigInt']>;
    newIndexValue_gte?: Maybe<Scalars['BigInt']>;
    newIndexValue_lte?: Maybe<Scalars['BigInt']>;
    newIndexValue_in?: Maybe<Array<Scalars['BigInt']>>;
    newIndexValue_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnitsPending?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_not?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_gt?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_lt?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_gte?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_lte?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnitsPending_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnitsApproved?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_not?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_gt?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_lt?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_gte?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_lte?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnitsApproved_not_in?: Maybe<Array<Scalars['BigInt']>>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    index?: Maybe<Scalars['String']>;
    index_not?: Maybe<Scalars['String']>;
    index_gt?: Maybe<Scalars['String']>;
    index_lt?: Maybe<Scalars['String']>;
    index_gte?: Maybe<Scalars['String']>;
    index_lte?: Maybe<Scalars['String']>;
    index_in?: Maybe<Array<Scalars['String']>>;
    index_not_in?: Maybe<Array<Scalars['String']>>;
    index_contains?: Maybe<Scalars['String']>;
    index_contains_nocase?: Maybe<Scalars['String']>;
    index_not_contains?: Maybe<Scalars['String']>;
    index_not_contains_nocase?: Maybe<Scalars['String']>;
    index_starts_with?: Maybe<Scalars['String']>;
    index_starts_with_nocase?: Maybe<Scalars['String']>;
    index_not_starts_with?: Maybe<Scalars['String']>;
    index_not_starts_with_nocase?: Maybe<Scalars['String']>;
    index_ends_with?: Maybe<Scalars['String']>;
    index_ends_with_nocase?: Maybe<Scalars['String']>;
    index_not_ends_with?: Maybe<Scalars['String']>;
    index_not_ends_with_nocase?: Maybe<Scalars['String']>;
    index_?: Maybe<Index_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum IndexUpdatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Publisher = "publisher",
    IndexId = "indexId",
    OldIndexValue = "oldIndexValue",
    NewIndexValue = "newIndexValue",
    TotalUnitsPending = "totalUnitsPending",
    TotalUnitsApproved = "totalUnitsApproved",
    UserData = "userData",
    Index = "index"
}
export declare type Index_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    createdAtTimestamp?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    indexValue?: Maybe<Scalars['BigInt']>;
    indexValue_not?: Maybe<Scalars['BigInt']>;
    indexValue_gt?: Maybe<Scalars['BigInt']>;
    indexValue_lt?: Maybe<Scalars['BigInt']>;
    indexValue_gte?: Maybe<Scalars['BigInt']>;
    indexValue_lte?: Maybe<Scalars['BigInt']>;
    indexValue_in?: Maybe<Array<Scalars['BigInt']>>;
    indexValue_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalSubscriptionsWithUnits?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_not?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits_not_in?: Maybe<Array<Scalars['Int']>>;
    totalUnitsPending?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_not?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_gt?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_lt?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_gte?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_lte?: Maybe<Scalars['BigInt']>;
    totalUnitsPending_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnitsPending_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnitsApproved?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_not?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_gt?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_lt?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_gte?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_lte?: Maybe<Scalars['BigInt']>;
    totalUnitsApproved_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnitsApproved_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnits?: Maybe<Scalars['BigInt']>;
    totalUnits_not?: Maybe<Scalars['BigInt']>;
    totalUnits_gt?: Maybe<Scalars['BigInt']>;
    totalUnits_lt?: Maybe<Scalars['BigInt']>;
    totalUnits_gte?: Maybe<Scalars['BigInt']>;
    totalUnits_lte?: Maybe<Scalars['BigInt']>;
    totalUnits_in?: Maybe<Array<Scalars['BigInt']>>;
    totalUnits_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountDistributedUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountDistributedUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['String']>;
    token_not?: Maybe<Scalars['String']>;
    token_gt?: Maybe<Scalars['String']>;
    token_lt?: Maybe<Scalars['String']>;
    token_gte?: Maybe<Scalars['String']>;
    token_lte?: Maybe<Scalars['String']>;
    token_in?: Maybe<Array<Scalars['String']>>;
    token_not_in?: Maybe<Array<Scalars['String']>>;
    token_contains?: Maybe<Scalars['String']>;
    token_contains_nocase?: Maybe<Scalars['String']>;
    token_not_contains?: Maybe<Scalars['String']>;
    token_not_contains_nocase?: Maybe<Scalars['String']>;
    token_starts_with?: Maybe<Scalars['String']>;
    token_starts_with_nocase?: Maybe<Scalars['String']>;
    token_not_starts_with?: Maybe<Scalars['String']>;
    token_not_starts_with_nocase?: Maybe<Scalars['String']>;
    token_ends_with?: Maybe<Scalars['String']>;
    token_ends_with_nocase?: Maybe<Scalars['String']>;
    token_not_ends_with?: Maybe<Scalars['String']>;
    token_not_ends_with_nocase?: Maybe<Scalars['String']>;
    token_?: Maybe<Token_Filter>;
    publisher?: Maybe<Scalars['String']>;
    publisher_not?: Maybe<Scalars['String']>;
    publisher_gt?: Maybe<Scalars['String']>;
    publisher_lt?: Maybe<Scalars['String']>;
    publisher_gte?: Maybe<Scalars['String']>;
    publisher_lte?: Maybe<Scalars['String']>;
    publisher_in?: Maybe<Array<Scalars['String']>>;
    publisher_not_in?: Maybe<Array<Scalars['String']>>;
    publisher_contains?: Maybe<Scalars['String']>;
    publisher_contains_nocase?: Maybe<Scalars['String']>;
    publisher_not_contains?: Maybe<Scalars['String']>;
    publisher_not_contains_nocase?: Maybe<Scalars['String']>;
    publisher_starts_with?: Maybe<Scalars['String']>;
    publisher_starts_with_nocase?: Maybe<Scalars['String']>;
    publisher_not_starts_with?: Maybe<Scalars['String']>;
    publisher_not_starts_with_nocase?: Maybe<Scalars['String']>;
    publisher_ends_with?: Maybe<Scalars['String']>;
    publisher_ends_with_nocase?: Maybe<Scalars['String']>;
    publisher_not_ends_with?: Maybe<Scalars['String']>;
    publisher_not_ends_with_nocase?: Maybe<Scalars['String']>;
    publisher_?: Maybe<Account_Filter>;
    subscriptions_?: Maybe<IndexSubscription_Filter>;
    indexCreatedEvent?: Maybe<Scalars['String']>;
    indexCreatedEvent_not?: Maybe<Scalars['String']>;
    indexCreatedEvent_gt?: Maybe<Scalars['String']>;
    indexCreatedEvent_lt?: Maybe<Scalars['String']>;
    indexCreatedEvent_gte?: Maybe<Scalars['String']>;
    indexCreatedEvent_lte?: Maybe<Scalars['String']>;
    indexCreatedEvent_in?: Maybe<Array<Scalars['String']>>;
    indexCreatedEvent_not_in?: Maybe<Array<Scalars['String']>>;
    indexCreatedEvent_contains?: Maybe<Scalars['String']>;
    indexCreatedEvent_contains_nocase?: Maybe<Scalars['String']>;
    indexCreatedEvent_not_contains?: Maybe<Scalars['String']>;
    indexCreatedEvent_not_contains_nocase?: Maybe<Scalars['String']>;
    indexCreatedEvent_starts_with?: Maybe<Scalars['String']>;
    indexCreatedEvent_starts_with_nocase?: Maybe<Scalars['String']>;
    indexCreatedEvent_not_starts_with?: Maybe<Scalars['String']>;
    indexCreatedEvent_not_starts_with_nocase?: Maybe<Scalars['String']>;
    indexCreatedEvent_ends_with?: Maybe<Scalars['String']>;
    indexCreatedEvent_ends_with_nocase?: Maybe<Scalars['String']>;
    indexCreatedEvent_not_ends_with?: Maybe<Scalars['String']>;
    indexCreatedEvent_not_ends_with_nocase?: Maybe<Scalars['String']>;
    indexCreatedEvent_?: Maybe<IndexCreatedEvent_Filter>;
    indexDistributionClaimedEvents_?: Maybe<IndexDistributionClaimedEvent_Filter>;
    indexUpdatedEvents_?: Maybe<IndexUpdatedEvent_Filter>;
    indexSubscribedEvents_?: Maybe<IndexSubscribedEvent_Filter>;
    indexUnitsUpdatedEvents_?: Maybe<IndexUnitsUpdatedEvent_Filter>;
    indexUnsubscribedEvents_?: Maybe<IndexUnsubscribedEvent_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum Index_OrderBy {
    Id = "id",
    CreatedAtTimestamp = "createdAtTimestamp",
    CreatedAtBlockNumber = "createdAtBlockNumber",
    UpdatedAtTimestamp = "updatedAtTimestamp",
    UpdatedAtBlockNumber = "updatedAtBlockNumber",
    IndexId = "indexId",
    IndexValue = "indexValue",
    TotalSubscriptionsWithUnits = "totalSubscriptionsWithUnits",
    TotalUnitsPending = "totalUnitsPending",
    TotalUnitsApproved = "totalUnitsApproved",
    TotalUnits = "totalUnits",
    TotalAmountDistributedUntilUpdatedAt = "totalAmountDistributedUntilUpdatedAt",
    Token = "token",
    Publisher = "publisher",
    Subscriptions = "subscriptions",
    IndexCreatedEvent = "indexCreatedEvent",
    IndexDistributionClaimedEvents = "indexDistributionClaimedEvents",
    IndexUpdatedEvents = "indexUpdatedEvents",
    IndexSubscribedEvents = "indexSubscribedEvents",
    IndexUnitsUpdatedEvents = "indexUnitsUpdatedEvents",
    IndexUnsubscribedEvents = "indexUnsubscribedEvents"
}
export declare type JailEvent = Event & {
    __typename?: 'JailEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    app: Scalars['Bytes'];
    reason: Scalars['BigInt'];
};
export declare type JailEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    app?: Maybe<Scalars['Bytes']>;
    app_not?: Maybe<Scalars['Bytes']>;
    app_in?: Maybe<Array<Scalars['Bytes']>>;
    app_not_in?: Maybe<Array<Scalars['Bytes']>>;
    app_contains?: Maybe<Scalars['Bytes']>;
    app_not_contains?: Maybe<Scalars['Bytes']>;
    reason?: Maybe<Scalars['BigInt']>;
    reason_not?: Maybe<Scalars['BigInt']>;
    reason_gt?: Maybe<Scalars['BigInt']>;
    reason_lt?: Maybe<Scalars['BigInt']>;
    reason_gte?: Maybe<Scalars['BigInt']>;
    reason_lte?: Maybe<Scalars['BigInt']>;
    reason_in?: Maybe<Array<Scalars['BigInt']>>;
    reason_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum JailEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    App = "app",
    Reason = "reason"
}
export declare type MintedEvent = Event & {
    __typename?: 'MintedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token, operator and to addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    operator: Scalars['Bytes'];
    to: Scalars['Bytes'];
    amount: Scalars['BigInt'];
    data: Scalars['Bytes'];
    token: Scalars['Bytes'];
    operatorData: Scalars['Bytes'];
};
export declare type MintedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    operator?: Maybe<Scalars['Bytes']>;
    operator_not?: Maybe<Scalars['Bytes']>;
    operator_in?: Maybe<Array<Scalars['Bytes']>>;
    operator_not_in?: Maybe<Array<Scalars['Bytes']>>;
    operator_contains?: Maybe<Scalars['Bytes']>;
    operator_not_contains?: Maybe<Scalars['Bytes']>;
    to?: Maybe<Scalars['Bytes']>;
    to_not?: Maybe<Scalars['Bytes']>;
    to_in?: Maybe<Array<Scalars['Bytes']>>;
    to_not_in?: Maybe<Array<Scalars['Bytes']>>;
    to_contains?: Maybe<Scalars['Bytes']>;
    to_not_contains?: Maybe<Scalars['Bytes']>;
    amount?: Maybe<Scalars['BigInt']>;
    amount_not?: Maybe<Scalars['BigInt']>;
    amount_gt?: Maybe<Scalars['BigInt']>;
    amount_lt?: Maybe<Scalars['BigInt']>;
    amount_gte?: Maybe<Scalars['BigInt']>;
    amount_lte?: Maybe<Scalars['BigInt']>;
    amount_in?: Maybe<Array<Scalars['BigInt']>>;
    amount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    data?: Maybe<Scalars['Bytes']>;
    data_not?: Maybe<Scalars['Bytes']>;
    data_in?: Maybe<Array<Scalars['Bytes']>>;
    data_not_in?: Maybe<Array<Scalars['Bytes']>>;
    data_contains?: Maybe<Scalars['Bytes']>;
    data_not_contains?: Maybe<Scalars['Bytes']>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    operatorData?: Maybe<Scalars['Bytes']>;
    operatorData_not?: Maybe<Scalars['Bytes']>;
    operatorData_in?: Maybe<Array<Scalars['Bytes']>>;
    operatorData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    operatorData_contains?: Maybe<Scalars['Bytes']>;
    operatorData_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum MintedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Operator = "operator",
    To = "to",
    Amount = "amount",
    Data = "data",
    Token = "token",
    OperatorData = "operatorData"
}
/** Defines the order direction, either ascending or descending */
export declare enum OrderDirection {
    Asc = "asc",
    Desc = "desc"
}
export declare type PppConfigurationChangedEvent = Event & {
    __typename?: 'PPPConfigurationChangedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** The address of the governance contract the event was emitted from. */
    governanceAddress: Scalars['Bytes'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    host: Scalars['Bytes'];
    superToken: Scalars['Bytes'];
    isKeySet: Scalars['Boolean'];
    liquidationPeriod: Scalars['BigInt'];
    patricianPeriod: Scalars['BigInt'];
};
export declare type PppConfigurationChangedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    governanceAddress?: Maybe<Scalars['Bytes']>;
    governanceAddress_not?: Maybe<Scalars['Bytes']>;
    governanceAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_contains?: Maybe<Scalars['Bytes']>;
    governanceAddress_not_contains?: Maybe<Scalars['Bytes']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    host?: Maybe<Scalars['Bytes']>;
    host_not?: Maybe<Scalars['Bytes']>;
    host_in?: Maybe<Array<Scalars['Bytes']>>;
    host_not_in?: Maybe<Array<Scalars['Bytes']>>;
    host_contains?: Maybe<Scalars['Bytes']>;
    host_not_contains?: Maybe<Scalars['Bytes']>;
    superToken?: Maybe<Scalars['Bytes']>;
    superToken_not?: Maybe<Scalars['Bytes']>;
    superToken_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_not_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_contains?: Maybe<Scalars['Bytes']>;
    superToken_not_contains?: Maybe<Scalars['Bytes']>;
    isKeySet?: Maybe<Scalars['Boolean']>;
    isKeySet_not?: Maybe<Scalars['Boolean']>;
    isKeySet_in?: Maybe<Array<Scalars['Boolean']>>;
    isKeySet_not_in?: Maybe<Array<Scalars['Boolean']>>;
    liquidationPeriod?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_not?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_gt?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_lt?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_gte?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_lte?: Maybe<Scalars['BigInt']>;
    liquidationPeriod_in?: Maybe<Array<Scalars['BigInt']>>;
    liquidationPeriod_not_in?: Maybe<Array<Scalars['BigInt']>>;
    patricianPeriod?: Maybe<Scalars['BigInt']>;
    patricianPeriod_not?: Maybe<Scalars['BigInt']>;
    patricianPeriod_gt?: Maybe<Scalars['BigInt']>;
    patricianPeriod_lt?: Maybe<Scalars['BigInt']>;
    patricianPeriod_gte?: Maybe<Scalars['BigInt']>;
    patricianPeriod_lte?: Maybe<Scalars['BigInt']>;
    patricianPeriod_in?: Maybe<Array<Scalars['BigInt']>>;
    patricianPeriod_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum PppConfigurationChangedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    GovernanceAddress = "governanceAddress",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Host = "host",
    SuperToken = "superToken",
    IsKeySet = "isKeySet",
    LiquidationPeriod = "liquidationPeriod",
    PatricianPeriod = "patricianPeriod"
}
export declare type Query = {
    __typename?: 'Query';
    flowUpdatedEvent?: Maybe<FlowUpdatedEvent>;
    flowUpdatedEvents: Array<FlowUpdatedEvent>;
    flowOperatorUpdatedEvent?: Maybe<FlowOperatorUpdatedEvent>;
    flowOperatorUpdatedEvents: Array<FlowOperatorUpdatedEvent>;
    indexCreatedEvent?: Maybe<IndexCreatedEvent>;
    indexCreatedEvents: Array<IndexCreatedEvent>;
    indexDistributionClaimedEvent?: Maybe<IndexDistributionClaimedEvent>;
    indexDistributionClaimedEvents: Array<IndexDistributionClaimedEvent>;
    indexUpdatedEvent?: Maybe<IndexUpdatedEvent>;
    indexUpdatedEvents: Array<IndexUpdatedEvent>;
    indexSubscribedEvent?: Maybe<IndexSubscribedEvent>;
    indexSubscribedEvents: Array<IndexSubscribedEvent>;
    indexUnitsUpdatedEvent?: Maybe<IndexUnitsUpdatedEvent>;
    indexUnitsUpdatedEvents: Array<IndexUnitsUpdatedEvent>;
    indexUnsubscribedEvent?: Maybe<IndexUnsubscribedEvent>;
    indexUnsubscribedEvents: Array<IndexUnsubscribedEvent>;
    subscriptionApprovedEvent?: Maybe<SubscriptionApprovedEvent>;
    subscriptionApprovedEvents: Array<SubscriptionApprovedEvent>;
    subscriptionDistributionClaimedEvent?: Maybe<SubscriptionDistributionClaimedEvent>;
    subscriptionDistributionClaimedEvents: Array<SubscriptionDistributionClaimedEvent>;
    subscriptionRevokedEvent?: Maybe<SubscriptionRevokedEvent>;
    subscriptionRevokedEvents: Array<SubscriptionRevokedEvent>;
    subscriptionUnitsUpdatedEvent?: Maybe<SubscriptionUnitsUpdatedEvent>;
    subscriptionUnitsUpdatedEvents: Array<SubscriptionUnitsUpdatedEvent>;
    agreementClassRegisteredEvent?: Maybe<AgreementClassRegisteredEvent>;
    agreementClassRegisteredEvents: Array<AgreementClassRegisteredEvent>;
    agreementClassUpdatedEvent?: Maybe<AgreementClassUpdatedEvent>;
    agreementClassUpdatedEvents: Array<AgreementClassUpdatedEvent>;
    appRegisteredEvent?: Maybe<AppRegisteredEvent>;
    appRegisteredEvents: Array<AppRegisteredEvent>;
    governanceReplacedEvent?: Maybe<GovernanceReplacedEvent>;
    governanceReplacedEvents: Array<GovernanceReplacedEvent>;
    jailEvent?: Maybe<JailEvent>;
    jailEvents: Array<JailEvent>;
    superTokenFactoryUpdatedEvent?: Maybe<SuperTokenFactoryUpdatedEvent>;
    superTokenFactoryUpdatedEvents: Array<SuperTokenFactoryUpdatedEvent>;
    superTokenLogicUpdatedEvent?: Maybe<SuperTokenLogicUpdatedEvent>;
    superTokenLogicUpdatedEvents: Array<SuperTokenLogicUpdatedEvent>;
    roleAdminChangedEvent?: Maybe<RoleAdminChangedEvent>;
    roleAdminChangedEvents: Array<RoleAdminChangedEvent>;
    roleGrantedEvent?: Maybe<RoleGrantedEvent>;
    roleGrantedEvents: Array<RoleGrantedEvent>;
    roleRevokedEvent?: Maybe<RoleRevokedEvent>;
    roleRevokedEvents: Array<RoleRevokedEvent>;
    setEvent?: Maybe<SetEvent>;
    setEvents: Array<SetEvent>;
    cfav1LiquidationPeriodChangedEvent?: Maybe<CfAv1LiquidationPeriodChangedEvent>;
    cfav1LiquidationPeriodChangedEvents: Array<CfAv1LiquidationPeriodChangedEvent>;
    configChangedEvent?: Maybe<ConfigChangedEvent>;
    configChangedEvents: Array<ConfigChangedEvent>;
    rewardAddressChangedEvent?: Maybe<RewardAddressChangedEvent>;
    rewardAddressChangedEvents: Array<RewardAddressChangedEvent>;
    pppconfigurationChangedEvent?: Maybe<PppConfigurationChangedEvent>;
    pppconfigurationChangedEvents: Array<PppConfigurationChangedEvent>;
    trustedForwarderChangedEvent?: Maybe<TrustedForwarderChangedEvent>;
    trustedForwarderChangedEvents: Array<TrustedForwarderChangedEvent>;
    agreementLiquidatedByEvent?: Maybe<AgreementLiquidatedByEvent>;
    agreementLiquidatedByEvents: Array<AgreementLiquidatedByEvent>;
    agreementLiquidatedV2Event?: Maybe<AgreementLiquidatedV2Event>;
    agreementLiquidatedV2Events: Array<AgreementLiquidatedV2Event>;
    burnedEvent?: Maybe<BurnedEvent>;
    burnedEvents: Array<BurnedEvent>;
    mintedEvent?: Maybe<MintedEvent>;
    mintedEvents: Array<MintedEvent>;
    sentEvent?: Maybe<SentEvent>;
    sentEvents: Array<SentEvent>;
    transferEvent?: Maybe<TransferEvent>;
    transferEvents: Array<TransferEvent>;
    tokenDowngradedEvent?: Maybe<TokenDowngradedEvent>;
    tokenDowngradedEvents: Array<TokenDowngradedEvent>;
    tokenUpgradedEvent?: Maybe<TokenUpgradedEvent>;
    tokenUpgradedEvents: Array<TokenUpgradedEvent>;
    customSuperTokenCreatedEvent?: Maybe<CustomSuperTokenCreatedEvent>;
    customSuperTokenCreatedEvents: Array<CustomSuperTokenCreatedEvent>;
    superTokenCreatedEvent?: Maybe<SuperTokenCreatedEvent>;
    superTokenCreatedEvents: Array<SuperTokenCreatedEvent>;
    superTokenLogicCreatedEvent?: Maybe<SuperTokenLogicCreatedEvent>;
    superTokenLogicCreatedEvents: Array<SuperTokenLogicCreatedEvent>;
    account?: Maybe<Account>;
    accounts: Array<Account>;
    index?: Maybe<Index>;
    indexes: Array<Index>;
    indexSubscription?: Maybe<IndexSubscription>;
    indexSubscriptions: Array<IndexSubscription>;
    stream?: Maybe<Stream>;
    streams: Array<Stream>;
    flowOperator?: Maybe<FlowOperator>;
    flowOperators: Array<FlowOperator>;
    streamPeriod?: Maybe<StreamPeriod>;
    streamPeriods: Array<StreamPeriod>;
    streamRevision?: Maybe<StreamRevision>;
    streamRevisions: Array<StreamRevision>;
    token?: Maybe<Token>;
    tokens: Array<Token>;
    resolverEntry?: Maybe<ResolverEntry>;
    resolverEntries: Array<ResolverEntry>;
    accountTokenSnapshot?: Maybe<AccountTokenSnapshot>;
    accountTokenSnapshots: Array<AccountTokenSnapshot>;
    accountTokenSnapshotLog?: Maybe<AccountTokenSnapshotLog>;
    accountTokenSnapshotLogs: Array<AccountTokenSnapshotLog>;
    tokenStatistic?: Maybe<TokenStatistic>;
    tokenStatistics: Array<TokenStatistic>;
    tokenStatisticLog?: Maybe<TokenStatisticLog>;
    tokenStatisticLogs: Array<TokenStatisticLog>;
    sfmeta?: Maybe<SfMeta>;
    sfmetas: Array<SfMeta>;
    event?: Maybe<Event>;
    events: Array<Event>;
    /** Access to subgraph metadata */
    _meta?: Maybe<_Meta_>;
};
export declare type QueryFlowUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryFlowUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryFlowOperatorUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryFlowOperatorUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowOperatorUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowOperatorUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryIndexCreatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryIndexCreatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexCreatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexCreatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryIndexDistributionClaimedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryIndexDistributionClaimedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexDistributionClaimedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexDistributionClaimedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryIndexUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryIndexUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryIndexSubscribedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryIndexSubscribedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexSubscribedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexSubscribedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryIndexUnitsUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryIndexUnitsUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUnitsUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUnitsUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryIndexUnsubscribedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryIndexUnsubscribedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUnsubscribedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUnsubscribedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySubscriptionApprovedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySubscriptionApprovedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionApprovedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionApprovedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySubscriptionDistributionClaimedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySubscriptionDistributionClaimedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionDistributionClaimedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionDistributionClaimedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySubscriptionRevokedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySubscriptionRevokedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionRevokedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionRevokedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySubscriptionUnitsUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySubscriptionUnitsUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionUnitsUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionUnitsUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAgreementClassRegisteredEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAgreementClassRegisteredEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AgreementClassRegisteredEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AgreementClassRegisteredEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAgreementClassUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAgreementClassUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AgreementClassUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AgreementClassUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAppRegisteredEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAppRegisteredEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AppRegisteredEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AppRegisteredEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryGovernanceReplacedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryGovernanceReplacedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<GovernanceReplacedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<GovernanceReplacedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryJailEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryJailEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<JailEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<JailEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySuperTokenFactoryUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySuperTokenFactoryUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenFactoryUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenFactoryUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySuperTokenLogicUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySuperTokenLogicUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenLogicUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenLogicUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryRoleAdminChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryRoleAdminChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RoleAdminChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RoleAdminChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryRoleGrantedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryRoleGrantedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RoleGrantedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RoleGrantedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryRoleRevokedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryRoleRevokedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RoleRevokedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RoleRevokedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySetEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySetEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SetEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SetEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryCfav1LiquidationPeriodChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryCfav1LiquidationPeriodChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<CfAv1LiquidationPeriodChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<CfAv1LiquidationPeriodChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryConfigChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryConfigChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<ConfigChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<ConfigChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryRewardAddressChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryRewardAddressChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RewardAddressChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RewardAddressChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryPppconfigurationChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryPppconfigurationChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<PppConfigurationChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<PppConfigurationChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTrustedForwarderChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTrustedForwarderChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TrustedForwarderChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TrustedForwarderChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAgreementLiquidatedByEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAgreementLiquidatedByEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AgreementLiquidatedByEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AgreementLiquidatedByEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAgreementLiquidatedV2EventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAgreementLiquidatedV2EventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AgreementLiquidatedV2Event_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AgreementLiquidatedV2Event_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryBurnedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryBurnedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<BurnedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<BurnedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryMintedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryMintedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<MintedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<MintedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySentEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySentEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SentEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SentEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTransferEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTransferEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TransferEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TransferEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTokenDowngradedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTokenDowngradedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenDowngradedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenDowngradedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTokenUpgradedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTokenUpgradedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenUpgradedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenUpgradedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryCustomSuperTokenCreatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryCustomSuperTokenCreatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<CustomSuperTokenCreatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<CustomSuperTokenCreatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySuperTokenCreatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySuperTokenCreatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenCreatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenCreatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySuperTokenLogicCreatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySuperTokenLogicCreatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenLogicCreatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenLogicCreatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAccountArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAccountsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Account_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Account_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryIndexArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryIndexesArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Index_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Index_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryIndexSubscriptionArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryIndexSubscriptionsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexSubscription_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexSubscription_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryStreamArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryStreamsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Stream_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Stream_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryFlowOperatorArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryFlowOperatorsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowOperator_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowOperator_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryStreamPeriodArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryStreamPeriodsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<StreamPeriod_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<StreamPeriod_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryStreamRevisionArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryStreamRevisionsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<StreamRevision_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<StreamRevision_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTokenArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTokensArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Token_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Token_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryResolverEntryArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryResolverEntriesArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<ResolverEntry_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<ResolverEntry_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAccountTokenSnapshotArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAccountTokenSnapshotsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AccountTokenSnapshot_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AccountTokenSnapshot_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAccountTokenSnapshotLogArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAccountTokenSnapshotLogsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AccountTokenSnapshotLog_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AccountTokenSnapshotLog_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTokenStatisticArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTokenStatisticsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenStatistic_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenStatistic_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTokenStatisticLogArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTokenStatisticLogsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenStatisticLog_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenStatisticLog_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySfmetaArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QuerySfmetasArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SfMeta_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SfMeta_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Event_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Event_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type Query_MetaArgs = {
    block?: Maybe<Block_Height>;
};
export declare type ResolverEntry = {
    __typename?: 'ResolverEntry';
    /** ID: the keccak256 hash of the set name */
    id: Scalars['ID'];
    createdAtTimestamp: Scalars['BigInt'];
    createdAtBlockNumber: Scalars['BigInt'];
    updatedAtTimestamp: Scalars['BigInt'];
    updatedAtBlockNumber: Scalars['BigInt'];
    targetAddress: Scalars['Bytes'];
    isToken: Scalars['Boolean'];
    isListed: Scalars['Boolean'];
    setEvents: Array<SetEvent>;
};
export declare type ResolverEntrySetEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SetEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SetEvent_Filter>;
};
export declare type ResolverEntry_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    createdAtTimestamp?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    targetAddress?: Maybe<Scalars['Bytes']>;
    targetAddress_not?: Maybe<Scalars['Bytes']>;
    targetAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    targetAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    targetAddress_contains?: Maybe<Scalars['Bytes']>;
    targetAddress_not_contains?: Maybe<Scalars['Bytes']>;
    isToken?: Maybe<Scalars['Boolean']>;
    isToken_not?: Maybe<Scalars['Boolean']>;
    isToken_in?: Maybe<Array<Scalars['Boolean']>>;
    isToken_not_in?: Maybe<Array<Scalars['Boolean']>>;
    isListed?: Maybe<Scalars['Boolean']>;
    isListed_not?: Maybe<Scalars['Boolean']>;
    isListed_in?: Maybe<Array<Scalars['Boolean']>>;
    isListed_not_in?: Maybe<Array<Scalars['Boolean']>>;
    setEvents_?: Maybe<SetEvent_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum ResolverEntry_OrderBy {
    Id = "id",
    CreatedAtTimestamp = "createdAtTimestamp",
    CreatedAtBlockNumber = "createdAtBlockNumber",
    UpdatedAtTimestamp = "updatedAtTimestamp",
    UpdatedAtBlockNumber = "updatedAtBlockNumber",
    TargetAddress = "targetAddress",
    IsToken = "isToken",
    IsListed = "isListed",
    SetEvents = "setEvents"
}
export declare type RewardAddressChangedEvent = Event & {
    __typename?: 'RewardAddressChangedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** The address of the governance contract the event was emitted from. */
    governanceAddress: Scalars['Bytes'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    host: Scalars['Bytes'];
    superToken: Scalars['Bytes'];
    isKeySet: Scalars['Boolean'];
    rewardAddress: Scalars['Bytes'];
};
export declare type RewardAddressChangedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    governanceAddress?: Maybe<Scalars['Bytes']>;
    governanceAddress_not?: Maybe<Scalars['Bytes']>;
    governanceAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_contains?: Maybe<Scalars['Bytes']>;
    governanceAddress_not_contains?: Maybe<Scalars['Bytes']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    host?: Maybe<Scalars['Bytes']>;
    host_not?: Maybe<Scalars['Bytes']>;
    host_in?: Maybe<Array<Scalars['Bytes']>>;
    host_not_in?: Maybe<Array<Scalars['Bytes']>>;
    host_contains?: Maybe<Scalars['Bytes']>;
    host_not_contains?: Maybe<Scalars['Bytes']>;
    superToken?: Maybe<Scalars['Bytes']>;
    superToken_not?: Maybe<Scalars['Bytes']>;
    superToken_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_not_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_contains?: Maybe<Scalars['Bytes']>;
    superToken_not_contains?: Maybe<Scalars['Bytes']>;
    isKeySet?: Maybe<Scalars['Boolean']>;
    isKeySet_not?: Maybe<Scalars['Boolean']>;
    isKeySet_in?: Maybe<Array<Scalars['Boolean']>>;
    isKeySet_not_in?: Maybe<Array<Scalars['Boolean']>>;
    rewardAddress?: Maybe<Scalars['Bytes']>;
    rewardAddress_not?: Maybe<Scalars['Bytes']>;
    rewardAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    rewardAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    rewardAddress_contains?: Maybe<Scalars['Bytes']>;
    rewardAddress_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum RewardAddressChangedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    GovernanceAddress = "governanceAddress",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Host = "host",
    SuperToken = "superToken",
    IsKeySet = "isKeySet",
    RewardAddress = "rewardAddress"
}
export declare type RoleAdminChangedEvent = Event & {
    __typename?: 'RoleAdminChangedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    role: Scalars['Bytes'];
    previousAdminRole: Scalars['Bytes'];
    newAdminRole: Scalars['Bytes'];
};
export declare type RoleAdminChangedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    role?: Maybe<Scalars['Bytes']>;
    role_not?: Maybe<Scalars['Bytes']>;
    role_in?: Maybe<Array<Scalars['Bytes']>>;
    role_not_in?: Maybe<Array<Scalars['Bytes']>>;
    role_contains?: Maybe<Scalars['Bytes']>;
    role_not_contains?: Maybe<Scalars['Bytes']>;
    previousAdminRole?: Maybe<Scalars['Bytes']>;
    previousAdminRole_not?: Maybe<Scalars['Bytes']>;
    previousAdminRole_in?: Maybe<Array<Scalars['Bytes']>>;
    previousAdminRole_not_in?: Maybe<Array<Scalars['Bytes']>>;
    previousAdminRole_contains?: Maybe<Scalars['Bytes']>;
    previousAdminRole_not_contains?: Maybe<Scalars['Bytes']>;
    newAdminRole?: Maybe<Scalars['Bytes']>;
    newAdminRole_not?: Maybe<Scalars['Bytes']>;
    newAdminRole_in?: Maybe<Array<Scalars['Bytes']>>;
    newAdminRole_not_in?: Maybe<Array<Scalars['Bytes']>>;
    newAdminRole_contains?: Maybe<Scalars['Bytes']>;
    newAdminRole_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum RoleAdminChangedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Role = "role",
    PreviousAdminRole = "previousAdminRole",
    NewAdminRole = "newAdminRole"
}
export declare type RoleGrantedEvent = Event & {
    __typename?: 'RoleGrantedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    role: Scalars['Bytes'];
    account: Scalars['Bytes'];
    sender: Scalars['Bytes'];
};
export declare type RoleGrantedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    role?: Maybe<Scalars['Bytes']>;
    role_not?: Maybe<Scalars['Bytes']>;
    role_in?: Maybe<Array<Scalars['Bytes']>>;
    role_not_in?: Maybe<Array<Scalars['Bytes']>>;
    role_contains?: Maybe<Scalars['Bytes']>;
    role_not_contains?: Maybe<Scalars['Bytes']>;
    account?: Maybe<Scalars['Bytes']>;
    account_not?: Maybe<Scalars['Bytes']>;
    account_in?: Maybe<Array<Scalars['Bytes']>>;
    account_not_in?: Maybe<Array<Scalars['Bytes']>>;
    account_contains?: Maybe<Scalars['Bytes']>;
    account_not_contains?: Maybe<Scalars['Bytes']>;
    sender?: Maybe<Scalars['Bytes']>;
    sender_not?: Maybe<Scalars['Bytes']>;
    sender_in?: Maybe<Array<Scalars['Bytes']>>;
    sender_not_in?: Maybe<Array<Scalars['Bytes']>>;
    sender_contains?: Maybe<Scalars['Bytes']>;
    sender_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum RoleGrantedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Role = "role",
    Account = "account",
    Sender = "sender"
}
export declare type RoleRevokedEvent = Event & {
    __typename?: 'RoleRevokedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    role: Scalars['Bytes'];
    account: Scalars['Bytes'];
    sender: Scalars['Bytes'];
};
export declare type RoleRevokedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    role?: Maybe<Scalars['Bytes']>;
    role_not?: Maybe<Scalars['Bytes']>;
    role_in?: Maybe<Array<Scalars['Bytes']>>;
    role_not_in?: Maybe<Array<Scalars['Bytes']>>;
    role_contains?: Maybe<Scalars['Bytes']>;
    role_not_contains?: Maybe<Scalars['Bytes']>;
    account?: Maybe<Scalars['Bytes']>;
    account_not?: Maybe<Scalars['Bytes']>;
    account_in?: Maybe<Array<Scalars['Bytes']>>;
    account_not_in?: Maybe<Array<Scalars['Bytes']>>;
    account_contains?: Maybe<Scalars['Bytes']>;
    account_not_contains?: Maybe<Scalars['Bytes']>;
    sender?: Maybe<Scalars['Bytes']>;
    sender_not?: Maybe<Scalars['Bytes']>;
    sender_in?: Maybe<Array<Scalars['Bytes']>>;
    sender_not_in?: Maybe<Array<Scalars['Bytes']>>;
    sender_contains?: Maybe<Scalars['Bytes']>;
    sender_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum RoleRevokedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Role = "role",
    Account = "account",
    Sender = "sender"
}
export declare type SfMeta = {
    __typename?: 'SFMeta';
    /** The id is the commit hash. */
    id: Scalars['ID'];
    timestamp: Scalars['BigInt'];
    blockNumber: Scalars['BigInt'];
    /** Whether the branch is feature/dev/v1. */
    configuration: Scalars['String'];
    /** The branch the current deployment is coming from. */
    branch: Scalars['String'];
};
export declare type SfMeta_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    configuration?: Maybe<Scalars['String']>;
    configuration_not?: Maybe<Scalars['String']>;
    configuration_gt?: Maybe<Scalars['String']>;
    configuration_lt?: Maybe<Scalars['String']>;
    configuration_gte?: Maybe<Scalars['String']>;
    configuration_lte?: Maybe<Scalars['String']>;
    configuration_in?: Maybe<Array<Scalars['String']>>;
    configuration_not_in?: Maybe<Array<Scalars['String']>>;
    configuration_contains?: Maybe<Scalars['String']>;
    configuration_contains_nocase?: Maybe<Scalars['String']>;
    configuration_not_contains?: Maybe<Scalars['String']>;
    configuration_not_contains_nocase?: Maybe<Scalars['String']>;
    configuration_starts_with?: Maybe<Scalars['String']>;
    configuration_starts_with_nocase?: Maybe<Scalars['String']>;
    configuration_not_starts_with?: Maybe<Scalars['String']>;
    configuration_not_starts_with_nocase?: Maybe<Scalars['String']>;
    configuration_ends_with?: Maybe<Scalars['String']>;
    configuration_ends_with_nocase?: Maybe<Scalars['String']>;
    configuration_not_ends_with?: Maybe<Scalars['String']>;
    configuration_not_ends_with_nocase?: Maybe<Scalars['String']>;
    branch?: Maybe<Scalars['String']>;
    branch_not?: Maybe<Scalars['String']>;
    branch_gt?: Maybe<Scalars['String']>;
    branch_lt?: Maybe<Scalars['String']>;
    branch_gte?: Maybe<Scalars['String']>;
    branch_lte?: Maybe<Scalars['String']>;
    branch_in?: Maybe<Array<Scalars['String']>>;
    branch_not_in?: Maybe<Array<Scalars['String']>>;
    branch_contains?: Maybe<Scalars['String']>;
    branch_contains_nocase?: Maybe<Scalars['String']>;
    branch_not_contains?: Maybe<Scalars['String']>;
    branch_not_contains_nocase?: Maybe<Scalars['String']>;
    branch_starts_with?: Maybe<Scalars['String']>;
    branch_starts_with_nocase?: Maybe<Scalars['String']>;
    branch_not_starts_with?: Maybe<Scalars['String']>;
    branch_not_starts_with_nocase?: Maybe<Scalars['String']>;
    branch_ends_with?: Maybe<Scalars['String']>;
    branch_ends_with_nocase?: Maybe<Scalars['String']>;
    branch_not_ends_with?: Maybe<Scalars['String']>;
    branch_not_ends_with_nocase?: Maybe<Scalars['String']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum SfMeta_OrderBy {
    Id = "id",
    Timestamp = "timestamp",
    BlockNumber = "blockNumber",
    Configuration = "configuration",
    Branch = "branch"
}
export declare type SentEvent = Event & {
    __typename?: 'SentEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token, operator and from addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    operator: Scalars['Bytes'];
    from: Scalars['Bytes'];
    to: Scalars['Bytes'];
    token: Scalars['Bytes'];
    amount: Scalars['BigInt'];
    data: Scalars['Bytes'];
    operatorData: Scalars['Bytes'];
};
export declare type SentEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    operator?: Maybe<Scalars['Bytes']>;
    operator_not?: Maybe<Scalars['Bytes']>;
    operator_in?: Maybe<Array<Scalars['Bytes']>>;
    operator_not_in?: Maybe<Array<Scalars['Bytes']>>;
    operator_contains?: Maybe<Scalars['Bytes']>;
    operator_not_contains?: Maybe<Scalars['Bytes']>;
    from?: Maybe<Scalars['Bytes']>;
    from_not?: Maybe<Scalars['Bytes']>;
    from_in?: Maybe<Array<Scalars['Bytes']>>;
    from_not_in?: Maybe<Array<Scalars['Bytes']>>;
    from_contains?: Maybe<Scalars['Bytes']>;
    from_not_contains?: Maybe<Scalars['Bytes']>;
    to?: Maybe<Scalars['Bytes']>;
    to_not?: Maybe<Scalars['Bytes']>;
    to_in?: Maybe<Array<Scalars['Bytes']>>;
    to_not_in?: Maybe<Array<Scalars['Bytes']>>;
    to_contains?: Maybe<Scalars['Bytes']>;
    to_not_contains?: Maybe<Scalars['Bytes']>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    amount?: Maybe<Scalars['BigInt']>;
    amount_not?: Maybe<Scalars['BigInt']>;
    amount_gt?: Maybe<Scalars['BigInt']>;
    amount_lt?: Maybe<Scalars['BigInt']>;
    amount_gte?: Maybe<Scalars['BigInt']>;
    amount_lte?: Maybe<Scalars['BigInt']>;
    amount_in?: Maybe<Array<Scalars['BigInt']>>;
    amount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    data?: Maybe<Scalars['Bytes']>;
    data_not?: Maybe<Scalars['Bytes']>;
    data_in?: Maybe<Array<Scalars['Bytes']>>;
    data_not_in?: Maybe<Array<Scalars['Bytes']>>;
    data_contains?: Maybe<Scalars['Bytes']>;
    data_not_contains?: Maybe<Scalars['Bytes']>;
    operatorData?: Maybe<Scalars['Bytes']>;
    operatorData_not?: Maybe<Scalars['Bytes']>;
    operatorData_in?: Maybe<Array<Scalars['Bytes']>>;
    operatorData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    operatorData_contains?: Maybe<Scalars['Bytes']>;
    operatorData_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum SentEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Operator = "operator",
    From = "from",
    To = "to",
    Token = "token",
    Amount = "amount",
    Data = "data",
    OperatorData = "operatorData"
}
export declare type SetEvent = Event & {
    __typename?: 'SetEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    /**
     * Because the name property is indexed, the
     * returned value will be a keccak256 hash
     * of the string.
     */
    hashedName: Scalars['Bytes'];
    target: Scalars['Bytes'];
    resolverEntry: ResolverEntry;
};
export declare type SetEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    hashedName?: Maybe<Scalars['Bytes']>;
    hashedName_not?: Maybe<Scalars['Bytes']>;
    hashedName_in?: Maybe<Array<Scalars['Bytes']>>;
    hashedName_not_in?: Maybe<Array<Scalars['Bytes']>>;
    hashedName_contains?: Maybe<Scalars['Bytes']>;
    hashedName_not_contains?: Maybe<Scalars['Bytes']>;
    target?: Maybe<Scalars['Bytes']>;
    target_not?: Maybe<Scalars['Bytes']>;
    target_in?: Maybe<Array<Scalars['Bytes']>>;
    target_not_in?: Maybe<Array<Scalars['Bytes']>>;
    target_contains?: Maybe<Scalars['Bytes']>;
    target_not_contains?: Maybe<Scalars['Bytes']>;
    resolverEntry?: Maybe<Scalars['String']>;
    resolverEntry_not?: Maybe<Scalars['String']>;
    resolverEntry_gt?: Maybe<Scalars['String']>;
    resolverEntry_lt?: Maybe<Scalars['String']>;
    resolverEntry_gte?: Maybe<Scalars['String']>;
    resolverEntry_lte?: Maybe<Scalars['String']>;
    resolverEntry_in?: Maybe<Array<Scalars['String']>>;
    resolverEntry_not_in?: Maybe<Array<Scalars['String']>>;
    resolverEntry_contains?: Maybe<Scalars['String']>;
    resolverEntry_contains_nocase?: Maybe<Scalars['String']>;
    resolverEntry_not_contains?: Maybe<Scalars['String']>;
    resolverEntry_not_contains_nocase?: Maybe<Scalars['String']>;
    resolverEntry_starts_with?: Maybe<Scalars['String']>;
    resolverEntry_starts_with_nocase?: Maybe<Scalars['String']>;
    resolverEntry_not_starts_with?: Maybe<Scalars['String']>;
    resolverEntry_not_starts_with_nocase?: Maybe<Scalars['String']>;
    resolverEntry_ends_with?: Maybe<Scalars['String']>;
    resolverEntry_ends_with_nocase?: Maybe<Scalars['String']>;
    resolverEntry_not_ends_with?: Maybe<Scalars['String']>;
    resolverEntry_not_ends_with_nocase?: Maybe<Scalars['String']>;
    resolverEntry_?: Maybe<ResolverEntry_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum SetEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    HashedName = "hashedName",
    Target = "target",
    ResolverEntry = "resolverEntry"
}
/**
 * Stream: A higher order entity that represents the lifetime of a stream between a `sender` and a `receiver`.
 * A account can start a stream, update the flow rate, but when they close it, it is
 * considered "dead". The next stream you create with the same `sender` and `receiver`
 * will create a new stream entity. Therefore, multiple stream entities can be created
 * between the same `sender` and `receiver`.
 */
export declare type Stream = {
    __typename?: 'Stream';
    /** ID composed of: senderAddress-receiverAddress-tokenAddress-revisionIndex */
    id: Scalars['ID'];
    createdAtTimestamp: Scalars['BigInt'];
    createdAtBlockNumber: Scalars['BigInt'];
    updatedAtTimestamp: Scalars['BigInt'];
    updatedAtBlockNumber: Scalars['BigInt'];
    currentFlowRate: Scalars['BigInt'];
    deposit: Scalars['BigInt'];
    /**
     * The amount streamed until `updatedAtTimestamp`/`updatedAtBlock`. The formula to get the current streamed
     * amount is:
     * `streamedUntilUpdatedAt + ((currentTime in seconds) - updatedAtTimestamp) * currentFlowRate`.
     */
    streamedUntilUpdatedAt: Scalars['BigInt'];
    token: Token;
    sender: Account;
    receiver: Account;
    flowUpdatedEvents: Array<FlowUpdatedEvent>;
    streamPeriods: Array<StreamPeriod>;
};
/**
 * Stream: A higher order entity that represents the lifetime of a stream between a `sender` and a `receiver`.
 * A account can start a stream, update the flow rate, but when they close it, it is
 * considered "dead". The next stream you create with the same `sender` and `receiver`
 * will create a new stream entity. Therefore, multiple stream entities can be created
 * between the same `sender` and `receiver`.
 */
export declare type StreamFlowUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowUpdatedEvent_Filter>;
};
/**
 * Stream: A higher order entity that represents the lifetime of a stream between a `sender` and a `receiver`.
 * A account can start a stream, update the flow rate, but when they close it, it is
 * considered "dead". The next stream you create with the same `sender` and `receiver`
 * will create a new stream entity. Therefore, multiple stream entities can be created
 * between the same `sender` and `receiver`.
 */
export declare type StreamStreamPeriodsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<StreamPeriod_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<StreamPeriod_Filter>;
};
/** StreamPeriod: A higher order entity that represents a period of time in a Stream with a constant flowRate. */
export declare type StreamPeriod = {
    __typename?: 'StreamPeriod';
    /** ID composed of: streamId - periodRevisionIndex */
    id: Scalars['ID'];
    stream: Stream;
    sender: Account;
    receiver: Account;
    token: Token;
    flowRate: Scalars['BigInt'];
    deposit: Scalars['BigInt'];
    startedAtTimestamp: Scalars['BigInt'];
    startedAtBlockNumber: Scalars['BigInt'];
    startedAtEvent: FlowUpdatedEvent;
    /** Following values are null until the StreamPeriod is terminated */
    stoppedAtTimestamp?: Maybe<Scalars['BigInt']>;
    stoppedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    stoppedAtEvent?: Maybe<FlowUpdatedEvent>;
    totalAmountStreamed?: Maybe<Scalars['BigInt']>;
};
export declare type StreamPeriod_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    stream?: Maybe<Scalars['String']>;
    stream_not?: Maybe<Scalars['String']>;
    stream_gt?: Maybe<Scalars['String']>;
    stream_lt?: Maybe<Scalars['String']>;
    stream_gte?: Maybe<Scalars['String']>;
    stream_lte?: Maybe<Scalars['String']>;
    stream_in?: Maybe<Array<Scalars['String']>>;
    stream_not_in?: Maybe<Array<Scalars['String']>>;
    stream_contains?: Maybe<Scalars['String']>;
    stream_contains_nocase?: Maybe<Scalars['String']>;
    stream_not_contains?: Maybe<Scalars['String']>;
    stream_not_contains_nocase?: Maybe<Scalars['String']>;
    stream_starts_with?: Maybe<Scalars['String']>;
    stream_starts_with_nocase?: Maybe<Scalars['String']>;
    stream_not_starts_with?: Maybe<Scalars['String']>;
    stream_not_starts_with_nocase?: Maybe<Scalars['String']>;
    stream_ends_with?: Maybe<Scalars['String']>;
    stream_ends_with_nocase?: Maybe<Scalars['String']>;
    stream_not_ends_with?: Maybe<Scalars['String']>;
    stream_not_ends_with_nocase?: Maybe<Scalars['String']>;
    stream_?: Maybe<Stream_Filter>;
    sender?: Maybe<Scalars['String']>;
    sender_not?: Maybe<Scalars['String']>;
    sender_gt?: Maybe<Scalars['String']>;
    sender_lt?: Maybe<Scalars['String']>;
    sender_gte?: Maybe<Scalars['String']>;
    sender_lte?: Maybe<Scalars['String']>;
    sender_in?: Maybe<Array<Scalars['String']>>;
    sender_not_in?: Maybe<Array<Scalars['String']>>;
    sender_contains?: Maybe<Scalars['String']>;
    sender_contains_nocase?: Maybe<Scalars['String']>;
    sender_not_contains?: Maybe<Scalars['String']>;
    sender_not_contains_nocase?: Maybe<Scalars['String']>;
    sender_starts_with?: Maybe<Scalars['String']>;
    sender_starts_with_nocase?: Maybe<Scalars['String']>;
    sender_not_starts_with?: Maybe<Scalars['String']>;
    sender_not_starts_with_nocase?: Maybe<Scalars['String']>;
    sender_ends_with?: Maybe<Scalars['String']>;
    sender_ends_with_nocase?: Maybe<Scalars['String']>;
    sender_not_ends_with?: Maybe<Scalars['String']>;
    sender_not_ends_with_nocase?: Maybe<Scalars['String']>;
    sender_?: Maybe<Account_Filter>;
    receiver?: Maybe<Scalars['String']>;
    receiver_not?: Maybe<Scalars['String']>;
    receiver_gt?: Maybe<Scalars['String']>;
    receiver_lt?: Maybe<Scalars['String']>;
    receiver_gte?: Maybe<Scalars['String']>;
    receiver_lte?: Maybe<Scalars['String']>;
    receiver_in?: Maybe<Array<Scalars['String']>>;
    receiver_not_in?: Maybe<Array<Scalars['String']>>;
    receiver_contains?: Maybe<Scalars['String']>;
    receiver_contains_nocase?: Maybe<Scalars['String']>;
    receiver_not_contains?: Maybe<Scalars['String']>;
    receiver_not_contains_nocase?: Maybe<Scalars['String']>;
    receiver_starts_with?: Maybe<Scalars['String']>;
    receiver_starts_with_nocase?: Maybe<Scalars['String']>;
    receiver_not_starts_with?: Maybe<Scalars['String']>;
    receiver_not_starts_with_nocase?: Maybe<Scalars['String']>;
    receiver_ends_with?: Maybe<Scalars['String']>;
    receiver_ends_with_nocase?: Maybe<Scalars['String']>;
    receiver_not_ends_with?: Maybe<Scalars['String']>;
    receiver_not_ends_with_nocase?: Maybe<Scalars['String']>;
    receiver_?: Maybe<Account_Filter>;
    token?: Maybe<Scalars['String']>;
    token_not?: Maybe<Scalars['String']>;
    token_gt?: Maybe<Scalars['String']>;
    token_lt?: Maybe<Scalars['String']>;
    token_gte?: Maybe<Scalars['String']>;
    token_lte?: Maybe<Scalars['String']>;
    token_in?: Maybe<Array<Scalars['String']>>;
    token_not_in?: Maybe<Array<Scalars['String']>>;
    token_contains?: Maybe<Scalars['String']>;
    token_contains_nocase?: Maybe<Scalars['String']>;
    token_not_contains?: Maybe<Scalars['String']>;
    token_not_contains_nocase?: Maybe<Scalars['String']>;
    token_starts_with?: Maybe<Scalars['String']>;
    token_starts_with_nocase?: Maybe<Scalars['String']>;
    token_not_starts_with?: Maybe<Scalars['String']>;
    token_not_starts_with_nocase?: Maybe<Scalars['String']>;
    token_ends_with?: Maybe<Scalars['String']>;
    token_ends_with_nocase?: Maybe<Scalars['String']>;
    token_not_ends_with?: Maybe<Scalars['String']>;
    token_not_ends_with_nocase?: Maybe<Scalars['String']>;
    token_?: Maybe<Token_Filter>;
    flowRate?: Maybe<Scalars['BigInt']>;
    flowRate_not?: Maybe<Scalars['BigInt']>;
    flowRate_gt?: Maybe<Scalars['BigInt']>;
    flowRate_lt?: Maybe<Scalars['BigInt']>;
    flowRate_gte?: Maybe<Scalars['BigInt']>;
    flowRate_lte?: Maybe<Scalars['BigInt']>;
    flowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    flowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    deposit?: Maybe<Scalars['BigInt']>;
    deposit_not?: Maybe<Scalars['BigInt']>;
    deposit_gt?: Maybe<Scalars['BigInt']>;
    deposit_lt?: Maybe<Scalars['BigInt']>;
    deposit_gte?: Maybe<Scalars['BigInt']>;
    deposit_lte?: Maybe<Scalars['BigInt']>;
    deposit_in?: Maybe<Array<Scalars['BigInt']>>;
    deposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    startedAtTimestamp?: Maybe<Scalars['BigInt']>;
    startedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    startedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    startedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    startedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    startedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    startedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    startedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    startedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    startedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    startedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    startedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    startedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    startedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    startedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    startedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    startedAtEvent?: Maybe<Scalars['String']>;
    startedAtEvent_not?: Maybe<Scalars['String']>;
    startedAtEvent_gt?: Maybe<Scalars['String']>;
    startedAtEvent_lt?: Maybe<Scalars['String']>;
    startedAtEvent_gte?: Maybe<Scalars['String']>;
    startedAtEvent_lte?: Maybe<Scalars['String']>;
    startedAtEvent_in?: Maybe<Array<Scalars['String']>>;
    startedAtEvent_not_in?: Maybe<Array<Scalars['String']>>;
    startedAtEvent_contains?: Maybe<Scalars['String']>;
    startedAtEvent_contains_nocase?: Maybe<Scalars['String']>;
    startedAtEvent_not_contains?: Maybe<Scalars['String']>;
    startedAtEvent_not_contains_nocase?: Maybe<Scalars['String']>;
    startedAtEvent_starts_with?: Maybe<Scalars['String']>;
    startedAtEvent_starts_with_nocase?: Maybe<Scalars['String']>;
    startedAtEvent_not_starts_with?: Maybe<Scalars['String']>;
    startedAtEvent_not_starts_with_nocase?: Maybe<Scalars['String']>;
    startedAtEvent_ends_with?: Maybe<Scalars['String']>;
    startedAtEvent_ends_with_nocase?: Maybe<Scalars['String']>;
    startedAtEvent_not_ends_with?: Maybe<Scalars['String']>;
    startedAtEvent_not_ends_with_nocase?: Maybe<Scalars['String']>;
    startedAtEvent_?: Maybe<FlowUpdatedEvent_Filter>;
    stoppedAtTimestamp?: Maybe<Scalars['BigInt']>;
    stoppedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    stoppedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    stoppedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    stoppedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    stoppedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    stoppedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    stoppedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    stoppedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    stoppedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    stoppedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    stoppedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    stoppedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    stoppedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    stoppedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    stoppedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    stoppedAtEvent?: Maybe<Scalars['String']>;
    stoppedAtEvent_not?: Maybe<Scalars['String']>;
    stoppedAtEvent_gt?: Maybe<Scalars['String']>;
    stoppedAtEvent_lt?: Maybe<Scalars['String']>;
    stoppedAtEvent_gte?: Maybe<Scalars['String']>;
    stoppedAtEvent_lte?: Maybe<Scalars['String']>;
    stoppedAtEvent_in?: Maybe<Array<Scalars['String']>>;
    stoppedAtEvent_not_in?: Maybe<Array<Scalars['String']>>;
    stoppedAtEvent_contains?: Maybe<Scalars['String']>;
    stoppedAtEvent_contains_nocase?: Maybe<Scalars['String']>;
    stoppedAtEvent_not_contains?: Maybe<Scalars['String']>;
    stoppedAtEvent_not_contains_nocase?: Maybe<Scalars['String']>;
    stoppedAtEvent_starts_with?: Maybe<Scalars['String']>;
    stoppedAtEvent_starts_with_nocase?: Maybe<Scalars['String']>;
    stoppedAtEvent_not_starts_with?: Maybe<Scalars['String']>;
    stoppedAtEvent_not_starts_with_nocase?: Maybe<Scalars['String']>;
    stoppedAtEvent_ends_with?: Maybe<Scalars['String']>;
    stoppedAtEvent_ends_with_nocase?: Maybe<Scalars['String']>;
    stoppedAtEvent_not_ends_with?: Maybe<Scalars['String']>;
    stoppedAtEvent_not_ends_with_nocase?: Maybe<Scalars['String']>;
    stoppedAtEvent_?: Maybe<FlowUpdatedEvent_Filter>;
    totalAmountStreamed?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum StreamPeriod_OrderBy {
    Id = "id",
    Stream = "stream",
    Sender = "sender",
    Receiver = "receiver",
    Token = "token",
    FlowRate = "flowRate",
    Deposit = "deposit",
    StartedAtTimestamp = "startedAtTimestamp",
    StartedAtBlockNumber = "startedAtBlockNumber",
    StartedAtEvent = "startedAtEvent",
    StoppedAtTimestamp = "stoppedAtTimestamp",
    StoppedAtBlockNumber = "stoppedAtBlockNumber",
    StoppedAtEvent = "stoppedAtEvent",
    TotalAmountStreamed = "totalAmountStreamed"
}
export declare type StreamRevision = {
    __typename?: 'StreamRevision';
    id: Scalars['ID'];
    revisionIndex: Scalars['Int'];
    periodRevisionIndex: Scalars['Int'];
};
export declare type StreamRevision_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    revisionIndex?: Maybe<Scalars['Int']>;
    revisionIndex_not?: Maybe<Scalars['Int']>;
    revisionIndex_gt?: Maybe<Scalars['Int']>;
    revisionIndex_lt?: Maybe<Scalars['Int']>;
    revisionIndex_gte?: Maybe<Scalars['Int']>;
    revisionIndex_lte?: Maybe<Scalars['Int']>;
    revisionIndex_in?: Maybe<Array<Scalars['Int']>>;
    revisionIndex_not_in?: Maybe<Array<Scalars['Int']>>;
    periodRevisionIndex?: Maybe<Scalars['Int']>;
    periodRevisionIndex_not?: Maybe<Scalars['Int']>;
    periodRevisionIndex_gt?: Maybe<Scalars['Int']>;
    periodRevisionIndex_lt?: Maybe<Scalars['Int']>;
    periodRevisionIndex_gte?: Maybe<Scalars['Int']>;
    periodRevisionIndex_lte?: Maybe<Scalars['Int']>;
    periodRevisionIndex_in?: Maybe<Array<Scalars['Int']>>;
    periodRevisionIndex_not_in?: Maybe<Array<Scalars['Int']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum StreamRevision_OrderBy {
    Id = "id",
    RevisionIndex = "revisionIndex",
    PeriodRevisionIndex = "periodRevisionIndex"
}
export declare type Stream_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    createdAtTimestamp?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    currentFlowRate?: Maybe<Scalars['BigInt']>;
    currentFlowRate_not?: Maybe<Scalars['BigInt']>;
    currentFlowRate_gt?: Maybe<Scalars['BigInt']>;
    currentFlowRate_lt?: Maybe<Scalars['BigInt']>;
    currentFlowRate_gte?: Maybe<Scalars['BigInt']>;
    currentFlowRate_lte?: Maybe<Scalars['BigInt']>;
    currentFlowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    currentFlowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    deposit?: Maybe<Scalars['BigInt']>;
    deposit_not?: Maybe<Scalars['BigInt']>;
    deposit_gt?: Maybe<Scalars['BigInt']>;
    deposit_lt?: Maybe<Scalars['BigInt']>;
    deposit_gte?: Maybe<Scalars['BigInt']>;
    deposit_lte?: Maybe<Scalars['BigInt']>;
    deposit_in?: Maybe<Array<Scalars['BigInt']>>;
    deposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    streamedUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    streamedUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    streamedUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    streamedUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    streamedUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    streamedUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    streamedUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    streamedUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['String']>;
    token_not?: Maybe<Scalars['String']>;
    token_gt?: Maybe<Scalars['String']>;
    token_lt?: Maybe<Scalars['String']>;
    token_gte?: Maybe<Scalars['String']>;
    token_lte?: Maybe<Scalars['String']>;
    token_in?: Maybe<Array<Scalars['String']>>;
    token_not_in?: Maybe<Array<Scalars['String']>>;
    token_contains?: Maybe<Scalars['String']>;
    token_contains_nocase?: Maybe<Scalars['String']>;
    token_not_contains?: Maybe<Scalars['String']>;
    token_not_contains_nocase?: Maybe<Scalars['String']>;
    token_starts_with?: Maybe<Scalars['String']>;
    token_starts_with_nocase?: Maybe<Scalars['String']>;
    token_not_starts_with?: Maybe<Scalars['String']>;
    token_not_starts_with_nocase?: Maybe<Scalars['String']>;
    token_ends_with?: Maybe<Scalars['String']>;
    token_ends_with_nocase?: Maybe<Scalars['String']>;
    token_not_ends_with?: Maybe<Scalars['String']>;
    token_not_ends_with_nocase?: Maybe<Scalars['String']>;
    token_?: Maybe<Token_Filter>;
    sender?: Maybe<Scalars['String']>;
    sender_not?: Maybe<Scalars['String']>;
    sender_gt?: Maybe<Scalars['String']>;
    sender_lt?: Maybe<Scalars['String']>;
    sender_gte?: Maybe<Scalars['String']>;
    sender_lte?: Maybe<Scalars['String']>;
    sender_in?: Maybe<Array<Scalars['String']>>;
    sender_not_in?: Maybe<Array<Scalars['String']>>;
    sender_contains?: Maybe<Scalars['String']>;
    sender_contains_nocase?: Maybe<Scalars['String']>;
    sender_not_contains?: Maybe<Scalars['String']>;
    sender_not_contains_nocase?: Maybe<Scalars['String']>;
    sender_starts_with?: Maybe<Scalars['String']>;
    sender_starts_with_nocase?: Maybe<Scalars['String']>;
    sender_not_starts_with?: Maybe<Scalars['String']>;
    sender_not_starts_with_nocase?: Maybe<Scalars['String']>;
    sender_ends_with?: Maybe<Scalars['String']>;
    sender_ends_with_nocase?: Maybe<Scalars['String']>;
    sender_not_ends_with?: Maybe<Scalars['String']>;
    sender_not_ends_with_nocase?: Maybe<Scalars['String']>;
    sender_?: Maybe<Account_Filter>;
    receiver?: Maybe<Scalars['String']>;
    receiver_not?: Maybe<Scalars['String']>;
    receiver_gt?: Maybe<Scalars['String']>;
    receiver_lt?: Maybe<Scalars['String']>;
    receiver_gte?: Maybe<Scalars['String']>;
    receiver_lte?: Maybe<Scalars['String']>;
    receiver_in?: Maybe<Array<Scalars['String']>>;
    receiver_not_in?: Maybe<Array<Scalars['String']>>;
    receiver_contains?: Maybe<Scalars['String']>;
    receiver_contains_nocase?: Maybe<Scalars['String']>;
    receiver_not_contains?: Maybe<Scalars['String']>;
    receiver_not_contains_nocase?: Maybe<Scalars['String']>;
    receiver_starts_with?: Maybe<Scalars['String']>;
    receiver_starts_with_nocase?: Maybe<Scalars['String']>;
    receiver_not_starts_with?: Maybe<Scalars['String']>;
    receiver_not_starts_with_nocase?: Maybe<Scalars['String']>;
    receiver_ends_with?: Maybe<Scalars['String']>;
    receiver_ends_with_nocase?: Maybe<Scalars['String']>;
    receiver_not_ends_with?: Maybe<Scalars['String']>;
    receiver_not_ends_with_nocase?: Maybe<Scalars['String']>;
    receiver_?: Maybe<Account_Filter>;
    flowUpdatedEvents_?: Maybe<FlowUpdatedEvent_Filter>;
    streamPeriods_?: Maybe<StreamPeriod_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum Stream_OrderBy {
    Id = "id",
    CreatedAtTimestamp = "createdAtTimestamp",
    CreatedAtBlockNumber = "createdAtBlockNumber",
    UpdatedAtTimestamp = "updatedAtTimestamp",
    UpdatedAtBlockNumber = "updatedAtBlockNumber",
    CurrentFlowRate = "currentFlowRate",
    Deposit = "deposit",
    StreamedUntilUpdatedAt = "streamedUntilUpdatedAt",
    Token = "token",
    Sender = "sender",
    Receiver = "receiver",
    FlowUpdatedEvents = "flowUpdatedEvents",
    StreamPeriods = "streamPeriods"
}
export declare type Subscription = {
    __typename?: 'Subscription';
    flowUpdatedEvent?: Maybe<FlowUpdatedEvent>;
    flowUpdatedEvents: Array<FlowUpdatedEvent>;
    flowOperatorUpdatedEvent?: Maybe<FlowOperatorUpdatedEvent>;
    flowOperatorUpdatedEvents: Array<FlowOperatorUpdatedEvent>;
    indexCreatedEvent?: Maybe<IndexCreatedEvent>;
    indexCreatedEvents: Array<IndexCreatedEvent>;
    indexDistributionClaimedEvent?: Maybe<IndexDistributionClaimedEvent>;
    indexDistributionClaimedEvents: Array<IndexDistributionClaimedEvent>;
    indexUpdatedEvent?: Maybe<IndexUpdatedEvent>;
    indexUpdatedEvents: Array<IndexUpdatedEvent>;
    indexSubscribedEvent?: Maybe<IndexSubscribedEvent>;
    indexSubscribedEvents: Array<IndexSubscribedEvent>;
    indexUnitsUpdatedEvent?: Maybe<IndexUnitsUpdatedEvent>;
    indexUnitsUpdatedEvents: Array<IndexUnitsUpdatedEvent>;
    indexUnsubscribedEvent?: Maybe<IndexUnsubscribedEvent>;
    indexUnsubscribedEvents: Array<IndexUnsubscribedEvent>;
    subscriptionApprovedEvent?: Maybe<SubscriptionApprovedEvent>;
    subscriptionApprovedEvents: Array<SubscriptionApprovedEvent>;
    subscriptionDistributionClaimedEvent?: Maybe<SubscriptionDistributionClaimedEvent>;
    subscriptionDistributionClaimedEvents: Array<SubscriptionDistributionClaimedEvent>;
    subscriptionRevokedEvent?: Maybe<SubscriptionRevokedEvent>;
    subscriptionRevokedEvents: Array<SubscriptionRevokedEvent>;
    subscriptionUnitsUpdatedEvent?: Maybe<SubscriptionUnitsUpdatedEvent>;
    subscriptionUnitsUpdatedEvents: Array<SubscriptionUnitsUpdatedEvent>;
    agreementClassRegisteredEvent?: Maybe<AgreementClassRegisteredEvent>;
    agreementClassRegisteredEvents: Array<AgreementClassRegisteredEvent>;
    agreementClassUpdatedEvent?: Maybe<AgreementClassUpdatedEvent>;
    agreementClassUpdatedEvents: Array<AgreementClassUpdatedEvent>;
    appRegisteredEvent?: Maybe<AppRegisteredEvent>;
    appRegisteredEvents: Array<AppRegisteredEvent>;
    governanceReplacedEvent?: Maybe<GovernanceReplacedEvent>;
    governanceReplacedEvents: Array<GovernanceReplacedEvent>;
    jailEvent?: Maybe<JailEvent>;
    jailEvents: Array<JailEvent>;
    superTokenFactoryUpdatedEvent?: Maybe<SuperTokenFactoryUpdatedEvent>;
    superTokenFactoryUpdatedEvents: Array<SuperTokenFactoryUpdatedEvent>;
    superTokenLogicUpdatedEvent?: Maybe<SuperTokenLogicUpdatedEvent>;
    superTokenLogicUpdatedEvents: Array<SuperTokenLogicUpdatedEvent>;
    roleAdminChangedEvent?: Maybe<RoleAdminChangedEvent>;
    roleAdminChangedEvents: Array<RoleAdminChangedEvent>;
    roleGrantedEvent?: Maybe<RoleGrantedEvent>;
    roleGrantedEvents: Array<RoleGrantedEvent>;
    roleRevokedEvent?: Maybe<RoleRevokedEvent>;
    roleRevokedEvents: Array<RoleRevokedEvent>;
    setEvent?: Maybe<SetEvent>;
    setEvents: Array<SetEvent>;
    cfav1LiquidationPeriodChangedEvent?: Maybe<CfAv1LiquidationPeriodChangedEvent>;
    cfav1LiquidationPeriodChangedEvents: Array<CfAv1LiquidationPeriodChangedEvent>;
    configChangedEvent?: Maybe<ConfigChangedEvent>;
    configChangedEvents: Array<ConfigChangedEvent>;
    rewardAddressChangedEvent?: Maybe<RewardAddressChangedEvent>;
    rewardAddressChangedEvents: Array<RewardAddressChangedEvent>;
    pppconfigurationChangedEvent?: Maybe<PppConfigurationChangedEvent>;
    pppconfigurationChangedEvents: Array<PppConfigurationChangedEvent>;
    trustedForwarderChangedEvent?: Maybe<TrustedForwarderChangedEvent>;
    trustedForwarderChangedEvents: Array<TrustedForwarderChangedEvent>;
    agreementLiquidatedByEvent?: Maybe<AgreementLiquidatedByEvent>;
    agreementLiquidatedByEvents: Array<AgreementLiquidatedByEvent>;
    agreementLiquidatedV2Event?: Maybe<AgreementLiquidatedV2Event>;
    agreementLiquidatedV2Events: Array<AgreementLiquidatedV2Event>;
    burnedEvent?: Maybe<BurnedEvent>;
    burnedEvents: Array<BurnedEvent>;
    mintedEvent?: Maybe<MintedEvent>;
    mintedEvents: Array<MintedEvent>;
    sentEvent?: Maybe<SentEvent>;
    sentEvents: Array<SentEvent>;
    transferEvent?: Maybe<TransferEvent>;
    transferEvents: Array<TransferEvent>;
    tokenDowngradedEvent?: Maybe<TokenDowngradedEvent>;
    tokenDowngradedEvents: Array<TokenDowngradedEvent>;
    tokenUpgradedEvent?: Maybe<TokenUpgradedEvent>;
    tokenUpgradedEvents: Array<TokenUpgradedEvent>;
    customSuperTokenCreatedEvent?: Maybe<CustomSuperTokenCreatedEvent>;
    customSuperTokenCreatedEvents: Array<CustomSuperTokenCreatedEvent>;
    superTokenCreatedEvent?: Maybe<SuperTokenCreatedEvent>;
    superTokenCreatedEvents: Array<SuperTokenCreatedEvent>;
    superTokenLogicCreatedEvent?: Maybe<SuperTokenLogicCreatedEvent>;
    superTokenLogicCreatedEvents: Array<SuperTokenLogicCreatedEvent>;
    account?: Maybe<Account>;
    accounts: Array<Account>;
    index?: Maybe<Index>;
    indexes: Array<Index>;
    indexSubscription?: Maybe<IndexSubscription>;
    indexSubscriptions: Array<IndexSubscription>;
    stream?: Maybe<Stream>;
    streams: Array<Stream>;
    flowOperator?: Maybe<FlowOperator>;
    flowOperators: Array<FlowOperator>;
    streamPeriod?: Maybe<StreamPeriod>;
    streamPeriods: Array<StreamPeriod>;
    streamRevision?: Maybe<StreamRevision>;
    streamRevisions: Array<StreamRevision>;
    token?: Maybe<Token>;
    tokens: Array<Token>;
    resolverEntry?: Maybe<ResolverEntry>;
    resolverEntries: Array<ResolverEntry>;
    accountTokenSnapshot?: Maybe<AccountTokenSnapshot>;
    accountTokenSnapshots: Array<AccountTokenSnapshot>;
    accountTokenSnapshotLog?: Maybe<AccountTokenSnapshotLog>;
    accountTokenSnapshotLogs: Array<AccountTokenSnapshotLog>;
    tokenStatistic?: Maybe<TokenStatistic>;
    tokenStatistics: Array<TokenStatistic>;
    tokenStatisticLog?: Maybe<TokenStatisticLog>;
    tokenStatisticLogs: Array<TokenStatisticLog>;
    sfmeta?: Maybe<SfMeta>;
    sfmetas: Array<SfMeta>;
    event?: Maybe<Event>;
    events: Array<Event>;
    /** Access to subgraph metadata */
    _meta?: Maybe<_Meta_>;
};
export declare type SubscriptionFlowUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionFlowUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionFlowOperatorUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionFlowOperatorUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowOperatorUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowOperatorUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionIndexCreatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionIndexCreatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexCreatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexCreatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionIndexDistributionClaimedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionIndexDistributionClaimedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexDistributionClaimedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexDistributionClaimedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionIndexUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionIndexUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionIndexSubscribedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionIndexSubscribedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexSubscribedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexSubscribedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionIndexUnitsUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionIndexUnitsUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUnitsUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUnitsUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionIndexUnsubscribedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionIndexUnsubscribedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexUnsubscribedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexUnsubscribedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSubscriptionApprovedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSubscriptionApprovedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionApprovedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionApprovedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSubscriptionDistributionClaimedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSubscriptionDistributionClaimedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionDistributionClaimedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionDistributionClaimedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSubscriptionRevokedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSubscriptionRevokedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionRevokedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionRevokedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSubscriptionUnitsUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSubscriptionUnitsUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SubscriptionUnitsUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SubscriptionUnitsUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAgreementClassRegisteredEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAgreementClassRegisteredEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AgreementClassRegisteredEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AgreementClassRegisteredEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAgreementClassUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAgreementClassUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AgreementClassUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AgreementClassUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAppRegisteredEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAppRegisteredEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AppRegisteredEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AppRegisteredEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionGovernanceReplacedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionGovernanceReplacedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<GovernanceReplacedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<GovernanceReplacedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionJailEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionJailEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<JailEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<JailEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSuperTokenFactoryUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSuperTokenFactoryUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenFactoryUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenFactoryUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSuperTokenLogicUpdatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSuperTokenLogicUpdatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenLogicUpdatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenLogicUpdatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionRoleAdminChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionRoleAdminChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RoleAdminChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RoleAdminChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionRoleGrantedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionRoleGrantedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RoleGrantedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RoleGrantedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionRoleRevokedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionRoleRevokedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RoleRevokedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RoleRevokedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSetEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSetEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SetEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SetEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionCfav1LiquidationPeriodChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionCfav1LiquidationPeriodChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<CfAv1LiquidationPeriodChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<CfAv1LiquidationPeriodChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionConfigChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionConfigChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<ConfigChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<ConfigChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionRewardAddressChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionRewardAddressChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RewardAddressChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RewardAddressChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionPppconfigurationChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionPppconfigurationChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<PppConfigurationChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<PppConfigurationChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTrustedForwarderChangedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTrustedForwarderChangedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TrustedForwarderChangedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TrustedForwarderChangedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAgreementLiquidatedByEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAgreementLiquidatedByEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AgreementLiquidatedByEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AgreementLiquidatedByEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAgreementLiquidatedV2EventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAgreementLiquidatedV2EventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AgreementLiquidatedV2Event_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AgreementLiquidatedV2Event_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionBurnedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionBurnedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<BurnedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<BurnedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionMintedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionMintedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<MintedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<MintedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSentEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSentEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SentEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SentEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTransferEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTransferEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TransferEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TransferEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTokenDowngradedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTokenDowngradedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenDowngradedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenDowngradedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTokenUpgradedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTokenUpgradedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenUpgradedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenUpgradedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionCustomSuperTokenCreatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionCustomSuperTokenCreatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<CustomSuperTokenCreatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<CustomSuperTokenCreatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSuperTokenCreatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSuperTokenCreatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenCreatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenCreatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSuperTokenLogicCreatedEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSuperTokenLogicCreatedEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SuperTokenLogicCreatedEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SuperTokenLogicCreatedEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAccountArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAccountsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Account_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Account_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionIndexArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionIndexesArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Index_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Index_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionIndexSubscriptionArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionIndexSubscriptionsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<IndexSubscription_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<IndexSubscription_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionStreamArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionStreamsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Stream_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Stream_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionFlowOperatorArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionFlowOperatorsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<FlowOperator_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<FlowOperator_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionStreamPeriodArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionStreamPeriodsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<StreamPeriod_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<StreamPeriod_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionStreamRevisionArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionStreamRevisionsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<StreamRevision_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<StreamRevision_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTokenArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTokensArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Token_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Token_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionResolverEntryArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionResolverEntriesArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<ResolverEntry_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<ResolverEntry_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAccountTokenSnapshotArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAccountTokenSnapshotsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AccountTokenSnapshot_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AccountTokenSnapshot_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAccountTokenSnapshotLogArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAccountTokenSnapshotLogsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AccountTokenSnapshotLog_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AccountTokenSnapshotLog_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTokenStatisticArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTokenStatisticsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenStatistic_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenStatistic_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTokenStatisticLogArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTokenStatisticLogsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenStatisticLog_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenStatisticLog_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSfmetaArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionSfmetasArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<SfMeta_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<SfMeta_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Event_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Event_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type Subscription_MetaArgs = {
    block?: Maybe<Block_Height>;
};
export declare type SubscriptionApprovedEvent = Event & {
    __typename?: 'SubscriptionApprovedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token, publisher and subscriber addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    subscriber: Scalars['Bytes'];
    publisher: Scalars['Bytes'];
    indexId: Scalars['BigInt'];
    userData: Scalars['Bytes'];
    subscription: IndexSubscription;
};
export declare type SubscriptionApprovedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    subscriber?: Maybe<Scalars['Bytes']>;
    subscriber_not?: Maybe<Scalars['Bytes']>;
    subscriber_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_not_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_contains?: Maybe<Scalars['Bytes']>;
    subscriber_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    subscription?: Maybe<Scalars['String']>;
    subscription_not?: Maybe<Scalars['String']>;
    subscription_gt?: Maybe<Scalars['String']>;
    subscription_lt?: Maybe<Scalars['String']>;
    subscription_gte?: Maybe<Scalars['String']>;
    subscription_lte?: Maybe<Scalars['String']>;
    subscription_in?: Maybe<Array<Scalars['String']>>;
    subscription_not_in?: Maybe<Array<Scalars['String']>>;
    subscription_contains?: Maybe<Scalars['String']>;
    subscription_contains_nocase?: Maybe<Scalars['String']>;
    subscription_not_contains?: Maybe<Scalars['String']>;
    subscription_not_contains_nocase?: Maybe<Scalars['String']>;
    subscription_starts_with?: Maybe<Scalars['String']>;
    subscription_starts_with_nocase?: Maybe<Scalars['String']>;
    subscription_not_starts_with?: Maybe<Scalars['String']>;
    subscription_not_starts_with_nocase?: Maybe<Scalars['String']>;
    subscription_ends_with?: Maybe<Scalars['String']>;
    subscription_ends_with_nocase?: Maybe<Scalars['String']>;
    subscription_not_ends_with?: Maybe<Scalars['String']>;
    subscription_not_ends_with_nocase?: Maybe<Scalars['String']>;
    subscription_?: Maybe<IndexSubscription_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum SubscriptionApprovedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Subscriber = "subscriber",
    Publisher = "publisher",
    IndexId = "indexId",
    UserData = "userData",
    Subscription = "subscription"
}
export declare type SubscriptionDistributionClaimedEvent = Event & {
    __typename?: 'SubscriptionDistributionClaimedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token, publisher and subscriber addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    subscriber: Scalars['Bytes'];
    publisher: Scalars['Bytes'];
    indexId: Scalars['BigInt'];
    amount: Scalars['BigInt'];
    subscription: IndexSubscription;
};
export declare type SubscriptionDistributionClaimedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    subscriber?: Maybe<Scalars['Bytes']>;
    subscriber_not?: Maybe<Scalars['Bytes']>;
    subscriber_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_not_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_contains?: Maybe<Scalars['Bytes']>;
    subscriber_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    amount?: Maybe<Scalars['BigInt']>;
    amount_not?: Maybe<Scalars['BigInt']>;
    amount_gt?: Maybe<Scalars['BigInt']>;
    amount_lt?: Maybe<Scalars['BigInt']>;
    amount_gte?: Maybe<Scalars['BigInt']>;
    amount_lte?: Maybe<Scalars['BigInt']>;
    amount_in?: Maybe<Array<Scalars['BigInt']>>;
    amount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    subscription?: Maybe<Scalars['String']>;
    subscription_not?: Maybe<Scalars['String']>;
    subscription_gt?: Maybe<Scalars['String']>;
    subscription_lt?: Maybe<Scalars['String']>;
    subscription_gte?: Maybe<Scalars['String']>;
    subscription_lte?: Maybe<Scalars['String']>;
    subscription_in?: Maybe<Array<Scalars['String']>>;
    subscription_not_in?: Maybe<Array<Scalars['String']>>;
    subscription_contains?: Maybe<Scalars['String']>;
    subscription_contains_nocase?: Maybe<Scalars['String']>;
    subscription_not_contains?: Maybe<Scalars['String']>;
    subscription_not_contains_nocase?: Maybe<Scalars['String']>;
    subscription_starts_with?: Maybe<Scalars['String']>;
    subscription_starts_with_nocase?: Maybe<Scalars['String']>;
    subscription_not_starts_with?: Maybe<Scalars['String']>;
    subscription_not_starts_with_nocase?: Maybe<Scalars['String']>;
    subscription_ends_with?: Maybe<Scalars['String']>;
    subscription_ends_with_nocase?: Maybe<Scalars['String']>;
    subscription_not_ends_with?: Maybe<Scalars['String']>;
    subscription_not_ends_with_nocase?: Maybe<Scalars['String']>;
    subscription_?: Maybe<IndexSubscription_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum SubscriptionDistributionClaimedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Subscriber = "subscriber",
    Publisher = "publisher",
    IndexId = "indexId",
    Amount = "amount",
    Subscription = "subscription"
}
export declare type SubscriptionRevokedEvent = Event & {
    __typename?: 'SubscriptionRevokedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token, publisher and subscriber addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    subscriber: Scalars['Bytes'];
    publisher: Scalars['Bytes'];
    indexId: Scalars['BigInt'];
    userData: Scalars['Bytes'];
    subscription: IndexSubscription;
};
export declare type SubscriptionRevokedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    subscriber?: Maybe<Scalars['Bytes']>;
    subscriber_not?: Maybe<Scalars['Bytes']>;
    subscriber_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_not_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_contains?: Maybe<Scalars['Bytes']>;
    subscriber_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    subscription?: Maybe<Scalars['String']>;
    subscription_not?: Maybe<Scalars['String']>;
    subscription_gt?: Maybe<Scalars['String']>;
    subscription_lt?: Maybe<Scalars['String']>;
    subscription_gte?: Maybe<Scalars['String']>;
    subscription_lte?: Maybe<Scalars['String']>;
    subscription_in?: Maybe<Array<Scalars['String']>>;
    subscription_not_in?: Maybe<Array<Scalars['String']>>;
    subscription_contains?: Maybe<Scalars['String']>;
    subscription_contains_nocase?: Maybe<Scalars['String']>;
    subscription_not_contains?: Maybe<Scalars['String']>;
    subscription_not_contains_nocase?: Maybe<Scalars['String']>;
    subscription_starts_with?: Maybe<Scalars['String']>;
    subscription_starts_with_nocase?: Maybe<Scalars['String']>;
    subscription_not_starts_with?: Maybe<Scalars['String']>;
    subscription_not_starts_with_nocase?: Maybe<Scalars['String']>;
    subscription_ends_with?: Maybe<Scalars['String']>;
    subscription_ends_with_nocase?: Maybe<Scalars['String']>;
    subscription_not_ends_with?: Maybe<Scalars['String']>;
    subscription_not_ends_with_nocase?: Maybe<Scalars['String']>;
    subscription_?: Maybe<IndexSubscription_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum SubscriptionRevokedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Subscriber = "subscriber",
    Publisher = "publisher",
    IndexId = "indexId",
    UserData = "userData",
    Subscription = "subscription"
}
export declare type SubscriptionUnitsUpdatedEvent = Event & {
    __typename?: 'SubscriptionUnitsUpdatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token, publisher and subscriber addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    subscriber: Scalars['Bytes'];
    publisher: Scalars['Bytes'];
    indexId: Scalars['BigInt'];
    units: Scalars['BigInt'];
    userData: Scalars['Bytes'];
    oldUnits: Scalars['BigInt'];
    subscription: IndexSubscription;
};
export declare type SubscriptionUnitsUpdatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    subscriber?: Maybe<Scalars['Bytes']>;
    subscriber_not?: Maybe<Scalars['Bytes']>;
    subscriber_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_not_in?: Maybe<Array<Scalars['Bytes']>>;
    subscriber_contains?: Maybe<Scalars['Bytes']>;
    subscriber_not_contains?: Maybe<Scalars['Bytes']>;
    publisher?: Maybe<Scalars['Bytes']>;
    publisher_not?: Maybe<Scalars['Bytes']>;
    publisher_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_not_in?: Maybe<Array<Scalars['Bytes']>>;
    publisher_contains?: Maybe<Scalars['Bytes']>;
    publisher_not_contains?: Maybe<Scalars['Bytes']>;
    indexId?: Maybe<Scalars['BigInt']>;
    indexId_not?: Maybe<Scalars['BigInt']>;
    indexId_gt?: Maybe<Scalars['BigInt']>;
    indexId_lt?: Maybe<Scalars['BigInt']>;
    indexId_gte?: Maybe<Scalars['BigInt']>;
    indexId_lte?: Maybe<Scalars['BigInt']>;
    indexId_in?: Maybe<Array<Scalars['BigInt']>>;
    indexId_not_in?: Maybe<Array<Scalars['BigInt']>>;
    units?: Maybe<Scalars['BigInt']>;
    units_not?: Maybe<Scalars['BigInt']>;
    units_gt?: Maybe<Scalars['BigInt']>;
    units_lt?: Maybe<Scalars['BigInt']>;
    units_gte?: Maybe<Scalars['BigInt']>;
    units_lte?: Maybe<Scalars['BigInt']>;
    units_in?: Maybe<Array<Scalars['BigInt']>>;
    units_not_in?: Maybe<Array<Scalars['BigInt']>>;
    userData?: Maybe<Scalars['Bytes']>;
    userData_not?: Maybe<Scalars['Bytes']>;
    userData_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_not_in?: Maybe<Array<Scalars['Bytes']>>;
    userData_contains?: Maybe<Scalars['Bytes']>;
    userData_not_contains?: Maybe<Scalars['Bytes']>;
    oldUnits?: Maybe<Scalars['BigInt']>;
    oldUnits_not?: Maybe<Scalars['BigInt']>;
    oldUnits_gt?: Maybe<Scalars['BigInt']>;
    oldUnits_lt?: Maybe<Scalars['BigInt']>;
    oldUnits_gte?: Maybe<Scalars['BigInt']>;
    oldUnits_lte?: Maybe<Scalars['BigInt']>;
    oldUnits_in?: Maybe<Array<Scalars['BigInt']>>;
    oldUnits_not_in?: Maybe<Array<Scalars['BigInt']>>;
    subscription?: Maybe<Scalars['String']>;
    subscription_not?: Maybe<Scalars['String']>;
    subscription_gt?: Maybe<Scalars['String']>;
    subscription_lt?: Maybe<Scalars['String']>;
    subscription_gte?: Maybe<Scalars['String']>;
    subscription_lte?: Maybe<Scalars['String']>;
    subscription_in?: Maybe<Array<Scalars['String']>>;
    subscription_not_in?: Maybe<Array<Scalars['String']>>;
    subscription_contains?: Maybe<Scalars['String']>;
    subscription_contains_nocase?: Maybe<Scalars['String']>;
    subscription_not_contains?: Maybe<Scalars['String']>;
    subscription_not_contains_nocase?: Maybe<Scalars['String']>;
    subscription_starts_with?: Maybe<Scalars['String']>;
    subscription_starts_with_nocase?: Maybe<Scalars['String']>;
    subscription_not_starts_with?: Maybe<Scalars['String']>;
    subscription_not_starts_with_nocase?: Maybe<Scalars['String']>;
    subscription_ends_with?: Maybe<Scalars['String']>;
    subscription_ends_with_nocase?: Maybe<Scalars['String']>;
    subscription_not_ends_with?: Maybe<Scalars['String']>;
    subscription_not_ends_with_nocase?: Maybe<Scalars['String']>;
    subscription_?: Maybe<IndexSubscription_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum SubscriptionUnitsUpdatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Subscriber = "subscriber",
    Publisher = "publisher",
    IndexId = "indexId",
    Units = "units",
    UserData = "userData",
    OldUnits = "oldUnits",
    Subscription = "subscription"
}
export declare type SuperTokenCreatedEvent = Event & {
    __typename?: 'SuperTokenCreatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token address. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
};
export declare type SuperTokenCreatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum SuperTokenCreatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token"
}
export declare type SuperTokenFactoryUpdatedEvent = Event & {
    __typename?: 'SuperTokenFactoryUpdatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    newFactory: Scalars['Bytes'];
};
export declare type SuperTokenFactoryUpdatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    newFactory?: Maybe<Scalars['Bytes']>;
    newFactory_not?: Maybe<Scalars['Bytes']>;
    newFactory_in?: Maybe<Array<Scalars['Bytes']>>;
    newFactory_not_in?: Maybe<Array<Scalars['Bytes']>>;
    newFactory_contains?: Maybe<Scalars['Bytes']>;
    newFactory_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum SuperTokenFactoryUpdatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    NewFactory = "newFactory"
}
export declare type SuperTokenLogicCreatedEvent = Event & {
    __typename?: 'SuperTokenLogicCreatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    tokenLogic: Scalars['Bytes'];
};
export declare type SuperTokenLogicCreatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    tokenLogic?: Maybe<Scalars['Bytes']>;
    tokenLogic_not?: Maybe<Scalars['Bytes']>;
    tokenLogic_in?: Maybe<Array<Scalars['Bytes']>>;
    tokenLogic_not_in?: Maybe<Array<Scalars['Bytes']>>;
    tokenLogic_contains?: Maybe<Scalars['Bytes']>;
    tokenLogic_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum SuperTokenLogicCreatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    TokenLogic = "tokenLogic"
}
export declare type SuperTokenLogicUpdatedEvent = Event & {
    __typename?: 'SuperTokenLogicUpdatedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    code: Scalars['Bytes'];
};
export declare type SuperTokenLogicUpdatedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    code?: Maybe<Scalars['Bytes']>;
    code_not?: Maybe<Scalars['Bytes']>;
    code_in?: Maybe<Array<Scalars['Bytes']>>;
    code_not_in?: Maybe<Array<Scalars['Bytes']>>;
    code_contains?: Maybe<Scalars['Bytes']>;
    code_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum SuperTokenLogicUpdatedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Code = "code"
}
/**
 * Token: A higher order entity created for super tokens that are "valid" (tokens that have
 * Superfluid's host contract address set as the host).
 */
export declare type Token = {
    __typename?: 'Token';
    /** ID: the token address */
    id: Scalars['ID'];
    createdAtTimestamp: Scalars['BigInt'];
    createdAtBlockNumber: Scalars['BigInt'];
    decimals: Scalars['Int'];
    name: Scalars['String'];
    symbol: Scalars['String'];
    isSuperToken: Scalars['Boolean'];
    /** This indicates whether the token is a NativeAssetSuperToken. */
    isNativeAssetSuperToken: Scalars['Boolean'];
    /** This indicates whether the token is a part of our resolver list. */
    isListed: Scalars['Boolean'];
    /** The address of the underlying ERC20 token. */
    underlyingAddress: Scalars['Bytes'];
    /**
     * The underlying ERC20 token for a SuperToken or
     * null for a regular ERC20 token.
     */
    underlyingToken?: Maybe<Token>;
};
export declare type TokenDowngradedEvent = Event & {
    __typename?: 'TokenDowngradedEvent';
    id: Scalars['ID'];
    account: Account;
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token and account addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    amount: Scalars['BigInt'];
};
export declare type TokenDowngradedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    account?: Maybe<Scalars['String']>;
    account_not?: Maybe<Scalars['String']>;
    account_gt?: Maybe<Scalars['String']>;
    account_lt?: Maybe<Scalars['String']>;
    account_gte?: Maybe<Scalars['String']>;
    account_lte?: Maybe<Scalars['String']>;
    account_in?: Maybe<Array<Scalars['String']>>;
    account_not_in?: Maybe<Array<Scalars['String']>>;
    account_contains?: Maybe<Scalars['String']>;
    account_contains_nocase?: Maybe<Scalars['String']>;
    account_not_contains?: Maybe<Scalars['String']>;
    account_not_contains_nocase?: Maybe<Scalars['String']>;
    account_starts_with?: Maybe<Scalars['String']>;
    account_starts_with_nocase?: Maybe<Scalars['String']>;
    account_not_starts_with?: Maybe<Scalars['String']>;
    account_not_starts_with_nocase?: Maybe<Scalars['String']>;
    account_ends_with?: Maybe<Scalars['String']>;
    account_ends_with_nocase?: Maybe<Scalars['String']>;
    account_not_ends_with?: Maybe<Scalars['String']>;
    account_not_ends_with_nocase?: Maybe<Scalars['String']>;
    account_?: Maybe<Account_Filter>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    amount?: Maybe<Scalars['BigInt']>;
    amount_not?: Maybe<Scalars['BigInt']>;
    amount_gt?: Maybe<Scalars['BigInt']>;
    amount_lt?: Maybe<Scalars['BigInt']>;
    amount_gte?: Maybe<Scalars['BigInt']>;
    amount_lte?: Maybe<Scalars['BigInt']>;
    amount_in?: Maybe<Array<Scalars['BigInt']>>;
    amount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum TokenDowngradedEvent_OrderBy {
    Id = "id",
    Account = "account",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Amount = "amount"
}
/** TokenStatistic: An aggregate entity which aggregates data of a single `token`. */
export declare type TokenStatistic = {
    __typename?: 'TokenStatistic';
    /** id: token address */
    id: Scalars['ID'];
    updatedAtTimestamp: Scalars['BigInt'];
    updatedAtBlockNumber: Scalars['BigInt'];
    /** The total number of currently active `token` streams. */
    totalNumberOfActiveStreams: Scalars['Int'];
    /** The all-time number of closed streams. */
    totalNumberOfClosedStreams: Scalars['Int'];
    /** The total number of Indexes created with `token`. */
    totalNumberOfIndexes: Scalars['Int'];
    /**
     * The total number of "active" (has greater than 0 units and has distributed it at
     * least once) Indexes created with `token`.
     */
    totalNumberOfActiveIndexes: Scalars['Int'];
    /**
     * The number of subscriptions which have units allocated to them
     * created with Indexes that distribute `token`.
     */
    totalSubscriptionsWithUnits: Scalars['Int'];
    /** Counts all approved subscriptions whether or not they have units. */
    totalApprovedSubscriptions: Scalars['Int'];
    /** The total deposit held by the CFA agreement for this particular `token`. */
    totalDeposit: Scalars['BigInt'];
    /** The total outflow rate of the `token` (how much value is being moved). */
    totalOutflowRate: Scalars['BigInt'];
    /** The all-time total amount streamed (outflows) until the `updatedAtTimestamp`/`updatedAtBlock`. */
    totalAmountStreamedUntilUpdatedAt: Scalars['BigInt'];
    /** The all-time total amount transferred until the `updatedAtTimestamp`/`updatedAtBlock`. */
    totalAmountTransferredUntilUpdatedAt: Scalars['BigInt'];
    /** The all-time total amount distributed until the `updatedAtTimestamp`/`updatedAtBlock`. */
    totalAmountDistributedUntilUpdatedAt: Scalars['BigInt'];
    /**
     * The total supply of the token - this is impacted by users upgrading/downgrading their
     * tokens.
     */
    totalSupply: Scalars['BigInt'];
    token: Token;
    tokenStatisticLogs: Array<TokenStatisticLog>;
};
/** TokenStatistic: An aggregate entity which aggregates data of a single `token`. */
export declare type TokenStatisticTokenStatisticLogsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TokenStatisticLog_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TokenStatisticLog_Filter>;
};
/** TokenStatisticLog: Historical entries of TokenStatistic updates. */
export declare type TokenStatisticLog = {
    __typename?: 'TokenStatisticLog';
    id: Scalars['ID'];
    timestamp: Scalars['BigInt'];
    blockNumber: Scalars['BigInt'];
    transactionHash: Scalars['Bytes'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    triggeredByEventName: Scalars['String'];
    /** The total number of currently active `token` streams. */
    totalNumberOfActiveStreams: Scalars['Int'];
    /** The all-time number of closed streams. */
    totalNumberOfClosedStreams: Scalars['Int'];
    /** The total number of Indexes created with `token`. */
    totalNumberOfIndexes: Scalars['Int'];
    /**
     * The total number of "active" (has greater than 0 units and has distributed it at
     * least once) Indexes created with `token`.
     */
    totalNumberOfActiveIndexes: Scalars['Int'];
    /**
     * The number of subscriptions which have units allocated to them
     * created with Indexes that distribute `token`.
     */
    totalSubscriptionsWithUnits: Scalars['Int'];
    /** Counts all approved subscriptions whether or not they have units. */
    totalApprovedSubscriptions: Scalars['Int'];
    /** The total deposit held by the CFA agreement for this particular `token`. */
    totalDeposit: Scalars['BigInt'];
    /** The total outflow rate of the `token` (how much value is being moved). */
    totalOutflowRate: Scalars['BigInt'];
    /** The all-time total amount streamed (outflows) until the `timestamp`/`block`. */
    totalAmountStreamed: Scalars['BigInt'];
    /** The all-time total amount transferred until the `timestamp`/`block`. */
    totalAmountTransferred: Scalars['BigInt'];
    /** The all-time total amount distributed until the `timestamp`/`block`. */
    totalAmountDistributed: Scalars['BigInt'];
    /**
     * The total supply of the token - this is impacted by users upgrading/downgrading their
     * tokens.
     */
    totalSupply: Scalars['BigInt'];
    token: Token;
    tokenStatistic: TokenStatistic;
};
export declare type TokenStatisticLog_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    triggeredByEventName?: Maybe<Scalars['String']>;
    triggeredByEventName_not?: Maybe<Scalars['String']>;
    triggeredByEventName_gt?: Maybe<Scalars['String']>;
    triggeredByEventName_lt?: Maybe<Scalars['String']>;
    triggeredByEventName_gte?: Maybe<Scalars['String']>;
    triggeredByEventName_lte?: Maybe<Scalars['String']>;
    triggeredByEventName_in?: Maybe<Array<Scalars['String']>>;
    triggeredByEventName_not_in?: Maybe<Array<Scalars['String']>>;
    triggeredByEventName_contains?: Maybe<Scalars['String']>;
    triggeredByEventName_contains_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_not_contains?: Maybe<Scalars['String']>;
    triggeredByEventName_not_contains_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_starts_with?: Maybe<Scalars['String']>;
    triggeredByEventName_starts_with_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_not_starts_with?: Maybe<Scalars['String']>;
    triggeredByEventName_not_starts_with_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_ends_with?: Maybe<Scalars['String']>;
    triggeredByEventName_ends_with_nocase?: Maybe<Scalars['String']>;
    triggeredByEventName_not_ends_with?: Maybe<Scalars['String']>;
    triggeredByEventName_not_ends_with_nocase?: Maybe<Scalars['String']>;
    totalNumberOfActiveStreams?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_not?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_gt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_lt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_gte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_lte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfActiveStreams_not_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfClosedStreams?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_not?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_gt?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_lt?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_gte?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_lte?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfClosedStreams_not_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfIndexes?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_not?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_gt?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_lt?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_gte?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_lte?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfIndexes_not_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfActiveIndexes?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_not?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_gt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_lt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_gte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_lte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfActiveIndexes_not_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_not?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits_not_in?: Maybe<Array<Scalars['Int']>>;
    totalApprovedSubscriptions?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_not?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_gt?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_lt?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_gte?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_lte?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_in?: Maybe<Array<Scalars['Int']>>;
    totalApprovedSubscriptions_not_in?: Maybe<Array<Scalars['Int']>>;
    totalDeposit?: Maybe<Scalars['BigInt']>;
    totalDeposit_not?: Maybe<Scalars['BigInt']>;
    totalDeposit_gt?: Maybe<Scalars['BigInt']>;
    totalDeposit_lt?: Maybe<Scalars['BigInt']>;
    totalDeposit_gte?: Maybe<Scalars['BigInt']>;
    totalDeposit_lte?: Maybe<Scalars['BigInt']>;
    totalDeposit_in?: Maybe<Array<Scalars['BigInt']>>;
    totalDeposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalOutflowRate?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_not?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_gt?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_lt?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_gte?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_lte?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalOutflowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamed?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamed_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountTransferred?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_not?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_gt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_lt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_gte?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_lte?: Maybe<Scalars['BigInt']>;
    totalAmountTransferred_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountTransferred_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountDistributed?: Maybe<Scalars['BigInt']>;
    totalAmountDistributed_not?: Maybe<Scalars['BigInt']>;
    totalAmountDistributed_gt?: Maybe<Scalars['BigInt']>;
    totalAmountDistributed_lt?: Maybe<Scalars['BigInt']>;
    totalAmountDistributed_gte?: Maybe<Scalars['BigInt']>;
    totalAmountDistributed_lte?: Maybe<Scalars['BigInt']>;
    totalAmountDistributed_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountDistributed_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalSupply?: Maybe<Scalars['BigInt']>;
    totalSupply_not?: Maybe<Scalars['BigInt']>;
    totalSupply_gt?: Maybe<Scalars['BigInt']>;
    totalSupply_lt?: Maybe<Scalars['BigInt']>;
    totalSupply_gte?: Maybe<Scalars['BigInt']>;
    totalSupply_lte?: Maybe<Scalars['BigInt']>;
    totalSupply_in?: Maybe<Array<Scalars['BigInt']>>;
    totalSupply_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['String']>;
    token_not?: Maybe<Scalars['String']>;
    token_gt?: Maybe<Scalars['String']>;
    token_lt?: Maybe<Scalars['String']>;
    token_gte?: Maybe<Scalars['String']>;
    token_lte?: Maybe<Scalars['String']>;
    token_in?: Maybe<Array<Scalars['String']>>;
    token_not_in?: Maybe<Array<Scalars['String']>>;
    token_contains?: Maybe<Scalars['String']>;
    token_contains_nocase?: Maybe<Scalars['String']>;
    token_not_contains?: Maybe<Scalars['String']>;
    token_not_contains_nocase?: Maybe<Scalars['String']>;
    token_starts_with?: Maybe<Scalars['String']>;
    token_starts_with_nocase?: Maybe<Scalars['String']>;
    token_not_starts_with?: Maybe<Scalars['String']>;
    token_not_starts_with_nocase?: Maybe<Scalars['String']>;
    token_ends_with?: Maybe<Scalars['String']>;
    token_ends_with_nocase?: Maybe<Scalars['String']>;
    token_not_ends_with?: Maybe<Scalars['String']>;
    token_not_ends_with_nocase?: Maybe<Scalars['String']>;
    token_?: Maybe<Token_Filter>;
    tokenStatistic?: Maybe<Scalars['String']>;
    tokenStatistic_not?: Maybe<Scalars['String']>;
    tokenStatistic_gt?: Maybe<Scalars['String']>;
    tokenStatistic_lt?: Maybe<Scalars['String']>;
    tokenStatistic_gte?: Maybe<Scalars['String']>;
    tokenStatistic_lte?: Maybe<Scalars['String']>;
    tokenStatistic_in?: Maybe<Array<Scalars['String']>>;
    tokenStatistic_not_in?: Maybe<Array<Scalars['String']>>;
    tokenStatistic_contains?: Maybe<Scalars['String']>;
    tokenStatistic_contains_nocase?: Maybe<Scalars['String']>;
    tokenStatistic_not_contains?: Maybe<Scalars['String']>;
    tokenStatistic_not_contains_nocase?: Maybe<Scalars['String']>;
    tokenStatistic_starts_with?: Maybe<Scalars['String']>;
    tokenStatistic_starts_with_nocase?: Maybe<Scalars['String']>;
    tokenStatistic_not_starts_with?: Maybe<Scalars['String']>;
    tokenStatistic_not_starts_with_nocase?: Maybe<Scalars['String']>;
    tokenStatistic_ends_with?: Maybe<Scalars['String']>;
    tokenStatistic_ends_with_nocase?: Maybe<Scalars['String']>;
    tokenStatistic_not_ends_with?: Maybe<Scalars['String']>;
    tokenStatistic_not_ends_with_nocase?: Maybe<Scalars['String']>;
    tokenStatistic_?: Maybe<TokenStatistic_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum TokenStatisticLog_OrderBy {
    Id = "id",
    Timestamp = "timestamp",
    BlockNumber = "blockNumber",
    TransactionHash = "transactionHash",
    LogIndex = "logIndex",
    Order = "order",
    TriggeredByEventName = "triggeredByEventName",
    TotalNumberOfActiveStreams = "totalNumberOfActiveStreams",
    TotalNumberOfClosedStreams = "totalNumberOfClosedStreams",
    TotalNumberOfIndexes = "totalNumberOfIndexes",
    TotalNumberOfActiveIndexes = "totalNumberOfActiveIndexes",
    TotalSubscriptionsWithUnits = "totalSubscriptionsWithUnits",
    TotalApprovedSubscriptions = "totalApprovedSubscriptions",
    TotalDeposit = "totalDeposit",
    TotalOutflowRate = "totalOutflowRate",
    TotalAmountStreamed = "totalAmountStreamed",
    TotalAmountTransferred = "totalAmountTransferred",
    TotalAmountDistributed = "totalAmountDistributed",
    TotalSupply = "totalSupply",
    Token = "token",
    TokenStatistic = "tokenStatistic"
}
export declare type TokenStatistic_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    updatedAtTimestamp?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    updatedAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    updatedAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    updatedAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalNumberOfActiveStreams?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_not?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_gt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_lt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_gte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_lte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveStreams_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfActiveStreams_not_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfClosedStreams?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_not?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_gt?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_lt?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_gte?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_lte?: Maybe<Scalars['Int']>;
    totalNumberOfClosedStreams_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfClosedStreams_not_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfIndexes?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_not?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_gt?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_lt?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_gte?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_lte?: Maybe<Scalars['Int']>;
    totalNumberOfIndexes_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfIndexes_not_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfActiveIndexes?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_not?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_gt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_lt?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_gte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_lte?: Maybe<Scalars['Int']>;
    totalNumberOfActiveIndexes_in?: Maybe<Array<Scalars['Int']>>;
    totalNumberOfActiveIndexes_not_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_not?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lt?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_gte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_lte?: Maybe<Scalars['Int']>;
    totalSubscriptionsWithUnits_in?: Maybe<Array<Scalars['Int']>>;
    totalSubscriptionsWithUnits_not_in?: Maybe<Array<Scalars['Int']>>;
    totalApprovedSubscriptions?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_not?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_gt?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_lt?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_gte?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_lte?: Maybe<Scalars['Int']>;
    totalApprovedSubscriptions_in?: Maybe<Array<Scalars['Int']>>;
    totalApprovedSubscriptions_not_in?: Maybe<Array<Scalars['Int']>>;
    totalDeposit?: Maybe<Scalars['BigInt']>;
    totalDeposit_not?: Maybe<Scalars['BigInt']>;
    totalDeposit_gt?: Maybe<Scalars['BigInt']>;
    totalDeposit_lt?: Maybe<Scalars['BigInt']>;
    totalDeposit_gte?: Maybe<Scalars['BigInt']>;
    totalDeposit_lte?: Maybe<Scalars['BigInt']>;
    totalDeposit_in?: Maybe<Array<Scalars['BigInt']>>;
    totalDeposit_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalOutflowRate?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_not?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_gt?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_lt?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_gte?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_lte?: Maybe<Scalars['BigInt']>;
    totalOutflowRate_in?: Maybe<Array<Scalars['BigInt']>>;
    totalOutflowRate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountStreamedUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountStreamedUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountTransferredUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountTransferredUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountTransferredUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountDistributedUntilUpdatedAt?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_not?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_gt?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_lt?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_gte?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_lte?: Maybe<Scalars['BigInt']>;
    totalAmountDistributedUntilUpdatedAt_in?: Maybe<Array<Scalars['BigInt']>>;
    totalAmountDistributedUntilUpdatedAt_not_in?: Maybe<Array<Scalars['BigInt']>>;
    totalSupply?: Maybe<Scalars['BigInt']>;
    totalSupply_not?: Maybe<Scalars['BigInt']>;
    totalSupply_gt?: Maybe<Scalars['BigInt']>;
    totalSupply_lt?: Maybe<Scalars['BigInt']>;
    totalSupply_gte?: Maybe<Scalars['BigInt']>;
    totalSupply_lte?: Maybe<Scalars['BigInt']>;
    totalSupply_in?: Maybe<Array<Scalars['BigInt']>>;
    totalSupply_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['String']>;
    token_not?: Maybe<Scalars['String']>;
    token_gt?: Maybe<Scalars['String']>;
    token_lt?: Maybe<Scalars['String']>;
    token_gte?: Maybe<Scalars['String']>;
    token_lte?: Maybe<Scalars['String']>;
    token_in?: Maybe<Array<Scalars['String']>>;
    token_not_in?: Maybe<Array<Scalars['String']>>;
    token_contains?: Maybe<Scalars['String']>;
    token_contains_nocase?: Maybe<Scalars['String']>;
    token_not_contains?: Maybe<Scalars['String']>;
    token_not_contains_nocase?: Maybe<Scalars['String']>;
    token_starts_with?: Maybe<Scalars['String']>;
    token_starts_with_nocase?: Maybe<Scalars['String']>;
    token_not_starts_with?: Maybe<Scalars['String']>;
    token_not_starts_with_nocase?: Maybe<Scalars['String']>;
    token_ends_with?: Maybe<Scalars['String']>;
    token_ends_with_nocase?: Maybe<Scalars['String']>;
    token_not_ends_with?: Maybe<Scalars['String']>;
    token_not_ends_with_nocase?: Maybe<Scalars['String']>;
    token_?: Maybe<Token_Filter>;
    tokenStatisticLogs_?: Maybe<TokenStatisticLog_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum TokenStatistic_OrderBy {
    Id = "id",
    UpdatedAtTimestamp = "updatedAtTimestamp",
    UpdatedAtBlockNumber = "updatedAtBlockNumber",
    TotalNumberOfActiveStreams = "totalNumberOfActiveStreams",
    TotalNumberOfClosedStreams = "totalNumberOfClosedStreams",
    TotalNumberOfIndexes = "totalNumberOfIndexes",
    TotalNumberOfActiveIndexes = "totalNumberOfActiveIndexes",
    TotalSubscriptionsWithUnits = "totalSubscriptionsWithUnits",
    TotalApprovedSubscriptions = "totalApprovedSubscriptions",
    TotalDeposit = "totalDeposit",
    TotalOutflowRate = "totalOutflowRate",
    TotalAmountStreamedUntilUpdatedAt = "totalAmountStreamedUntilUpdatedAt",
    TotalAmountTransferredUntilUpdatedAt = "totalAmountTransferredUntilUpdatedAt",
    TotalAmountDistributedUntilUpdatedAt = "totalAmountDistributedUntilUpdatedAt",
    TotalSupply = "totalSupply",
    Token = "token",
    TokenStatisticLogs = "tokenStatisticLogs"
}
export declare type TokenUpgradedEvent = Event & {
    __typename?: 'TokenUpgradedEvent';
    id: Scalars['ID'];
    account: Account;
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token and account addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    token: Scalars['Bytes'];
    amount: Scalars['BigInt'];
};
export declare type TokenUpgradedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    account?: Maybe<Scalars['String']>;
    account_not?: Maybe<Scalars['String']>;
    account_gt?: Maybe<Scalars['String']>;
    account_lt?: Maybe<Scalars['String']>;
    account_gte?: Maybe<Scalars['String']>;
    account_lte?: Maybe<Scalars['String']>;
    account_in?: Maybe<Array<Scalars['String']>>;
    account_not_in?: Maybe<Array<Scalars['String']>>;
    account_contains?: Maybe<Scalars['String']>;
    account_contains_nocase?: Maybe<Scalars['String']>;
    account_not_contains?: Maybe<Scalars['String']>;
    account_not_contains_nocase?: Maybe<Scalars['String']>;
    account_starts_with?: Maybe<Scalars['String']>;
    account_starts_with_nocase?: Maybe<Scalars['String']>;
    account_not_starts_with?: Maybe<Scalars['String']>;
    account_not_starts_with_nocase?: Maybe<Scalars['String']>;
    account_ends_with?: Maybe<Scalars['String']>;
    account_ends_with_nocase?: Maybe<Scalars['String']>;
    account_not_ends_with?: Maybe<Scalars['String']>;
    account_not_ends_with_nocase?: Maybe<Scalars['String']>;
    account_?: Maybe<Account_Filter>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    amount?: Maybe<Scalars['BigInt']>;
    amount_not?: Maybe<Scalars['BigInt']>;
    amount_gt?: Maybe<Scalars['BigInt']>;
    amount_lt?: Maybe<Scalars['BigInt']>;
    amount_gte?: Maybe<Scalars['BigInt']>;
    amount_lte?: Maybe<Scalars['BigInt']>;
    amount_in?: Maybe<Array<Scalars['BigInt']>>;
    amount_not_in?: Maybe<Array<Scalars['BigInt']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum TokenUpgradedEvent_OrderBy {
    Id = "id",
    Account = "account",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Token = "token",
    Amount = "amount"
}
export declare type Token_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    createdAtTimestamp?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_not?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lt?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_gte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_lte?: Maybe<Scalars['BigInt']>;
    createdAtTimestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtTimestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_not?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lt?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_gte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_lte?: Maybe<Scalars['BigInt']>;
    createdAtBlockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    createdAtBlockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    decimals?: Maybe<Scalars['Int']>;
    decimals_not?: Maybe<Scalars['Int']>;
    decimals_gt?: Maybe<Scalars['Int']>;
    decimals_lt?: Maybe<Scalars['Int']>;
    decimals_gte?: Maybe<Scalars['Int']>;
    decimals_lte?: Maybe<Scalars['Int']>;
    decimals_in?: Maybe<Array<Scalars['Int']>>;
    decimals_not_in?: Maybe<Array<Scalars['Int']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    symbol?: Maybe<Scalars['String']>;
    symbol_not?: Maybe<Scalars['String']>;
    symbol_gt?: Maybe<Scalars['String']>;
    symbol_lt?: Maybe<Scalars['String']>;
    symbol_gte?: Maybe<Scalars['String']>;
    symbol_lte?: Maybe<Scalars['String']>;
    symbol_in?: Maybe<Array<Scalars['String']>>;
    symbol_not_in?: Maybe<Array<Scalars['String']>>;
    symbol_contains?: Maybe<Scalars['String']>;
    symbol_contains_nocase?: Maybe<Scalars['String']>;
    symbol_not_contains?: Maybe<Scalars['String']>;
    symbol_not_contains_nocase?: Maybe<Scalars['String']>;
    symbol_starts_with?: Maybe<Scalars['String']>;
    symbol_starts_with_nocase?: Maybe<Scalars['String']>;
    symbol_not_starts_with?: Maybe<Scalars['String']>;
    symbol_not_starts_with_nocase?: Maybe<Scalars['String']>;
    symbol_ends_with?: Maybe<Scalars['String']>;
    symbol_ends_with_nocase?: Maybe<Scalars['String']>;
    symbol_not_ends_with?: Maybe<Scalars['String']>;
    symbol_not_ends_with_nocase?: Maybe<Scalars['String']>;
    isSuperToken?: Maybe<Scalars['Boolean']>;
    isSuperToken_not?: Maybe<Scalars['Boolean']>;
    isSuperToken_in?: Maybe<Array<Scalars['Boolean']>>;
    isSuperToken_not_in?: Maybe<Array<Scalars['Boolean']>>;
    isNativeAssetSuperToken?: Maybe<Scalars['Boolean']>;
    isNativeAssetSuperToken_not?: Maybe<Scalars['Boolean']>;
    isNativeAssetSuperToken_in?: Maybe<Array<Scalars['Boolean']>>;
    isNativeAssetSuperToken_not_in?: Maybe<Array<Scalars['Boolean']>>;
    isListed?: Maybe<Scalars['Boolean']>;
    isListed_not?: Maybe<Scalars['Boolean']>;
    isListed_in?: Maybe<Array<Scalars['Boolean']>>;
    isListed_not_in?: Maybe<Array<Scalars['Boolean']>>;
    underlyingAddress?: Maybe<Scalars['Bytes']>;
    underlyingAddress_not?: Maybe<Scalars['Bytes']>;
    underlyingAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    underlyingAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    underlyingAddress_contains?: Maybe<Scalars['Bytes']>;
    underlyingAddress_not_contains?: Maybe<Scalars['Bytes']>;
    underlyingToken?: Maybe<Scalars['String']>;
    underlyingToken_not?: Maybe<Scalars['String']>;
    underlyingToken_gt?: Maybe<Scalars['String']>;
    underlyingToken_lt?: Maybe<Scalars['String']>;
    underlyingToken_gte?: Maybe<Scalars['String']>;
    underlyingToken_lte?: Maybe<Scalars['String']>;
    underlyingToken_in?: Maybe<Array<Scalars['String']>>;
    underlyingToken_not_in?: Maybe<Array<Scalars['String']>>;
    underlyingToken_contains?: Maybe<Scalars['String']>;
    underlyingToken_contains_nocase?: Maybe<Scalars['String']>;
    underlyingToken_not_contains?: Maybe<Scalars['String']>;
    underlyingToken_not_contains_nocase?: Maybe<Scalars['String']>;
    underlyingToken_starts_with?: Maybe<Scalars['String']>;
    underlyingToken_starts_with_nocase?: Maybe<Scalars['String']>;
    underlyingToken_not_starts_with?: Maybe<Scalars['String']>;
    underlyingToken_not_starts_with_nocase?: Maybe<Scalars['String']>;
    underlyingToken_ends_with?: Maybe<Scalars['String']>;
    underlyingToken_ends_with_nocase?: Maybe<Scalars['String']>;
    underlyingToken_not_ends_with?: Maybe<Scalars['String']>;
    underlyingToken_not_ends_with_nocase?: Maybe<Scalars['String']>;
    underlyingToken_?: Maybe<Token_Filter>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum Token_OrderBy {
    Id = "id",
    CreatedAtTimestamp = "createdAtTimestamp",
    CreatedAtBlockNumber = "createdAtBlockNumber",
    Decimals = "decimals",
    Name = "name",
    Symbol = "symbol",
    IsSuperToken = "isSuperToken",
    IsNativeAssetSuperToken = "isNativeAssetSuperToken",
    IsListed = "isListed",
    UnderlyingAddress = "underlyingAddress",
    UnderlyingToken = "underlyingToken"
}
export declare type TransferEvent = Event & {
    __typename?: 'TransferEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** Holds the token, from and to addresses. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    from: Account;
    to: Account;
    value: Scalars['BigInt'];
    token: Scalars['Bytes'];
};
export declare type TransferEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    from?: Maybe<Scalars['String']>;
    from_not?: Maybe<Scalars['String']>;
    from_gt?: Maybe<Scalars['String']>;
    from_lt?: Maybe<Scalars['String']>;
    from_gte?: Maybe<Scalars['String']>;
    from_lte?: Maybe<Scalars['String']>;
    from_in?: Maybe<Array<Scalars['String']>>;
    from_not_in?: Maybe<Array<Scalars['String']>>;
    from_contains?: Maybe<Scalars['String']>;
    from_contains_nocase?: Maybe<Scalars['String']>;
    from_not_contains?: Maybe<Scalars['String']>;
    from_not_contains_nocase?: Maybe<Scalars['String']>;
    from_starts_with?: Maybe<Scalars['String']>;
    from_starts_with_nocase?: Maybe<Scalars['String']>;
    from_not_starts_with?: Maybe<Scalars['String']>;
    from_not_starts_with_nocase?: Maybe<Scalars['String']>;
    from_ends_with?: Maybe<Scalars['String']>;
    from_ends_with_nocase?: Maybe<Scalars['String']>;
    from_not_ends_with?: Maybe<Scalars['String']>;
    from_not_ends_with_nocase?: Maybe<Scalars['String']>;
    from_?: Maybe<Account_Filter>;
    to?: Maybe<Scalars['String']>;
    to_not?: Maybe<Scalars['String']>;
    to_gt?: Maybe<Scalars['String']>;
    to_lt?: Maybe<Scalars['String']>;
    to_gte?: Maybe<Scalars['String']>;
    to_lte?: Maybe<Scalars['String']>;
    to_in?: Maybe<Array<Scalars['String']>>;
    to_not_in?: Maybe<Array<Scalars['String']>>;
    to_contains?: Maybe<Scalars['String']>;
    to_contains_nocase?: Maybe<Scalars['String']>;
    to_not_contains?: Maybe<Scalars['String']>;
    to_not_contains_nocase?: Maybe<Scalars['String']>;
    to_starts_with?: Maybe<Scalars['String']>;
    to_starts_with_nocase?: Maybe<Scalars['String']>;
    to_not_starts_with?: Maybe<Scalars['String']>;
    to_not_starts_with_nocase?: Maybe<Scalars['String']>;
    to_ends_with?: Maybe<Scalars['String']>;
    to_ends_with_nocase?: Maybe<Scalars['String']>;
    to_not_ends_with?: Maybe<Scalars['String']>;
    to_not_ends_with_nocase?: Maybe<Scalars['String']>;
    to_?: Maybe<Account_Filter>;
    value?: Maybe<Scalars['BigInt']>;
    value_not?: Maybe<Scalars['BigInt']>;
    value_gt?: Maybe<Scalars['BigInt']>;
    value_lt?: Maybe<Scalars['BigInt']>;
    value_gte?: Maybe<Scalars['BigInt']>;
    value_lte?: Maybe<Scalars['BigInt']>;
    value_in?: Maybe<Array<Scalars['BigInt']>>;
    value_not_in?: Maybe<Array<Scalars['BigInt']>>;
    token?: Maybe<Scalars['Bytes']>;
    token_not?: Maybe<Scalars['Bytes']>;
    token_in?: Maybe<Array<Scalars['Bytes']>>;
    token_not_in?: Maybe<Array<Scalars['Bytes']>>;
    token_contains?: Maybe<Scalars['Bytes']>;
    token_not_contains?: Maybe<Scalars['Bytes']>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum TransferEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    From = "from",
    To = "to",
    Value = "value",
    Token = "token"
}
export declare type TrustedForwarderChangedEvent = Event & {
    __typename?: 'TrustedForwarderChangedEvent';
    id: Scalars['ID'];
    transactionHash: Scalars['Bytes'];
    gasPrice: Scalars['BigInt'];
    timestamp: Scalars['BigInt'];
    name: Scalars['String'];
    /** The address of the governance contract the event was emitted from. */
    governanceAddress: Scalars['Bytes'];
    /** Empty addresses array. */
    addresses: Array<Scalars['Bytes']>;
    blockNumber: Scalars['BigInt'];
    logIndex: Scalars['BigInt'];
    order: Scalars['BigInt'];
    host: Scalars['Bytes'];
    superToken: Scalars['Bytes'];
    isKeySet: Scalars['Boolean'];
    forwarder: Scalars['Bytes'];
    enabled: Scalars['Boolean'];
};
export declare type TrustedForwarderChangedEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    transactionHash?: Maybe<Scalars['Bytes']>;
    transactionHash_not?: Maybe<Scalars['Bytes']>;
    transactionHash_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionHash_contains?: Maybe<Scalars['Bytes']>;
    transactionHash_not_contains?: Maybe<Scalars['Bytes']>;
    gasPrice?: Maybe<Scalars['BigInt']>;
    gasPrice_not?: Maybe<Scalars['BigInt']>;
    gasPrice_gt?: Maybe<Scalars['BigInt']>;
    gasPrice_lt?: Maybe<Scalars['BigInt']>;
    gasPrice_gte?: Maybe<Scalars['BigInt']>;
    gasPrice_lte?: Maybe<Scalars['BigInt']>;
    gasPrice_in?: Maybe<Array<Scalars['BigInt']>>;
    gasPrice_not_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp?: Maybe<Scalars['BigInt']>;
    timestamp_not?: Maybe<Scalars['BigInt']>;
    timestamp_gt?: Maybe<Scalars['BigInt']>;
    timestamp_lt?: Maybe<Scalars['BigInt']>;
    timestamp_gte?: Maybe<Scalars['BigInt']>;
    timestamp_lte?: Maybe<Scalars['BigInt']>;
    timestamp_in?: Maybe<Array<Scalars['BigInt']>>;
    timestamp_not_in?: Maybe<Array<Scalars['BigInt']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_contains_nocase?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_not_contains_nocase?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_starts_with_nocase?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with_nocase?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_ends_with_nocase?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with_nocase?: Maybe<Scalars['String']>;
    governanceAddress?: Maybe<Scalars['Bytes']>;
    governanceAddress_not?: Maybe<Scalars['Bytes']>;
    governanceAddress_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_not_in?: Maybe<Array<Scalars['Bytes']>>;
    governanceAddress_contains?: Maybe<Scalars['Bytes']>;
    governanceAddress_not_contains?: Maybe<Scalars['Bytes']>;
    addresses?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains?: Maybe<Array<Scalars['Bytes']>>;
    addresses_not_contains_nocase?: Maybe<Array<Scalars['Bytes']>>;
    blockNumber?: Maybe<Scalars['BigInt']>;
    blockNumber_not?: Maybe<Scalars['BigInt']>;
    blockNumber_gt?: Maybe<Scalars['BigInt']>;
    blockNumber_lt?: Maybe<Scalars['BigInt']>;
    blockNumber_gte?: Maybe<Scalars['BigInt']>;
    blockNumber_lte?: Maybe<Scalars['BigInt']>;
    blockNumber_in?: Maybe<Array<Scalars['BigInt']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex?: Maybe<Scalars['BigInt']>;
    logIndex_not?: Maybe<Scalars['BigInt']>;
    logIndex_gt?: Maybe<Scalars['BigInt']>;
    logIndex_lt?: Maybe<Scalars['BigInt']>;
    logIndex_gte?: Maybe<Scalars['BigInt']>;
    logIndex_lte?: Maybe<Scalars['BigInt']>;
    logIndex_in?: Maybe<Array<Scalars['BigInt']>>;
    logIndex_not_in?: Maybe<Array<Scalars['BigInt']>>;
    order?: Maybe<Scalars['BigInt']>;
    order_not?: Maybe<Scalars['BigInt']>;
    order_gt?: Maybe<Scalars['BigInt']>;
    order_lt?: Maybe<Scalars['BigInt']>;
    order_gte?: Maybe<Scalars['BigInt']>;
    order_lte?: Maybe<Scalars['BigInt']>;
    order_in?: Maybe<Array<Scalars['BigInt']>>;
    order_not_in?: Maybe<Array<Scalars['BigInt']>>;
    host?: Maybe<Scalars['Bytes']>;
    host_not?: Maybe<Scalars['Bytes']>;
    host_in?: Maybe<Array<Scalars['Bytes']>>;
    host_not_in?: Maybe<Array<Scalars['Bytes']>>;
    host_contains?: Maybe<Scalars['Bytes']>;
    host_not_contains?: Maybe<Scalars['Bytes']>;
    superToken?: Maybe<Scalars['Bytes']>;
    superToken_not?: Maybe<Scalars['Bytes']>;
    superToken_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_not_in?: Maybe<Array<Scalars['Bytes']>>;
    superToken_contains?: Maybe<Scalars['Bytes']>;
    superToken_not_contains?: Maybe<Scalars['Bytes']>;
    isKeySet?: Maybe<Scalars['Boolean']>;
    isKeySet_not?: Maybe<Scalars['Boolean']>;
    isKeySet_in?: Maybe<Array<Scalars['Boolean']>>;
    isKeySet_not_in?: Maybe<Array<Scalars['Boolean']>>;
    forwarder?: Maybe<Scalars['Bytes']>;
    forwarder_not?: Maybe<Scalars['Bytes']>;
    forwarder_in?: Maybe<Array<Scalars['Bytes']>>;
    forwarder_not_in?: Maybe<Array<Scalars['Bytes']>>;
    forwarder_contains?: Maybe<Scalars['Bytes']>;
    forwarder_not_contains?: Maybe<Scalars['Bytes']>;
    enabled?: Maybe<Scalars['Boolean']>;
    enabled_not?: Maybe<Scalars['Boolean']>;
    enabled_in?: Maybe<Array<Scalars['Boolean']>>;
    enabled_not_in?: Maybe<Array<Scalars['Boolean']>>;
    /** Filter for the block changed event. */
    _change_block?: Maybe<BlockChangedFilter>;
};
export declare enum TrustedForwarderChangedEvent_OrderBy {
    Id = "id",
    TransactionHash = "transactionHash",
    GasPrice = "gasPrice",
    Timestamp = "timestamp",
    Name = "name",
    GovernanceAddress = "governanceAddress",
    Addresses = "addresses",
    BlockNumber = "blockNumber",
    LogIndex = "logIndex",
    Order = "order",
    Host = "host",
    SuperToken = "superToken",
    IsKeySet = "isKeySet",
    Forwarder = "forwarder",
    Enabled = "enabled"
}
export declare type _Block_ = {
    __typename?: '_Block_';
    /** The hash of the block */
    hash?: Maybe<Scalars['Bytes']>;
    /** The block number */
    number: Scalars['Int'];
    /** Integer representation of the timestamp stored in blocks for the chain */
    timestamp?: Maybe<Scalars['Int']>;
};
/** The type for the top-level _meta field */
export declare type _Meta_ = {
    __typename?: '_Meta_';
    /**
     * Information about a specific subgraph block. The hash of the block
     * will be null if the _meta field has a block constraint that asks for
     * a block number. It will be filled if the _meta field has no block constraint
     * and therefore asks for the latest  block
     */
    block: _Block_;
    /** The deployment ID */
    deployment: Scalars['String'];
    /** If `true`, the subgraph encountered indexing errors at some past block */
    hasIndexingErrors: Scalars['Boolean'];
};
export declare enum _SubgraphErrorPolicy_ {
    /** Data will be returned even if the subgraph has indexing errors */
    Allow = "allow",
    /** If the subgraph has indexing errors, data will be omitted. The default. */
    Deny = "deny"
}
export declare type EventFragmentFragment = ({
    __typename?: 'FlowUpdatedEvent';
} & Pick<FlowUpdatedEvent, 'transactionHash' | 'blockNumber' | 'timestamp' | 'sender' | 'flowRate' | 'oldFlowRate' | 'type'>);
export declare type PaymentFragmentFragment = ({
    __typename?: 'SentEvent';
} & Pick<SentEvent, 'transactionHash' | 'blockNumber' | 'timestamp' | 'from' | 'amount'>);
export declare type GetSuperFluidEventsQueryVariables = Exact<{
    tokenAddress: Scalars['Bytes'];
    to: Scalars['Bytes'];
    reference: Scalars['Bytes'];
}>;
export declare type GetSuperFluidEventsQuery = ({
    __typename?: 'Query';
} & {
    untagged: Array<({
        __typename?: 'FlowUpdatedEvent';
    } & EventFragmentFragment)>;
    flow: Array<({
        __typename?: 'FlowUpdatedEvent';
    } & EventFragmentFragment)>;
    payment: Array<({
        __typename?: 'SentEvent';
    } & PaymentFragmentFragment)>;
});
export declare const EventFragmentFragmentDoc: import("graphql/language/ast").DocumentNode;
export declare const PaymentFragmentFragmentDoc: import("graphql/language/ast").DocumentNode;
export declare const GetSuperFluidEventsDocument: import("graphql/language/ast").DocumentNode;
export declare type SdkFunctionWrapper = <T>(action: (requestHeaders?: Record<string, string>) => Promise<T>, operationName: string) => Promise<T>;
export declare function getSdk(client: GraphQLClient, withWrapper?: SdkFunctionWrapper): {
    GetSuperFluidEvents(variables: GetSuperFluidEventsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetSuperFluidEventsQuery>;
};
export declare type Sdk = ReturnType<typeof getSdk>;
export declare const EventFragment: import("graphql/language/ast").DocumentNode;
export declare const PaymentFragment: import("graphql/language/ast").DocumentNode;
export declare const GetSuperFluidEvents: import("graphql/language/ast").DocumentNode;
//# sourceMappingURL=graphql-superfluid.d.ts.map