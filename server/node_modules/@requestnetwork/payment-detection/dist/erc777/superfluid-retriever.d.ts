import { PaymentTypes } from '@requestnetwork/types';
import { FlowUpdatedEvent, SentEvent } from '../thegraph/generated/graphql-superfluid';
import { TheGraphClientOptions } from '../thegraph/superfluid';
export declare class SuperFluidInfoRetriever {
    private paymentReference;
    private tokenContractAddress;
    private toAddress;
    private eventName;
    private network;
    private options?;
    private client;
    /**
     * @param paymentReference The reference to identify the payment
     * @param tokenContractAddress The address of the ERC777 contract
     * @param toAddress Address of the balance we want to check
     * @param eventName Indicate if it is an address for payment or refund
     * @param network The Ethereum network to use
     * @param options Extra options to GraphQL client
     */
    constructor(paymentReference: string, tokenContractAddress: string | null, toAddress: string, eventName: PaymentTypes.EVENTS_NAMES, network: string, options?: TheGraphClientOptions | undefined);
    private getGraphVariables;
    /**
     * Chronological sorting of events having payment reference and closing events without payment reference
     * @returns List of streaming events
     */
    protected getStreamingEvents(): Promise<Partial<FlowUpdatedEvent>[]>;
    /**
     * Chronological sorting of one off payment events having payment reference
     * @returns List of one off payment events
     */
    protected getOneOffPaymentEvents(): Promise<Partial<SentEvent>[]>;
    /**
     * First MVP version which convert :
     * stream events queried from SuperFluid subgraph
     * into payment events with the parameters expected by extractEvents function
     * to compute balance from amounts in ERC20 style transactions
     */
    getTransferEvents(): Promise<PaymentTypes.ERC777PaymentNetworkEvent[]>;
}
//# sourceMappingURL=superfluid-retriever.d.ts.map